
# C4 Sequence Diagram 生成要求

## 专家视角

作为 C4 时序图专家，你需要同时扮演：

1. **C4 架构专家**
   - 理解 C4 模型的层次结构（System、Container、Component）
   - 识别架构组件之间的交互模式
   - 将业务流程映射到技术组件

2. **时序图工程师**
   - 精通 PlantUML 时序图语法
   - 结合 C4 标注增强时序图表达
   - 掌握同步/异步消息表示方法

3. **流程分析师**
   - 理解业务流程的时间顺序
   - 识别关键交互点和数据流
   - 确保流程逻辑完整性

## 核心语法

### 图表声明

C4 时序图使用标准 PlantUML 时序图语法，结合 C4 注释：

### C4 Dynamic 图 vs 标准时序图

**标准时序图** (本文档主要内容):
- 使用 `!include <C4/C4_Container>` + PlantUML 时序图语法
- 适用于复杂的交互流程，支持分组、条件、循环

**C4 Dynamic 图** (简化版时序图):
- 使用 `!include <C4/C4_Dynamic>`
- 提供 `Rel_*()` 宏，支持自动编号关系
- 适用于简单的顺序交互，强调步骤编号
- 示例:
  ```plantuml
  @startuml
  !include <C4/C4_Dynamic>
  Rel(web, api, "POST /orders")
  Rel(api, db, "INSERT order")
  Rel(db, api, "order_id")
  @enduml
  ```

### 标准时序图示例

```plantuml
@startuml
!include <C4/C4_Container>
SHOW_PERSON_OUTLINE()  ' 可选，显示人形轮廓

title C4 Sequence - 用户下单流程

' 定义参与者（使用 C4 容器/组件）
participant "用户" as user
participant "Web应用" as web <<Container>>
participant "API网关" as api <<Container>>
participant "订单服务" as order <<Container>>
participant "支付服务" as payment <<Container>>
participant "数据库" as db <<Container>>

' 交互流程
user -> web: 提交订单
web -> api: POST /orders
api -> order: 创建订单
order -> db: 保存订单数据
db --> order: 订单ID
order --> api: 订单信息
api -> payment: 发起支付
payment --> api: 支付结果
api --> web: 下单成功
web --> user: 显示订单详情

@enduml
```

### 参与者定义

```plantuml
' 基础参与者
participant "名称" as alias

' C4 容器标注
participant "容器名" as alias <<Container>>

' C4 组件标注
participant "组件名" as alias <<Component>>

' C4 系统标注
participant "系统名" as alias <<System>>

' 外部系统标注
participant "外部系统" as alias <<External System>>
```

### 消息类型

```plantuml
' 同步调用（实线箭头）
A -> B: 同步消息

' 返回消息（虚线箭头）
B --> A: 返回结果

' 异步消息（实线箭头，无返回期望）
A ->> B: 异步消息

' 自调用
A -> A: 内部处理

' 激活生命线
activate B
B -> C: 处理
deactivate B
```

### 分组和注释

```plantuml
' 分组块
group 支付流程
    A -> B: 发起支付
    B -> C: 扣款
    C --> B: 扣款成功
    B --> A: 支付完成
end

' 条件分支
alt 支付成功
    A -> B: 创建订单
else 支付失败
    A -> B: 取消订单
end

' 循环
loop 重试3次
    A -> B: 请求
    B --> A: 响应
end

' 注释
note over A,B: 这是一个重要的交互点
```

## 生成示例

### 示例 1: 用户登录流程（简单场景）

**用户需求**：用户登录的 C4 时序图

**生成代码**：
```plantuml
@startuml
!include <C4/C4_Container>

title C4 Sequence - 用户登录流程

participant "用户" as user
participant "Web应用" as web <<Container>>
participant "认证服务" as auth <<Container>>
participant "用户数据库" as db <<Container>>

user -> web: 输入用户名密码
web -> auth: POST /auth/login
activate auth
auth -> db: 查询用户信息
activate db
db --> auth: 用户数据
deactivate db
auth -> auth: 验证密码
alt 验证成功
    auth --> web: 返回 Token
    web --> user: 登录成功
else 验证失败
    auth --> web: 认证失败
    web --> user: 显示错误信息
end
deactivate auth

@enduml
```

**关键点**：
- 使用 `<<Container>>` 标注 C4 容器
- `activate/deactivate` 显示组件活动时间
- `alt/else` 表示条件分支
- 返回消息使用虚线箭头 `-->`

### 示例 2: 订单处理流程（中等复杂度）

**用户需求**：电商订单处理的完整时序图

**生成代码**：
```plantuml
@startuml
!include <C4/C4_Container>

title C4 Sequence - 订单处理流程

participant "用户" as user
participant "Web应用" as web <<Container>>
participant "API网关" as api <<Container>>
participant "订单服务" as order <<Container>>
participant "库存服务" as inventory <<Container>>
participant "支付服务" as payment <<Container>>
participant "消息队列" as mq <<Container>>

user -> web: 提交订单
web -> api: POST /orders
api -> order: 创建订单请求

group 库存检查
    order -> inventory: 检查库存
    inventory --> order: 库存充足
    order -> inventory: 锁定库存
    inventory --> order: 锁定成功
end

group 支付处理
    order -> payment: 发起支付
    activate payment
    payment -> payment: 调用支付网关
    payment --> order: 支付成功
    deactivate payment
end

group 订单确认
    order -> mq: 发布订单确认消息
    order --> api: 订单创建成功
    api --> web: 返回订单信息
    web --> user: 显示订单详情
end

note over mq: 异步通知发货系统

@enduml
```

**关键点**：
- 使用 `group` 对相关交互分组
- 多个服务协同处理订单
- 包含消息队列的异步通知
- 使用 `note` 添加重要说明

### 示例 3: 微服务错误处理（高级场景）

**用户需求**：微服务架构下的错误处理和重试机制

**生成代码**：
```plantuml
@startuml
!include <C4/C4_Container>

title C4 Sequence - 微服务错误处理与重试

' === 参与者定义 ===
participant "API网关" as api <<Container>>
participant "订单服务" as order <<Container>>
participant "支付服务" as payment <<Container>>
participant "熔断器" as circuit <<Component>>
participant "重试队列" as retry <<Container>>
participant "监控服务" as monitor <<Container>>

' === 初始请求 ===
api -> order: 创建订单

' === 支付处理流程（含重试机制）===
group 支付处理（含重试）
    loop 最多重试3次
        order -> circuit: 检查熔断状态

        ' === 熔断器状态判断 ===
        alt 熔断器关闭
            circuit -> payment: 调用支付服务

            ' === 支付结果处理 ===
            alt 支付成功
                payment --> circuit: 成功响应
                circuit --> order: 支付完成
            else 支付超时
                payment --> circuit: 超时错误
                circuit -> monitor: 记录失败
                circuit --> order: 返回错误

                ' === 重试逻辑 ===
                alt 未达重试上限
                    order -> retry: 加入重试队列
                    note right: 延迟重试
                else 达到重试上限
                    order -> circuit: 触发熔断
                    circuit -> monitor: 熔断告警
                    order --> api: 支付失败
                end
            end

        ' === 熔断器开启情况 ===
        else 熔断器开启
            circuit --> order: 快速失败
            order --> api: 服务不可用
        end
    end
end

@enduml
```

**关键点**：
- 使用 `<<Component>>` 标注组件级别
- `loop` 表示重试逻辑
- 嵌套 `alt/else` 处理多种错误场景
- 展示熔断器模式的完整流程
- 包含监控和告警机制

## 常见错误

### 错误 1: 空 `!include` 语句（历史 60% 失败原因）

⚠️ **这是 C4-PlantUML 最致命的错误！** 空的 `!include` 会导致 Kroki 渲染完全失败。

**❌ 错误写法**：
```plantuml
@startuml
!include

participant "订单服务" as order <<Container>>
@enduml
```

**Kroki 错误信息**：
```
Error: Syntax error at line 2: !include directive requires a file path
Rendering failed: Invalid PlantUML syntax
```

**✅ 正确写法**：
```plantuml
@startuml
!include <C4/C4_Container>

title C4 Sequence - 订单处理流程

participant "订单服务" as order <<Container>>
@enduml
```

**原因**：
- `!include` 必须指定完整的文件路径（如 `<C4/C4_Container>`）
- 空的 `!include` 会导致 PlantUML 解析器崩溃
- Kroki 对此零容忍，必须移除或补全路径

**历史问题**：
- 这是导致 C4-PlantUML 历史 60% 生成失败的根本原因
- 早期 AI 模型经常生成空 `!include` 占位符

### 错误 2: 缺少 C4 标注

**❌ 错误写法**：
```plantuml
participant "订单服务" as order
```

**✅ 正确写法**：
```plantuml
participant "订单服务" as order <<Container>>
```

**原因**：C4 时序图应该标注组件类型（Container/Component/System），体现 C4 架构层次。

### 错误 3: 消息方向错乱

**❌ 错误写法**：
```plantuml
A -> B: 请求
A -> C: 响应
```

**✅ 正确写法**：
```plantuml
A -> B: 请求
B --> A: 响应
```

**原因**：响应消息应该使用虚线箭头 `-->` 并指向调用方。

### 错误 4: 缺少返回消息

**❌ 错误写法**：
```plantuml
web -> api: 请求数据
api -> db: 查询
```

**✅ 正确写法**：
```plantuml
web -> api: 请求数据
api -> db: 查询
db --> api: 返回结果
api --> web: 响应数据
```

**原因**：完整的交互应该包含请求和响应。

### 错误 5: 未使用分组

**❌ 错误写法**：
```plantuml
A -> B: 步骤1
B -> C: 步骤2
C -> D: 步骤3
```

**✅ 正确写法**：
```plantuml
group 业务流程
    A -> B: 步骤1
    B -> C: 步骤2
    C -> D: 步骤3
end
```

**原因**：使用 `group` 可以更清晰地组织相关交互。

### 错误 6: 生命线激活混乱

**❌ 错误写法**：
```plantuml
A -> B: 请求
activate B
A -> C: 另一个请求
deactivate B
```

**✅ 正确写法**：
```plantuml
A -> B: 请求
activate B
B -> B: 处理
B --> A: 响应
deactivate B

A -> C: 另一个请求
activate C
C --> A: 响应
deactivate C
```

**原因**：激活/去激活应该成对出现，表示组件的活动周期。

### 错误 7: 缺少标题

**❌ 错误写法**：
```plantuml
@startuml
participant A
@enduml
```

**✅ 正确写法**：
```plantuml
@startuml
title C4 Sequence - 业务流程名称
participant A
@enduml
```

**原因**：C4 图表应该有清晰的标题说明其用途。

## 生成检查清单

生成代码后，逐项检查：

- [ ] **包含 C4 库引用**：使用 `!include <C4/C4_Container>`
- [ ] **有清晰标题**：使用 `title C4 Sequence - ...`
- [ ] **C4 标注完整**：参与者标注 `<<Container>>` 等
- [ ] **消息方向正确**：请求用 `->`，响应用 `-->`
- [ ] **返回消息完整**：每个请求都有对应的响应
- [ ] **使用分组**：相关交互用 `group` 组织
- [ ] **生命线合理**：`activate/deactivate` 成对使用
- [ ] **代码可渲染**：语法正确，可直接通过 Kroki 渲染

**任何检查项不通过，立即修正后重新生成**
