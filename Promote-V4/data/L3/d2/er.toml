# ============================================
# L3 类型层: D2 ER 图 (Entity-Relationship Diagram)
# ============================================

[meta]
level = "L3"
language = "d2"
diagram_type = "er"
version = "1.0.0"
description = "D2 ER 图生成规范 - 数据库设计、实体关系建模、数据建模"
author = "DiagramAI Team"
created_at = "2025-10-19"
updated_at = "2025-10-19"

# 类型相关元数据
complexity = "medium"
target_length = 2800
use_cases = ["数据库设计", "实体关系建模", "数据模型设计", "Schema 设计"]

# ============================================
# Section 1: D 角色定义
# ============================================

[D_role]
additional_roles = [
  "数据库架构师 - 理解实体关系建模 (ER Modeling) 和数据库设计范式",
  "D2 SQL Table 工程师 - 精通 `shape: sql_table` 语法和约束定义",
  "数据建模专家 - 识别实体关系类型 (一对一、一对多、多对多)"
]

# ============================================
# Section 2: E 约束条件
# ============================================

[E_constraints]
items = [
  """
  **表声明必须使用 sql_table shape**:
  每个表必须使用 `shape: sql_table` 声明,否则会被渲染为普通容器。
  - ✅ 正确: `tableName: { shape: sql_table }`
  - ❌ 错误: `tableName: { }` (缺少 shape 声明)
  """,

  """
  **主键约束必需**:
  每个表都应该有主键约束,明确标识唯一记录。
  - ✅ 正确: `id: int {constraint: primary_key}`
  - ❌ 错误: `id: int` (缺少主键约束)
  """,

  """
  **外键关系箭头方向规范**:
  箭头应该从主表的主键指向从表的外键,表示数据引用方向。
  - ✅ 正确: `users.id -> orders.user_id: "1:N"`
  - ❌ 错误: `orders.user_id -> users.id` (方向反向)
  """,

  """
  **字段类型必须规范**:
  应使用标准 SQL 类型,而非通用类型。
  - ✅ 正确: `id: int`, `name: varchar(50)`, `created_at: timestamp`
  - ❌ 错误: `id: number`, `name: string` (非 SQL 类型)
  """,

  """
  **多对多关系使用中间表**:
  多对多关系需要通过中间表实现,不能直接连接两个表。
  - ✅ 正确: 通过 `user_products` 中间表连接 `users` 和 `products`
  - ❌ 错误: `users.id -> products.id: "M:N"` (直接连接)
  """,

  """
  **约束语法规范**:
  多个约束需要使用数组语法包裹。
  - ✅ 正确: `email: varchar(255) {constraint: [unique, not_null]}`
  - ❌ 错误: `email: varchar(255) constraint: unique, not_null` (语法错误)
  """,

  """
  **关系基数必须标注**:
  应明确标注关系基数 (1:1, 1:N, M:N),并使用箭头头部表示数量。
  - ✅ 正确: `users.id -> orders.user_id: "1:N" { source-arrowhead: 1; target-arrowhead: "*" }`
  - ❌ 错误: `users.id -> orders.user_id` (缺少基数标注)
  """,

  """
  **复合约束使用注释说明**:
  D2 不直接支持复合约束的语法表示,应通过注释说明:
  - 复合唯一约束: `# 注释: UNIQUE(user_id, role_id) - 防止重复分配角色`
  - 复合主键: `# 说明: (order_id, product_id) 组合作为主键`
  - 检查约束: `# 说明: price > 0 (价格必须为正数)`
  - 外键级联: `# 说明: ON DELETE CASCADE - 删除帖子时级联删除评论`
  """
]

# ============================================
# Section 3: P 流程规范
# ============================================

[P_process]
items = [
  """
  **1. 识别实体和属性**:
  - 确定系统中的核心实体 (用户、订单、商品等)
  - 分析每个实体的属性 (字段)
  - 确定字段的数据类型和约束
  - 识别主键和外键字段
  """,

  """
  **2. 设计表结构**:
  - 为每个实体创建表定义
  - 定义主键 (通常为 id 字段)
  - 定义必填字段 (not_null 约束)
  - 定义唯一字段 (unique 约束,如 email, username)
  - 定义外键字段 (foreign_key 约束)
  """,

  """
  **3. 识别实体关系**:
  - 一对一 (1:1): 用户-个人资料
  - 一对多 (1:N): 用户-订单, 订单-订单项
  - 多对多 (M:N): 学生-课程 (通过中间表)
  - 自关联: 员工-经理, 评论-父评论
  """,

  """
  **4. 应用 D2 语法**:
  - 为每个表声明 `shape: sql_table`
  - 使用 `constraint` 定义主键、外键、唯一性、非空
  - 使用箭头定义表关系 (主表.主键 -> 从表.外键)
  - 为关系添加基数标注 (1:1, 1:N, M:N)
  - 为关系添加箭头头部 (source-arrowhead, target-arrowhead)
  """,

  """
  **5. 优化和验证**:
  - 检查所有表都有主键定义
  - 验证外键关系方向正确 (主表 -> 从表)
  - 确认多对多关系使用中间表
  - 检查约束合理性 (如 email 唯一, username 唯一且非空)
  - 确保所有关系都有基数标注
  - 测试代码可在 Kroki 成功渲染
  """
]

# ============================================
# Section 4: H 质量标准
# ============================================

[H_quality]
items = [
  """
  **ER 图语法正确性**:
  - 所有表都声明 `shape: sql_table`
  - 所有表都有主键定义 (`constraint: primary_key`)
  - 字段类型规范 (使用标准 SQL 类型)
  - 外键字段标注 (`constraint: foreign_key`)
  - 约束语法正确 (单个约束或数组语法)
  - 代码可在 Kroki 成功渲染
  """,

  """
  **关系定义正确性**:
  - 关系方向正确 (箭头从主表主键指向从表外键)
  - 关系语法正确 (使用 `主表.主键 -> 从表.外键` 格式)
  - 关系基数标注 (使用 `1:1`, `1:N`, `M:N`)
  - 箭头头部完整 (一对多/一对一关系包含 `source-arrowhead` 和 `target-arrowhead`)
  - 多对多用中间表 (M:N 关系通过中间表实现,不直接连接)
  """,

  """
  **数据完整性**:
  - 外键完整性: 所有外键字段都有对应的关系箭头
  - 关系完整性: 所有关系箭头的字段都在表中定义
  - 约束合理性: 约束符合业务逻辑 (如 email 唯一, username 唯一且非空)
  - 中间表设计: 中间表包含两端的外键,通常还有主键
  - 自关联处理: 自关联关系使用虚线样式区分
  """,

  """
  **命名规范和设计质量**:
  - 表名使用复数 (users, orders, products)
  - 外键命名清晰 (user_id, order_id 明确指向的表)
  - 下划线命名法 (created_at, updated_at)
  - 布尔字段前缀 (is_active, is_deleted)
  - 中间表命名 (user_roles, order_items 体现关联关系)
  - 符合数据库范式要求,避免冗余
  """
]

# ============================================
# Section 5: 使用场景
# ============================================

[[use_cases]]
title = "用户-订单系统"
scenario = "展示用户和订单的基本关系 (一对多)"
key_points = [
  "使用 `shape: sql_table` 声明 SQL 表",
  "使用 `constraint: primary_key` 定义主键",
  "使用 `constraint: foreign_key` 定义外键",
  "使用箭头表示表之间的关系 (users.id -> orders.user_id)",
  "使用 `1:N` 标签表示一对多关系"
]

[[use_cases]]
title = "电商系统 ER 图"
scenario = "展示用户、商品、订单和订单项的完整关系"
key_points = [
  "使用中间表 `order_items` 实现订单和商品的多对多关系",
  "每个表都有明确的主键和外键",
  "使用描述性关系标签 (places, contains, included in)",
  "字段定义完整,包含约束和类型",
  "使用 `source-arrowhead` 和 `target-arrowhead` 标识关系基数"
]

[[use_cases]]
title = "社交网络系统"
scenario = "展示用户、帖子、评论、点赞和关注关系的完整数据模型"
key_points = [
  "多对多关系通过中间表实现 (likes, follows)",
  "自关联关系 (comments.parent_id, follows 用户关注用户)",
  "使用虚线样式区分特殊关系 (自关联)",
  "完整的社交网络数据模型",
  "考虑了计数器字段 (likes_count, comments_count) 用于性能优化"
]
