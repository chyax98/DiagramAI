# Promote V3 提示词架构规范

> **竞技方案**: 保留旧版精华 + DEPTH 框架重组 + 示例优化
> **核心理念**: 信息密度优先,避免过度压缩导致质量损失

---

## 📊 设计原则

### 1. 动态长度分配 (总计 ≤ 5000 字)

**核心理念**: 根据语言/类型的实际复杂度动态调整,不强制统一字数

```yaml
复杂度评估:
  简单语言/类型: L1(800) + L2(600) + L3(400) ≈ 1800 字
    示例: Nomnoml, BPMN

  中等复杂度: L1(1200) + L2(1000) + L3(600) ≈ 2800 字
    示例: D2, Graphviz, WaveDrom

  高复杂度: L1(1500) + L2(1500) + L3(1000) ≈ 4000 字
    示例: Mermaid, PlantUML, Structurizr

总预算上限: 5000 字 (≈ 7500 tokens)
```

**复杂度判断标准**:

- 保留关键字数量 (越多越复杂)
- 图表类型数量 (越多越复杂)
- 特殊语法规则 (越多越复杂)
- 引擎限制条目 (越多越复杂)

### 2. 强制 DEPTH 框架

**所有文件必须严格遵循五段式结构**:

```markdown
# D (Define)

角色定义与协作目标

# E (Establish)

成功指标与硬约束

# P (Provide)

背景信息与环境设定

# T (Task)

执行任务与操作流程

# H (Human)

自检回路与复核清单
```

**禁止**:

- ❌ 使用其他段落结构
- ❌ 省略任何 DEPTH 段落
- ❌ 改变段落顺序
- ❌ 使用二级/三级标题替代

### 3. 核心创新点

**保留旧版优势**:

- ✅ `<<<SYSTEM_INSTRUCTION>>>` 任务指令系统 (这是核心竞争力)
- ✅ 三专家角色模型 (需求分析/图表设计/代码实现)
- ✅ 强制规则 vs 最佳实践的分级体系

**新增 DEPTH 框架**:

- ✅ 统一结构,便于维护和更新
- ✅ 层级清晰,避免重复内容
- ✅ 可组合性,支持动态拼接

**示例优化策略**:

- ✅ 每个规则最多 1 正例 + 1 反例
- ✅ 精选高频错误场景
- ✅ 去除冗余的多示例堆叠

---

## 🏗️ DEPTH 框架映射

### D (Define) - 角色定义

| 层级   | 内容                                                   | 动态字数 |
| ------ | ------------------------------------------------------ | -------- |
| **L1** | 固定三专家角色 (需求分析/图表设计/代码实现) + 协作目标 | 100-200  |
| **L2** | 语言特定角色 (如 Mermaid 语法稽核员),无则留空或简述    | 0-150    |
| **L3** | 类型特定角色 (如流程图业务审校员),无则留空             | 0-100    |

**拼接策略**: 合并为连续自然语言,不暴露层级标记
**质量原则**: 有实质内容才写,没有就留空段落,禁止凑字数

---

### E (Establish) - 成功指标

| 层级   | 内容                                                   | 动态字数 |
| ------ | ------------------------------------------------------ | -------- |
| **L1** | 任务指令系统 (<<<SYSTEM_INSTRUCTION>>>) + 通用成功标准 | 400-800  |
| **L2** | 语言硬约束 (保留字/转义/声明格式),复杂语言可详细       | 200-800  |
| **L3** | 类型必备元素,简单类型可精简                            | 100-400  |

**关键要求**:

- L1 必须包含完整的任务指令说明 (生成/调整/修复三模式)
- L2 根据复杂度调整: 简单语言精简列举,复杂语言详细说明+示例
- L3 根据类型特点调整: 简单类型仅列关键项,复杂类型需详细约束

---

### P (Provide) - 背景信息

| 层级   | 内容                                   | 动态字数 |
| ------ | -------------------------------------- | -------- |
| **L1** | 系统背景 (DiagramAI/中文优先/输出格式) | 150-300  |
| **L2** | 渲染引擎限制,有限制才写,无则留空       | 0-300    |
| **L3** | 业务场景,有特殊场景才写                | 0-200    |

**拼接策略**: 仅挑选与当前请求相关的上下文,重写为 1 段自然描述
**质量原则**: 背景信息要有实质帮助,避免空洞的描述

---

### T (Task) - 执行任务

| 层级   | 内容                                              | 动态字数 |
| ------ | ------------------------------------------------- | -------- |
| **L1** | 任务分流逻辑 (生成/调整/修复的判别条件与执行要点) | 300-600  |
| **L2** | 语言特有步骤,有独特流程才写                       | 0-400    |
| **L3** | 类型操作骨架,根据复杂度详略得当                   | 100-500  |

**拼接策略**: 转写为"工作流程"句子列表,不保留层级标记
**质量原则**: 简单语言/类型精简流程,复杂的需要详细步骤指导

---

### H (Human) - 自检回路

| 层级   | 内容                                   | 动态字数 |
| ------ | -------------------------------------- | -------- |
| **L1** | 统一自检框架 (语法/结构/需求 ≥8 分)    | 100-200  |
| **L2** | 语言复核列表,复杂语言详细,简单语言精简 | 50-300   |
| **L3** | 类型复核列表,根据类型复杂度调整        | 50-200   |

**拼接策略**: 合并为一段"自检指引",避免层级称谓
**质量原则**: 复核项要具体可执行,避免模糊的"检查是否正确"

---

## 📝 写作规范

### 通用要求

1. **结构统一**: 所有文件使用 Markdown 一级标题 `# D`、`# E`、`# P`、`# T`、`# H`
2. **语言简洁**: 避免冗余表达,使用命令式或陈述式
3. **无层级暴露**: 不出现 "L1/L2/L3" 字样,内容直接描述
4. **占位符规范**: 使用 `{language}`、`{diagram_type}` 等占位符,确保可替换

### L1 特殊要求

**必须包含的核心内容**:

1. **任务指令系统** (300-400字)

   ```markdown
   ## ⚠️ 任务识别 (最高优先级)

   每条消息开头包含 `<<<SYSTEM_INSTRUCTION>>>` 标记:

   ### 1. GENERATE_NEW_DIAGRAM

   - 触发: 点击"生成图表"
   - 执行: 理解需求 → 设计结构 → 从零编写
   - 禁止: 参考现有代码

   ### 2. ADJUST_EXISTING_DIAGRAM

   - 触发: 点击"调整"
   - 执行: 分析现有 → 定位修改 → 最小化改动
   - 禁止: 完全重写

   ### 3. FIX_SYNTAX_ERRORS_ONLY

   - 触发: 点击"修复"
   - 执行: 识别错误 → 仅修复语法 → 保持其他不变
   - 禁止: 改逻辑/结构/内容
   ```

2. **DEPTH 五段式** (900-1100字)
   - D: 三专家角色定义
   - E: 通用成功标准
   - P: DiagramAI 系统背景
   - T: 任务分流与执行骨架
   - H: 自检框架

### L2 特殊要求

**必须包含的核心内容**:

1. **语法硬规则** (400-500字)
   - 保留关键字列表 (精选高频冲突词,不完整枚举)
   - 特殊字符转义规则
   - 声明格式要求
   - 示例: 每个规则 1 正例 + 1 反例

2. **引擎限制** (200-250字)
   - Kroki 渲染引擎版本
   - 语言特定限制

3. **DEPTH 补充** (200-250字)
   - D: 语言特定角色 (可选)
   - E: 语言红线
   - T: 语言特有步骤
   - H: 语言复核列表

### L3 特殊要求

**必须包含的核心内容**:

1. **类型特定规则** (300-400字)
   - 必备结构元素
   - 类型约束
   - 示例: 1-2 个精选场景

2. **操作骨架** (200-300字)
   - 节点/连线步骤
   - 布局建议
   - 数量约束

3. **DEPTH 补充** (100-100字)
   - D: 类型角色
   - E: 类型红线
   - T: 类型骨架
   - H: 类型复核

---

## 🔧 拼接与组装

### 拼接流程

```
1. 根据 {language} 和 {diagram_type} 选择文件
   - L1: Promote-V3/L1.md
   - L2: Promote-V3/L2-{language}.md
   - L3: Promote-V3/L3-{language}-{type}.md

2. 按 DEPTH 段落提取内容
   - D: 合并三层的 Define 段
   - E: 合并三层的 Establish 段
   - P: 合并三层的 Provide 段
   - T: 合并三层的 Task 段
   - H: 合并三层的 Human 段

3. 重写为自然语言
   - 去除层级标记和重复术语
   - 改写为连续段落
   - 替换占位符

4. 验证总长度
   - 目标: ≤ 3300 字 (≈ 5000 tokens)
   - 超出时优先裁剪 L3 非硬性内容
```

### 输出格式

```markdown
你同时扮演需求分析专家、图表架构师、代码实现工程师、{L2*角色}、{L3*角色},
协作目标是将用户输入转化为可直接渲染的高质量 {language} {diagram_type} 代码。

⚠️ 任务识别 (最高优先级):
每条消息开头的 <<<SYSTEM_INSTRUCTION>>> 标记决定执行模式...
[完整的任务指令说明]

成功指标:

- 输出必须零语法错误并覆盖需求
- {L1\_通用标准}
- {L2\_语言红线}
- {L3\_类型必备}

背景信息:
{L1*系统背景} + {L2*引擎限制} + {L3\_业务场景}

执行任务:
{L1*任务分流} + {L2*语言步骤} + {L3\_类型骨架}

自检回路:
{L1*自检框架} + {L2*语言复核} + {L3\_类型复核}
```

---

## 📋 文件清单

### 必需文件

```
Promote-V3/
├── Promote-V3-Spec.md          # 本文档
├── L1.md                       # 通用层 (1200-1500字)
├── L2-mermaid.md               # Mermaid 语言层 (800-1000字)
├── L2-plantuml.md              # PlantUML 语言层 (800-1000字)
├── L2-d2.md                    # D2 语言层 (800-1000字)
├── L3-mermaid-flowchart.md     # Mermaid 流程图 (600-800字)
├── L3-mermaid-sequence.md      # Mermaid 时序图 (600-800字)
├── L3-plantuml-sequence.md     # PlantUML 时序图 (600-800字)
└── ...                         # 其他核心类型
```

### 优先级 (并行编写)

**Phase 1**: 基础框架 (并行启动 2 个 agents)

- [ ] L1.md (通用层)
- [ ] L2-mermaid.md (主力语言)

**Phase 2**: 主流语言 (并行启动 2 个 agents)

- [ ] L2-plantuml.md
- [ ] L2-d2.md

**Phase 3**: 核心类型 (并行启动 3 个 agents)

- [ ] L3-mermaid-flowchart.md
- [ ] L3-mermaid-sequence.md
- [ ] L3-plantuml-sequence.md

---

## 🎯 质量标准

### 必须满足

1. **字数控制**: 每个文件严格控制在规定范围内
2. **结构统一**: 所有文件使用相同的 DEPTH 框架
3. **信息准确**: 所有语法规则和限制经过验证
4. **示例精选**: 避免冗余示例,每规则最多 2 个

### 验证方法

```bash
# 字数统计
wc -m Promote-V3/*.md

# 结构检查
grep "^# [DEPTH]" Promote-V3/*.md

# 拼接测试
node scripts/assemble-prompts.js --test
```

---

## 🏆 竞争优势

**相比 V2 方案**:

1. ✅ 保留了旧版的任务指令系统 (V2 可能丢失)
2. ✅ 字数预算更合理 (3000字 vs V2 的 700字)
3. ✅ 信息密度更高 (保留精华,去除冗余)
4. ✅ 可维护性更好 (DEPTH 框架 + 清晰分层)

**测试指标**:

- 语法错误率 (越低越好)
- 需求覆盖度 (越高越好)
- 首次渲染成功率 (越高越好)
- 调整准确性 (越精确越好)

---

## 📌 注意事项

1. **保留关键字处理**: 不在提示词中完整枚举,仅列举高频冲突词
2. **示例策略**: 优先选择真实用户场景的错误案例
3. **版本管理**: 每次更新需同步修改 Spec 和对应文件
4. **测试优先**: 所有提示词必须经过实际渲染测试

---

## 🚀 下一步

1. 并行启动多个 Task agents 编写文件
2. 完成后进行拼接测试
3. 与 V2 方案进行 A/B 测试对比
4. 根据测试结果优化迭代
