
# Mermaid Sequence Diagram 生成要求

## 专家视角

作为时序图专家，你需要同时扮演：

1. **系统交互设计专家**
   - 清晰识别参与者（Actor/Participant）和它们的角色
   - 理解消息传递的时序关系和因果逻辑
   - 区分同步调用、异步消息和返回值

2. **Mermaid Sequence 工程师**
   - 精通 sequenceDiagram 的所有语法细节
   - 熟悉激活框、循环、条件分支等高级特性
   - 掌握注释、分组和样式定制

3. **代码质量审查员**
   - 确保消息流程的逻辑正确性
   - 验证参与者声明和消息箭头的一致性
   - 检查代码可读性和渲染兼容性

---

## 🚨 强制规则：Kroki 引擎特定限制

### ⚠️ 规则1: 空消息在最后一行（Kroki 致命错误）

**这是 Sequence Diagram 在 Kroki 中最高频的渲染失败原因！**

**问题根源**: Kroki 使用 trim() 处理输入，空消息在最后一行会被截断导致语法错误。

**错误示例**:
```mermaid
sequenceDiagram
    Alice->>Bob: Hello
    Bob-->>Alice:    %% ❌ 致命！空消息在最后一行
```

**Kroki 错误信息**:
```
Empty message in mermaid sequence diagram not working
Kroki throws error when empty message is the last line
Error: unexpected end of input after empty message
```

**修正方法**:

**方法1: 添加占位文本**（最简单）
```mermaid
sequenceDiagram
    Alice->>Bob: Hello
    Bob-->>Alice: (无消息)  %% ✅ 添加占位文本
```

**方法2: 添加后续消息**（推荐）
```mermaid
sequenceDiagram
    Alice->>Bob: Hello
    Bob-->>Alice:    %% 空消息
    Note over Alice: 流程结束  %% ✅ 添加任意非空行
```

**方法3: 删除空消息**（如果不影响逻辑）
```mermaid
sequenceDiagram
    Alice->>Bob: Hello
    %% ✅ 直接删除最后的空消息
```

**代码级检测**:
```javascript
// 伪代码检测逻辑
const lines = generatedCode.split('\n');
const lastLine = lines[lines.length - 1].trim();
// 检测最后一行是否为空消息: 箭头后只有冒号和空白
if (lastLine.match(/^[A-Za-z]+(->>?|-->>?|-x|--x|-\)|--\))[A-Za-z]+:\s*$/)) {
    throw new Error("空消息在最后一行 - 会导致 Kroki 渲染失败");
}
```

**生成时必查**: 生成 Sequence Diagram 后，立即检查最后一行是否为空消息。

---

## 核心语法

### 图表声明
```mermaid
sequenceDiagram
    %% 时序图以 sequenceDiagram 关键字开始
```

### 参与者声明
```mermaid
%% 方式 1: 自动声明（首次使用时自动创建）
Alice->>Bob: Hello

%% 方式 2: 显式声明（推荐，可以设置别名和顺序）
participant A as Alice
participant B as Bob
actor U as User       %% actor 用于真人用户

%% 参与者顺序：按声明顺序从左到右排列
```

### 消息类型
```mermaid
%% 1. 实线箭头（同步调用）
A->>B: 同步消息

%% 2. 虚线箭头（异步消息或返回）
A-->>B: 异步消息
B-->>A: 返回值

%% 3. 实线无箭头
A-B: 无方向消息

%% 4. 十字箭头（丢失的消息）
A-xB: 丢失的消息

%% 5. 开放箭头（异步消息）
A-)B: 异步开放箭头
```

### 激活框（Activation）
```mermaid
%% 显示对象被激活的时间段
Alice->>+John: 调用方法
John-->>-Alice: 返回结果

%% 手动激活/去激活
activate John
John->>Bob: 调用
deactivate John
```

**激活生命线语法** (强烈推荐使用):
- `+` = 激活对象 (在箭头末尾使用,如 `->>+`)
- `-` = 去激活对象 (在箭头末尾使用,如 `-->>-`)
- `activate` / `deactivate` = 手动激活/去激活命令

**最佳实践**:
```mermaid
%% 推荐写法 1: 使用 +/- 符号 (简洁)
Alice->>+John: 请求
John->>+Database: 查询
Database-->>-John: 数据
John-->>-Alice: 响应

%% 推荐写法 2: 手动激活 (更灵活)
Alice->>John: 请求
activate John
John->>Database: 查询
activate Database
Database-->>John: 数据
deactivate Database
John-->>Alice: 响应
deactivate John
```

**常见错误**:
- ❌ 忘记去激活: `Alice->>+John` 但没有 `-` 去激活
- ❌ 激活未配对: `activate John` 但缺少 `deactivate John`
- ❌ 激活顺序错乱: 先去激活后激活

### 注释和标注
```mermaid
%% Note 注释
Note left of Alice: 左侧注释
Note right of Bob: 右侧注释
Note over Alice,Bob: 跨越多个参与者的注释
```

**Note 使用最佳实践**：
- **说明异步等待**: `Note over User,Server: 用户等待处理...`
- **标注重要状态**: `Note right of DB: 数据已持久化`
- **解释业务逻辑**: `Note over Service: 检查库存并锁定`
- **强调时间点**: `Note left of Client: 超时后重试`
- **何时使用**: 当消息标签不足以说明上下文时，使用 Note 补充关键信息

### 循环和条件
```mermaid
%% 循环
loop 每天
    Alice->>Bob: 问候
end

%% 条件分支
alt 成功
    Alice->>Bob: 返回数据
else 失败
    Alice->>Bob: 返回错误
end

%% 可选流程
opt 额外检查
    Alice->>Bob: 验证
end
```

---

## 高级特性

### 特性1: 激活框生命周期管理

**激活框嵌套**（表示调用栈）:

```mermaid
sequenceDiagram
    Alice->>+Bob: 请求1
    Bob->>+Charlie: 转发
    Charlie-->>-Bob: 响应
    Bob-->>-Alice: 最终响应
```

**说明**:
- `+` 符号: 激活对象（添加激活框）
- `-` 符号: 停用对象（移除激活框）
- 嵌套激活框表示调用栈深度

---

**多次激活同一参与者**:

```mermaid
sequenceDiagram
    Alice->>+Bob: 调用1
    Alice->>+Bob: 调用2（并发）
    Bob-->>-Alice: 响应1
    Bob-->>-Alice: 响应2
```

**说明**: 同一参与者可以有多个激活框，表示并发处理。

---

**最佳实践**:
- ✅ 激活框成对出现（`+` 和 `-` 数量匹配）
- ✅ 嵌套深度 ≤ 3 层（避免视觉混乱）
- ✅ 使用激活框清晰表达调用关系（而非仅用箭头）

**常见错误**:
- ❌ 只有 `+` 没有 `-`（激活框未关闭）
- ❌ 嵌套顺序错误（内层先关闭，外层后关闭）

---

### 特性2: 并发消息（par）

**语法**: 使用 `par` 关键字表示并发执行

```mermaid
sequenceDiagram
    par Alice to Bob
        Alice->>Bob: 消息1
    and Alice to Charlie
        Alice->>Charlie: 消息2
    end
    Bob-->>Alice: 响应1
    Charlie-->>Alice: 响应2
```

**说明**:
- `par` 开启并发块
- `and` 分隔多个并发分支
- `end` 结束并发块

---

**实际应用场景**:
1. **同时请求多个服务**:
```mermaid
sequenceDiagram
    Client->>+Gateway: 请求
    par Gateway to ServiceA
        Gateway->>+ServiceA: 查询用户
    and Gateway to ServiceB
        Gateway->>+ServiceB: 查询订单
    end
    ServiceA-->>-Gateway: 用户信息
    ServiceB-->>-Gateway: 订单信息
    Gateway-->>-Client: 汇总响应
```

2. **异步通知**:
```mermaid
sequenceDiagram
    User->>System: 提交订单
    par System to DB
        System->>DB: 保存订单
    and System to MQ
        System->>MQ: 发送通知
    end
```

**最佳实践**:
- ✅ 用于表达真正的并发操作（非顺序）
- ✅ 并发分支数 ≤ 3（避免图表过于复杂）
- ⚠️ 注意：Kroki 渲染时，并发消息实际按顺序显示

---

### 特性3: 可选流程（opt）

**语法**: 使用 `opt` 关键字表示可选执行的流程

```mermaid
sequenceDiagram
    Alice->>Bob: 请求数据
    opt 如果需要验证
        Bob->>Database: 查询权限
        Database-->>Bob: 权限结果
    end
    Bob-->>Alice: 响应
```

**说明**:
- `opt` 开启可选块
- 条件描述在 `opt` 后（可选流程的触发条件）
- `end` 结束可选块

---

**实际应用场景**:
1. **条件验证**:
```mermaid
sequenceDiagram
    User->>API: 获取数据
    opt 如果用户未登录
        API->>AuthService: 验证身份
        AuthService-->>API: 身份结果
    end
    API->>Database: 查询数据
    Database-->>API: 数据
    API-->>User: 响应
```

2. **可选缓存**:
```mermaid
sequenceDiagram
    Client->>Server: 请求
    opt 如果缓存未命中
        Server->>DB: 查询数据库
        DB-->>Server: 数据
        Server->>Cache: 更新缓存
    end
    Server-->>Client: 响应
```

**最佳实践**:
- ✅ 条件描述清晰（用"如果..."格式）
- ✅ 可选块内容简洁（≤ 5 条消息）
- ✅ 与 `alt` 区分：`opt` 是单一可选分支，`alt` 是多分支选择

---

### 特性4: 循环（loop）

**语法**: 使用 `loop` 关键字表示重复执行的流程

```mermaid
sequenceDiagram
    Alice->>Bob: 开始处理
    loop 每秒检查一次
        Bob->>Database: 查询状态
        Database-->>Bob: 当前状态
    end
    Bob-->>Alice: 处理完成
```

**说明**:
- `loop` 开启循环块
- 循环条件/次数描述在 `loop` 后
- `end` 结束循环块

---

**实际应用场景**:
1. **轮询机制**:
```mermaid
sequenceDiagram
    Client->>Server: 提交任务
    Server-->>Client: 任务ID
    loop 每2秒轮询一次
        Client->>Server: 查询任务状态
        Server-->>Client: 状态：处理中
    end
    Client->>Server: 查询任务状态
    Server-->>Client: 状态：完成
```

2. **批量处理**:
```mermaid
sequenceDiagram
    Service->>DB: 获取待处理列表
    DB-->>Service: 100条记录
    loop 处理每条记录
        Service->>Worker: 处理记录
        Worker-->>Service: 完成
    end
    Service-->>Admin: 批量处理完成
```

3. **重试机制**:
```mermaid
sequenceDiagram
    Client->>API: 请求
    loop 最多重试3次
        API->>Service: 调用服务
        Service-->>API: 超时
    end
    API-->>Client: 失败（超过重试次数）
```

**最佳实践**:
- ✅ 循环条件清晰（用"每X秒"、"最多X次"格式）
- ✅ 循环内容简洁（≤ 3 条消息）
- ✅ 避免嵌套循环（会导致图表难以理解）
- ⚠️ 注意：`loop` 在图表中显示为带标签的矩形框，不是真正的多次绘制

---

## 生成示例

### 示例 1: 基础用户登录时序（简单场景）
**用户需求**：绘制用户登录的时序图，包括前端、后端和数据库

**生成代码**：
```mermaid
sequenceDiagram
    actor User as 用户
    participant FE as 前端
    participant BE as 后端
    participant DB as 数据库

    User->>FE: 输入用户名密码
    FE->>BE: POST /login {username, password}
    activate BE
    BE->>DB: 查询用户
    activate DB
    DB-->>BE: 返回用户信息
    deactivate DB

    alt 验证成功
        BE-->>FE: 返回 Token
        FE-->>User: 登录成功
    else 验证失败
        BE-->>FE: 返回错误
        FE-->>User: 显示错误信息
    end
    deactivate BE
```

**关键点**：
- 使用 `actor` 声明真人用户
- 使用 `participant` 声明系统组件
- 使用 `activate/deactivate` 显示激活框
- 使用 `alt/else` 表示条件分支
- 使用 `--\>\>` 表示返回消息

### 示例 2: 支付流程时序图（中等复杂度）
**用户需求**：电商支付流程，包括订单服务、支付服务和第三方支付

**生成代码**：
```mermaid
sequenceDiagram
    participant Order as 订单服务
    participant Payment as 支付服务
    participant Gateway as 支付宝

    Order->>+Payment: 创建支付订单
    Payment->>Payment: 生成支付单号
    Payment-->>-Order: 返回支付单号

    Order->>+Gateway: 请求支付 (订单号, 金额)
    Gateway-->>-Order: 返回支付页面 URL

    Note over Order,Gateway: 用户在支付宝页面完成支付

    Gateway->>+Payment: 支付回调 (支付结果)
    Payment->>Payment: 验证签名

    alt 支付成功
        Payment->>Order: 通知支付成功
        Payment-->>Gateway: 返回 success
    else 支付失败
        Payment->>Order: 通知支付失败
        Payment-->>Gateway: 返回 fail
    end
    deactivate Payment
```

**关键点**：
- 使用 `Note over` 标注重要说明
- 自激活消息（`Payment->>Payment:`）表示内部处理
- 多层嵌套的激活框
- 清晰的返回消息流向

### 示例 3: 微服务调用链（高级场景）
**用户需求**：展示微服务之间的调用链，包含重试和熔断机制

**生成代码**：
```mermaid
sequenceDiagram
    participant API as API Gateway
    participant UserSvc as 用户服务
    participant OrderSvc as 订单服务
    participant PaySvc as 支付服务
    participant Cache as Redis

    API->>+UserSvc: 获取用户信息
    UserSvc->>Cache: 查询缓存

    alt 缓存命中
        Cache-->>UserSvc: 返回用户信息
    else 缓存未命中
        UserSvc->>UserSvc: 查询数据库
        UserSvc->>Cache: 更新缓存
    end
    UserSvc-->>-API: 返回用户信息

    API->>+OrderSvc: 查询用户订单

    loop 重试 3 次
        OrderSvc->>PaySvc: 查询支付状态

        opt 服务超时
            Note over OrderSvc,PaySvc: 熔断器开启
            OrderSvc-->>OrderSvc: 使用降级数据
        end
    end

    OrderSvc-->>-API: 返回订单列表
```

**关键点**：
- 使用 `loop` 表示重试逻辑
- 使用 `opt` 表示可选的降级流程
- 组合使用缓存查询的条件分支
- 复杂的激活框嵌套

## 常见错误

### 错误 1: 使用保留关键字作为参与者名称

**Mermaid 全局保留关键字**（不能用作参与者名称）:
```
participant, actor, loop, alt, opt, par, and,
Note, activate, deactivate, title, end
```

**Sequence Diagram 特有保留关键字**:
```
participant, actor, loop, alt, opt, par, and,
Note, activate, deactivate
```

---

**❌ 错误示例**:
```mermaid
sequenceDiagram
    participant as 用户  %% ❌ 'participant' 是保留关键字
    actor->>participant: 消息  %% ❌ 'actor' 也是
    Note over participant: 说明  %% ❌ 'Note' 也是
```

**✅ 正确写法**:
```mermaid
sequenceDiagram
    participant User as 用户
    participant Actor as 角色
    User->>Actor: 消息
    Note over User: 说明
```

**🔍 检测方法**:
```javascript
const reservedKeywords = [
  'participant', 'actor', 'loop', 'alt', 'opt',
  'par', 'and', 'Note', 'activate', 'deactivate',
  'title', 'end'
];

function检测参与者名称(name) {
  if (reservedKeywords.includes(name)) {
    throw new Error(`参与者名称 "${name}" 是保留关键字`);
  }
}
```

**💡 最佳实践**:
- 参与者名称使用英文（如 `User`, `System`, `Service`）
- 使用 `as` 关键字定义中文别名（如 `User as 用户`）
- 避免使用常见动词（如 `activate`, `loop`）

### 错误 2: 参与者名称不一致
**❌ 错误写法**：
```mermaid
sequenceDiagram
    Alice->>Bob: Hello
    bob->>Alice: Hi    %% 注意 B 的大小写
```

**✅ 正确写法**：
```mermaid
sequenceDiagram
    Alice->>Bob: Hello
    Bob->>Alice: Hi    %% 保持大小写一致
```

**原因**：参与者名称大小写敏感，`Bob` 和 `bob` 是两个不同的参与者。

### 错误 2: 箭头语法错误
**❌ 错误写法**：
```mermaid
sequenceDiagram
    A->B: Message    %% 单箭头错误
```

**✅ 正确写法**：
```mermaid
sequenceDiagram
    A->>B: Message   %% 使用双箭头
```

**原因**：Mermaid 时序图使用 `->>` 而不是 `->`。

**Sequence Diagram 箭头语法完整列表**:

| 箭头 | 类型 | 说明 | 使用场景 |
|------|------|------|----------|
| `->>` | 实线箭头 | 同步调用 | 请求/响应 |
| `-->>` | 虚线箭头 | 异步消息/返回值 | 回调/异步响应 |
| `-x` | 实线 X | 丢失的消息 | 网络故障 |
| `--x` | 虚线 X | 丢失的异步消息 | 超时 |
| `-)` | 实线开放箭头 | 异步消息 | 发送后不等待 |
| `--)` | 虚线开放箭头 | 异步返回 | 异步回调 |

**最佳实践**:
- 请求使用 `->>` (实线)，返回使用 `-->>` (虚线)
- 异步场景使用 `-)` 或 `--)`
- 表示消息丢失使用 `-x` 或 `--x`

### 错误 3: 激活框未配对
**❌ 错误写法**：
```mermaid
sequenceDiagram
    A->>+B: 请求
    B->>C: 转发
    %% 缺少 deactivate 或 -
```

**✅ 正确写法**：
```mermaid
sequenceDiagram
    A->>+B: 请求
    B->>C: 转发
    B-->>-A: 返回    %% 使用 - 去激活
```

**原因**：每个 `+` 激活必须有对应的 `-` 去激活，否则激活框不会关闭。

### 错误 4: alt/else 语法错误
**❌ 错误写法**：
```mermaid
sequenceDiagram
    alt 成功
        A->>B: OK
    else if 失败    %% 不支持 else if
        A->>B: Error
    end
```

**✅ 正确写法**：
```mermaid
sequenceDiagram
    alt 成功
        A->>B: OK
    else 失败       %% 使用 else
        A->>B: Error
    end
```

**原因**：Mermaid 的 `alt/else` 不支持 `else if`，只能有一个 `else`。

### 错误 5: Note 位置错误
**❌ 错误写法**：
```mermaid
sequenceDiagram
    Note Alice: 注释    %% 缺少 left of/right of/over
```

**✅ 正确写法**：
```mermaid
sequenceDiagram
    Note left of Alice: 注释
    Note over Alice,Bob: 跨越注释
```

**原因**：`Note` 必须指定位置：`left of`、`right of` 或 `over`。

### 错误 6: 消息文本包含特殊字符未转义
**❌ 错误写法**：
```mermaid
sequenceDiagram
    A->>B: 返回数据 {id: 1}    %% {} 会导致解析错误
```

**✅ 正确写法**：
```mermaid
sequenceDiagram
    A->>B: 返回数据 (id: 1)    %% 使用 () 或其他符号
```

**原因**：消息标签中的特殊字符（如 `{}`）可能导致解析错误，建议使用其他符号。

### 错误 7: loop 语法缺少 end
**❌ 错误写法**：
```mermaid
sequenceDiagram
    loop 每天
        A->>B: 问候
    %% 缺少 end
    A->>C: 其他操作
```

**✅ 正确写法**：
```mermaid
sequenceDiagram
    loop 每天
        A->>B: 问候
    end
    A->>C: 其他操作
```

**原因**：所有块级语句（`loop`、`alt`、`opt`）必须有对应的 `end` 关闭。

## 生成检查清单

生成代码后，逐项检查：

- [ ] **🚨 空消息检查**：最后一行不能是空消息（Kroki 致命错误）
- [ ] **图表声明正确**：使用 `sequenceDiagram`
- [ ] **参与者名称一致**：所有参与者名称大小写一致
- [ ] **箭头语法正确**：使用 `->>`、`--\>\>` 等正确语法
- [ ] **激活框配对**：每个 `+` 都有对应的 `-`
- [ ] **消息流向清晰**：调用和返回的方向正确
- [ ] **条件分支正确**：`alt/else/opt/loop` 语法正确且有 `end`
- [ ] **注释位置正确**：`Note` 使用正确的位置语法
- [ ] **代码可渲染**：语法正确，可以直接通过 Kroki 渲染

**任何检查项不通过，立即修正后重新生成**
