# ============================================
# L3 类型层 - UMLet UML Diagram (UML 图表)
# ============================================

[meta]
level = "L3"
language = "umlet"
diagram_type = "uml"
version = "1.0.0"
description = "L3: UMLet UML 图表生成规范（类图、用例图、组件图）"
author = "DiagramAI Team"
created_at = "2025-10-19"
updated_at = "2025-10-19"

# 类型相关元数据
complexity = "medium"
target_length = 2800
use_cases = ["类图设计", "用例图建模", "组件图设计", "面向对象设计", "系统架构设计"]

# ============================================
# Section 1: D 角色定义
# ============================================

[D_role]
additional_roles = [
  "UMLet 类图设计专家",
  "UML 建模师",
  "面向对象设计师",
  "系统架构师"
]

# ============================================
# Section 2: E 约束条件
# ============================================

[E_constraints]
items = [
  """
  **类图 - 分隔符强制规则**: 类定义必须使用 `--` 分隔符分隔类名、属性和方法三部分。这是 UMLet 最常见的致命错误。
  - 标准结构: `类名\\n--\\n属性列表\\n--\\n方法列表`
  - 只有属性: `类名\\n--\\n属性列表\\n--\\n`（第二个 `--` 后留空）
  - 只有方法: `类名\\n--\\n--\\n方法列表`（第一个 `--` 后留空）
  - 错误: 使用 `-` 或 `---` → Kroki 渲染为纯文本或格式错误
  """,

  """
  **类图 - 可见性修饰符强制标注**: 所有属性和方法必须标注可见性，不能省略。
  - `+` - public（公有）: 所有地方可访问
  - `-` - private（私有）: 仅类内部可访问
  - `#` - protected（受保护）: 类及子类可访问
  - `~` - package（包级）: 同包内可访问
  - 示例: `- userId: int`（私有属性），`+ login(): boolean`（公有方法）
  - 错误: `userId: int` → 缺少可见性修饰符
  """,

  """
  **类图 - 继承关系符号规则**: 继承/泛化必须使用 `--|>` 符号，不能使用简化符号。
  - 继承/泛化: `子类 --|>` (实线三角箭头)
  - 实现接口: `实现类 ..|> 接口` (虚线三角箭头)
  - 错误: 使用 `->`, `-->`, `=>`, `<-` 等非标准符号
  - 正确: `狗 --|> 动物`（狗继承动物）
  """,

  """
  **类图 - 属性和方法类型标注**: 属性和方法必须明确标注类型。
  - 属性格式: `可见性 属性名: 类型`（如 `- userId: int`）
  - 方法格式: `可见性 方法名(参数列表): 返回类型`（如 `+ login(): boolean`）
  - 参数格式: `参数名: 类型`，多个参数用逗号分隔（如 `findById(id: int, includeDeleted: boolean): User`）
  - 常见类型: `int`, `string`, `boolean`, `decimal`, `DateTime`, 自定义类型
  """,

  """
  **类图 - 关联关系多重性标记**: 关联关系必须使用双引号标记多重性（基数）。
  - 格式: `类A "基数1" --- "基数2" 类B`
  - 常见基数: `1` (恰好一个), `*` (零个或多个), `0..1` (零个或一个), `1..*` (一个或多个)
  - 示例: `用户 "1" --- "*" 订单` (一对多: 一个用户有多个订单)
  - 示例: `订单 "*" --- "*" 商品` (多对多: 订单和商品多对多关系)
  """,

  """
  **类图 - 组合和聚合关系**: 组合和聚合必须使用正确的符号表达生命周期依赖。
  - 组合（强拥有）: `类A "1" --* "*" 类B`（黑色菱形，生命周期绑定）
  - 聚合（弱拥有）: `类A "1" --o "*" 类B`（白色菱形，生命周期独立）
  - 组合示例: `订单 "1" --* "*" 订单项`（订单删除，订单项也删除）
  - 聚合示例: `部门 "1" --o "*" 员工`（部门删除，员工仍存在）
  """,

  """
  **类图 - 抽象类和接口定义**: 抽象类和接口必须使用构造型标注。
  - 接口: `<<interface>>\\nI接口名\\n--\\n方法列表`
  - 抽象类: `<<abstract>>\\n抽象类名\\n--\\n属性\\n--\\n方法（含抽象方法）`
  - 抽象方法: `+ {abstract} 方法名(): 返回类型`
  - 接口只有方法，没有属性（接口定义行为契约）
  """,

  """
  **用例图 - 用例和参与者定义**: 用例使用圆括号，参与者直接写名称。
  - 用例定义: `(用例名称)`（如 `(登录)`, `(下单)`, `(支付)`）
  - 参与者定义: 直接写名称（如 `用户`, `管理员`, `系统`）
  - 关联: `参与者 --- (用例)`（如 `用户 --- (登录)`）
  - 依赖: `(用例1) ..> (用例2)`（如 `(下单) ..> (支付)`）
  """,

  """
  **用例图 - 包含和扩展关系**: 包含和扩展关系必须使用正确的符号和标签。
  - 包含（include）: `(用例1) <.. (用例2)` + `<<include>>` 标签（用例1 包含用例2，必须执行）
  - 扩展（extend）: `(用例1) <.. (用例2)` + `<<extend>>` 标签（用例1 扩展用例2，可选执行）
  - 示例: `(下单) <.. (验证库存) <<include>>`（下单必须验证库存）
  - 示例: `(支付) <.. (使用优惠券) <<extend>>`（支付可选使用优惠券）
  """,

  """
  **组件图 - 组件定义和关系**: 组件使用方括号，关系使用箭头。
  - 组件定义: `[组件名称]`（如 `[用户服务]`, `[订单服务]`, `[数据库]`）
  - 依赖（强）: `[组件A] --> [组件B]`（如 `[前端应用] --> [用户服务]`）
  - 依赖（弱）: `[组件A] ..> [组件B]`（如 `[用户服务] ..> [数据库]`）
  - 组件名称应清晰表达职责和边界
  """
]

# ============================================
# Section 3: P 流程规范
# ============================================

[P_process]
items = [
  """
  **1. 图表类型选择**:
  - 类图（Class Diagram）: 面向对象设计，表达类的结构和关系
  - 用例图（Use Case Diagram）: 需求分析，表达系统功能和参与者
  - 组件图（Component Diagram）: 架构设计，表达系统组件和依赖
  - 根据用户需求选择合适的图表类型
  """,

  """
  **2. 类图设计流程**:
  - 识别核心类（如 用户、订单、商品、分类）
  - 定义类的属性（如 userId, username, email）
  - 定义类的方法（如 login(), logout(), getProfile()）
  - 确定可见性（公有、私有、受保护）
  - 识别类之间的关系（继承、实现、关联、组合、聚合、依赖）
  - 标注多重性（一对一、一对多、多对多）
  """,

  """
  **3. 用例图设计流程**:
  - 识别系统边界（系统提供哪些功能）
  - 识别参与者（用户、管理员、外部系统）
  - 识别用例（登录、注册、下单、支付、管理商品）
  - 建立参与者与用例的关联
  - 识别用例之间的依赖（包含、扩展）
  """,

  """
  **4. 组件图设计流程**:
  - 识别系统组件（前端应用、用户服务、订单服务、数据库）
  - 识别组件职责和边界
  - 识别组件之间的依赖关系（强依赖、弱依赖）
  - 标注依赖方向（调用方 → 被调用方）
  """,

  """
  **5. UMLet 代码生成**:
  - 类图:
    - 定义类（使用 `--` 分隔符，标注可见性）
    - 定义关系（使用正确的符号: `--|>`, `..|>`, `---`, `--*`, `--o`, `..>`）
    - 标注多重性（使用双引号: `"1"`, `"*"`, `"0..1"`）
  - 用例图:
    - 定义参与者和用例（参与者直接写名称，用例用圆括号）
    - 定义关联和依赖（使用 `---` 和 `..>`）
    - 标注包含和扩展（使用 `<<include>>` 和 `<<extend>>`）
  - 组件图:
    - 定义组件（使用方括号: `[组件名]`）
    - 定义依赖（使用 `-->` 和 `..>`）
  """
]

# ============================================
# Section 4: H 质量标准
# ============================================

[H_quality]
items = [
  """
  **UMLet 语法正确性**:
  - 类定义使用 `--` 分隔符（不是 `-` 或 `---`）
  - 所有属性和方法都有可见性修饰符（`+`, `-`, `#`, `~`）
  - 关系符号使用正确（`--|>`, `..|>`, `---`, `--*`, `--o`, `..>`）
  - 多重性标记使用双引号（如 `"1"`, `"*"`, `"0..1"`）
  - 构造型正确使用（`<<interface>>`, `<<abstract>>`, `<<enumeration>>`）
  - 用例使用圆括号，组件使用方括号
  """,

  """
  **UML 规范符合性**:
  - 类结构完整（类名、属性、方法三部分）
  - 继承关系正确（子类 → 父类，使用 `--|>`）
  - 接口实现正确（实现类 → 接口，使用 `..|>`）
  - 关联、组合、聚合、依赖关系使用正确
  - 多重性标注准确（一对一、一对多、多对多）
  - 抽象方法标注 `{abstract}`
  """,

  """
  **业务建模准确性**:
  - 类名清晰表达职责（如 `用户管理器`, `订单服务`）
  - 属性名清晰表达含义（如 `userId` 而非 `id`）
  - 方法名清晰表达操作（如 `login()`, `getProfile()`）
  - 关系类型准确（继承、实现、关联、组合、聚合、依赖）
  - 用例名称清晰表达功能（如 `登录`, `下单`, `支付`）
  - 组件名称清晰表达职责和边界
  """,

  """
  **设计质量**:
  - 类的职责单一，符合单一职责原则
  - 继承层次合理，避免过深继承（不超过 3 层）
  - 关联关系合理，避免循环依赖
  - 组合和聚合使用恰当，表达生命周期依赖
  - 接口设计合理，体现行为契约
  - 用例划分合理，粒度适中
  - 组件划分合理，边界清晰
  """,

  """
  **Kroki 渲染质量**:
  - 生成的 UMLet 代码能被 Kroki 成功渲染为 SVG 图像
  - 无渲染错误或警告
  - 图形布局清晰，类框/用例/组件大小适中
  - 关系线不交叉或交叉最少
  - 文本标签清晰易读
  - 可见性修饰符图标正确显示
  - 关系箭头方向正确
  """
]

# ============================================
# Section 5: 使用场景
# ============================================

[[use_cases]]
title = "电商系统类图"
scenario = "设计电商系统的核心类，包括用户、订单、商品、购物车"
key_points = [
  "继承关系: 管理员继承用户（`管理员 --|> 用户`）",
  "关联关系: 用户与订单一对多（`用户 \"1\" --- \"*\" 订单`）",
  "组合关系: 订单与订单项（`订单 \"1\" --* \"*\" 订单项`）",
  "聚合关系: 购物车与商品（`购物车 \"1\" --o \"*\" 商品`）"
]

[[use_cases]]
title = "在线教育平台用例图"
scenario = "在线教育平台的用例图，包括学生、教师、管理员三类参与者"
key_points = [
  "参与者: 学生、教师、管理员",
  "核心用例: 登录、浏览课程、选课、上课、考试、评分",
  "包含关系: (选课) <.. (验证前置课程) <<include>>",
  "扩展关系: (上课) <.. (互动答疑) <<extend>>"
]

[[use_cases]]
title = "微服务架构组件图"
scenario = "微服务架构的组件图，展示前端、后端服务、数据库的依赖关系"
key_points = [
  "组件: [前端应用], [用户服务], [订单服务], [支付服务], [数据库]",
  "依赖关系: [前端应用] --> [用户服务], [订单服务] --> [支付服务]",
  "弱依赖: [用户服务] ..> [数据库], [订单服务] ..> [数据库]",
  "清晰表达服务边界和调用关系"
]
