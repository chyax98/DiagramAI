# UMLet 语言通用规范

## 强制规则（Mandatory Rules）

### ⚠️ 规则 1: 类定义必须使用 `--` 分隔符
这是 UMLet 最常见的致命错误！类的属性和方法部分必须使用 `--` 分隔，不能使用单个 `-` 或其他符号。

**错误示例**：
```
用户
-
userId: int
-
login(): boolean
```

```
用户
---
userId: int
---
login(): boolean
```

**正确写法**：
```
用户
--
- userId: int
--
+ login(): boolean
```

**违反后果**: UMLet 无法识别类结构，渲染为纯文本或格式错误的类图。
**Kroki 错误**: `Invalid class separator: expected '--' at line X`

**分隔规则**:
- 类名和属性之间: `--`
- 属性和方法之间: `--`
- 如果只有属性没有方法，仍需要第二个 `--` 后留空
- 如果只有方法没有属性，第一个 `--` 后可留空

**示例**:
```
# 标准类定义
用户
--
- userId: int
- username: string
--
+ login(): boolean
+ logout(): void

# 只有属性
配置
--
- host: string
- port: int
--

# 只有方法
工具类
--
--
+ formatDate(): string
+ parseJson(): object
```

---

### ⚠️ 规则 2: 继承关系必须使用 `--|>` 符号
继承关系使用特定的符号 `--|>`，不能使用简单的箭头或其他符号。

**错误示例**：
```
子类 -> 父类
子类 --> 父类
子类 => 父类
子类 <- 父类
```

**正确写法**：
```
子类 --|> 父类
```

**违反后果**: 关系类型错误，渲染为普通箭头或关联关系，不符合 UML 规范。
**Kroki 错误**: `Invalid inheritance syntax: use '--|>' for inheritance`

**关系符号完整列表**:
- `--|>` - 继承/泛化（实线三角箭头）
- `..|>` - 实现接口（虚线三角箭头）
- `---` - 单向关联（实线箭头）
- `<-->` - 双向关联（双向实线箭头）
- `--*` - 组合（强拥有，黑色菱形）
- `--o` - 聚合（弱拥有，白色菱形）
- `..>` - 依赖（虚线箭头）

**示例**:
```
# 继承
狗 --|> 动物
猫 --|> 动物

# 实现接口
UserServiceImpl ..|> IUserService

# 关联
用户 "1" --- "*" 订单

# 组合
订单 "1" --* "*" 订单项

# 聚合
部门 "1" --o "*" 员工

# 依赖
Controller ..> Service
```

---

### ⚠️ 规则 3: 属性和方法必须标注可见性
所有类的属性和方法必须使用可见性修饰符（`+`, `-`, `#`, `~`），不能省略。

**错误示例**：
```
用户
--
userId: int
username: string
--
login(): boolean
logout(): void
```

**正确写法**：
```
用户
--
- userId: int
- username: string
--
+ login(): boolean
+ logout(): void
```

**违反后果**: 可见性不明确，不符合 UML 规范，渲染结果可能缺少修饰符图标。
**Kroki 错误**: `Missing visibility modifier at line X: expected '+', '-', '#', or '~'`

**可见性修饰符**:
- `+` - public（公有）- 所有地方可访问
- `-` - private（私有）- 仅类内部可访问
- `#` - protected（受保护）- 类及子类可访问
- `~` - package（包级）- 同包内可访问

**最佳实践**:
- 属性通常使用 `-`（私有）
- 方法通常使用 `+`（公有）
- 受保护的属性/方法使用 `#`
- 包级访问使用 `~`

**示例**:
```
用户
--
- userId: int          # 私有属性
# username: string     # 受保护属性
~ email: string        # 包级属性
--
+ login(): boolean     # 公有方法
- hashPassword(): string   # 私有方法
# validate(): boolean       # 受保护方法
```

---

## 基础元素

### 类定义

**标准类**:
```
用户
--
- userId: int
- username: string
- email: string
--
+ login(): boolean
+ logout(): void
+ getProfile(): UserProfile
```

**接口定义**:
```
<<interface>>
IUserService
--
+ findById(id: int): User
+ save(user: User): void
+ delete(id: int): void
```

**抽象类**:
```
<<abstract>>
BaseEntity
--
# id: int
# createdAt: DateTime
--
+ save(): void
+ delete(): void
+ {abstract} validate(): boolean
```

**枚举类型**:
```
<<enumeration>>
OrderStatus
--
PENDING
PAID
SHIPPED
COMPLETED
CANCELLED
```

---

## 关系类型

### 继承/泛化
实线三角箭头，表示"is-a"关系：
```
子类 --|> 父类
```

### 实现接口
虚线三角箭头：
```
实现类 ..|> 接口
```

### 关联
实线箭头，表示"has-a"关系：
```
类A --- 类B          # 单向关联
类A <--> 类B         # 双向关联
```

### 组合（强拥有）
黑色菱形，生命周期绑定：
```
类A --* 类B
```

示例：订单和订单项（订单删除，订单项也删除）

### 聚合（弱拥有）
白色菱形，生命周期独立：
```
类A --o 类B
```

示例：部门和员工（部门删除，员工仍存在）

### 依赖
虚线箭头，表示临时使用关系：
```
类A ..> 类B
```

### 多重性标记
在关系两端标注基数：
```
用户 "1" --- "*" 订单      # 一对多
订单 "*" --- "*" 商品      # 多对多
学生 "1" --- "1" 学号      # 一对一
```

**基数符号**:
- `1` - 恰好一个
- `*` - 零个或多个
- `0..1` - 零个或一个
- `1..*` - 一个或多个
- `m..n` - m 到 n 个

---

## 用例图元素

### 用例定义
使用圆括号包裹：
```
(用例名称)
```

### 参与者
直接写名称：
```
参与者名称
用户
管理员
```

### 用例关系
```
参与者 --- (用例)        # 关联
(用例1) ..> (用例2)      # 依赖
(用例1) <.. (用例2)      # 包含 <<include>>
(用例1) <.. (用例2)      # 扩展 <<extend>>
```

**示例**:
```
用户 --- (浏览商品)
用户 --- (加入购物车)
用户 --- (下单)
用户 --- (支付)

管理员 --- (管理商品)
管理员 --- (查看订单)

(下单) ..> (支付) <<include>>
(支付) <.. (退款) <<extend>>
```

---

## 组件图元素

### 组件定义
使用方括号包裹：
```
[组件名称]
```

### 组件关系
```
[组件A] --> [组件B]      # 依赖
[组件A] ..> [组件B]      # 弱依赖
```

**示例**:
```
[前端应用]
[用户服务]
[订单服务]
[支付服务]
[数据库]

[前端应用] --> [用户服务]
[前端应用] --> [订单服务]
[订单服务] --> [支付服务]
[用户服务] ..> [数据库]
[订单服务] ..> [数据库]
```

---

## 命名规范

**类命名**:
- ✅ 使用帕斯卡命名法：用户、订单服务、产品管理器
- ✅ 使用业务术语，清晰表达类的职责
- ❌ 避免技术术语：Controller、Manager（除非必要）

**属性命名**:
- ✅ 使用驼峰命名法：userId, userName, createdAt
- ✅ 类型标注清晰：属性名: 类型
- ❌ 避免无意义的缩写

**方法命名**:
- ✅ 使用动词开头：get, set, find, save, delete
- ✅ 参数和返回值类型明确
- ❌ 避免过长的方法名

---

## 常见错误

### 错误 1: 分隔符不正确
**❌ 错误**:
```
用户
-
属性列表
-
方法列表
```

**✅ 正确**:
```
用户
--
属性列表
--
方法列表
```

**原因**: UMLet 使用 `--` 作为分隔符
**Kroki 错误**: `Invalid class separator: expected '--'`

---

### 错误 2: 关系符号错误
**❌ 错误**:
```
子类 -> 父类
```

**✅ 正确**:
```
子类 --|> 父类
```

**原因**: 继承使用 `--|>` 符号，不是简单的箭头
**Kroki 错误**: `Invalid inheritance syntax: use '--|>'`

---

### 错误 3: 可见性符号缺失
**❌ 错误**:
```
用户
--
userId: int
--
login(): boolean
```

**✅ 正确**:
```
用户
--
- userId: int
--
+ login(): boolean
```

**原因**: 属性和方法必须标注可见性
**Kroki 错误**: `Missing visibility modifier: expected '+', '-', '#', or '~'`

---

## 最佳实践

1. **类设计**
   - 每个类职责单一，符合单一职责原则
   - 属性使用私有（`-`），方法使用公有（`+`）
   - 合理使用抽象类和接口
   - 使用 `<<stereotype>>` 标注特殊类型

2. **关系设计**
   - 明确标注所有关系类型
   - 使用多重性标记表达基数
   - 避免循环依赖
   - 优先使用组合而非继承

3. **命名规范**
   - 使用业务领域术语
   - 保持命名一致性
   - 避免技术术语泄露
   - 类名使用名词，方法名使用动词

4. **简洁优先**
   - 只展示关键属性和方法（必须完整，不允许占位符）
   - 避免过度细节
   - 合理分层（接口-抽象类-实现类）

5. **分隔符规范**
   - 始终使用 `--` 分隔类的各部分
   - 即使某部分为空，仍需保留分隔符
   - 不要使用 `-` 或 `---`

6. **可见性规范**
   - 所有属性和方法必须标注可见性
   - 使用标准符号（`+`, `-`, `#`, `~`）
   - 不要省略修饰符

---

## Kroki 兼容性

- **Kroki 版本**: 支持 UMLet 14.3+
- **特殊限制**:
  - 不支持颜色自定义（UMLet 使用默认配色）
  - 不支持字体样式自定义
  - 建议使用标准 UML 符号
  - 复杂的构造型（stereotype）可能不被完全支持
- **已知问题**:
  - 中文字符在某些字体下可能显示不全，建议使用简洁文本
  - 过大的类图（超过 20 个类）可能渲染缓慢
  - 多重继承可能导致布局混乱

---

## 高级特性

### 抽象方法
使用 `{abstract}` 标注：
```
<<abstract>>
动物
--
# name: string
--
+ {abstract} makeSound(): void
+ eat(): void
```

### 静态成员
使用下划线标注：
```
工具类
--
_MAX_SIZE: int
--
_formatDate(): string
```

### 常量
使用全大写：
```
配置
--
- HOST: string
- PORT: int
--
```

### 泛型
使用尖括号：
```
List<T>
--
- items: T[]
--
+ add(item: T): void
+ get(index: int): T
```

### 注释
使用 `//` 或文本框：
```
// 这是注释
用户
--
- userId: int
--
```
