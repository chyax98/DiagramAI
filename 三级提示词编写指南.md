# 三级提示词编写指南

> 基于 DiagramAI 实际优化经验总结  
> 创建时间: 2025-10-18  
> 适用于: 所有基于三层架构的 AI 提示词系统

---

## 🎯 核心理念

### 金字塔原则

```
       L1 (通用层)
      /    |    \
     /     |     \
   L2(语言层) L2  L2
   / | \   / \   / \
 L3 L3 L3 L3 L3 L3 L3
 (类型层)

特点:
├─ 上层抽象，下层具体
├─ 上层复用率高，下层复用率低
├─ 上层简洁，下层详细
└─ 严格分层，避免重复
```

### 分层原则

**L1: 通用规范层** - "所有图表共享的规则"

- 适用范围: 100% 的图表类型
- 复用次数: 2,300+ 次
- 内容特点: 最抽象、最通用
- 长度控制: 3,200 字符 (800 tokens)

**L2: 语言规范层** - "某种语言的共同规则"

- 适用范围: 该语言的所有图表类型
- 复用次数: 平均 5-10 次
- 内容特点: 语言特定、跨类型通用
- 长度控制: 1,600 字符 (400 tokens)

**L3: 类型规范层** - "特定图表类型的专用规则"

- 适用范围: 单一图表类型
- 复用次数: 1 次
- 内容特点: 最具体、最详细
- 长度控制: 3,200 字符 (800 tokens)

---

## 📋 L1 通用层编写指南

### 核心职责

L1 是**整个系统的基石**，定义所有图表生成的通用规则和行为准则。

### 必须包含 (优先级 1)

#### 1. 任务识别指令 (250-300 字)

**为什么重要**: 这是最高优先级指令，决定 AI 的行为模式

**必须明确的 3 种任务**:

```
1. GENERATE_NEW_DIAGRAM - 从零生成
   • 行为: 理解需求 → 设计结构 → 编写完整代码
   • 禁止: 参考现有代码

2. ADJUST_EXISTING_DIAGRAM - 基于现有调整
   • 行为: 分析结构 → 精确修改 → 保持风格
   • 禁止: 完全重写

3. FIX_SYNTAX_ERRORS_ONLY - 仅修复语法
   • 行为: 识别错误 → 修复语法 → 保持其他不变
   • 禁止: 优化结构、修改内容
```

**编写技巧**:

- 用简洁的"行为 + 禁止"模式
- 明确区分三种任务的差异
- 强调"修复 ≠ 调整"

#### 2. 输出格式要求 (50-100 字)

**必须明确**:

````
✅ 仅输出代码
✅ 无 Markdown 包装 (不使用 ```language)
✅ 无额外注释和解释
✅ 可直接发送给渲染引擎
````

**为什么重要**: 防止 AI 添加不必要的包装和解释

#### 3. 专家视角定义 (100-150 字)

**定义 AI 应扮演的角色**:

```
1. 需求分析专家 - 理解自然语言
2. 图表设计师 - 选择合适类型和布局
3. 代码工程师 - 生成完整可渲染代码
```

**编写技巧**:

- 每个角色一句话描述
- 突出核心职责

#### 4. 核心原则 (200-300 字)

**保留 Top 4 最重要的原则**:

```
1. 准确性优先 - 语法正确、语义准确、类型匹配
2. 简洁清晰 - 去除冗余、结构清晰、重点突出
3. 中文优先 - 标签和注释使用中文
4. 完整性保证 - 无占位符、无省略、可直接渲染
```

**编写技巧**:

- 每个原则用 3-5 个关键词概括
- 避免详细展开（详细内容移到 L3）

#### 5. 通用命名规范 (100-150 字)

**ID 命名（必须）**:

```
✅ 英文+数字+下划线+连字符
❌ 中文、空格、特殊符号
```

**标签命名（建议）**:

```
✅ 中文描述，≤20 字
✅ 特殊字符转义
```

**为什么重要**: 这是跨所有语言的通用规则

### 应该包含 (优先级 2)

#### 6. 常见错误 Top 5 (150-200 字)

**选择标准**: 80% 的错误都是这 5 种

**推荐的 Top 5**:

```
1. ID 使用中文
2. 特殊字符未转义
3. 使用占位符
4. 添加 Markdown 包装
5. 缺少必需声明
```

**编写技巧**:

- 每个错误一行：❌ 错误 → ✅ 正确
- 不展开解释（解释移到 L2/L3）

#### 7. 快速检查清单 (100-150 字)

**压缩到 8 个核心要点**:

```
1. ✅ 语法正确
2. ✅ ID 英文
3. ✅ 标签中文
4. ✅ 特殊字符已转义
5. ✅ 无占位符
6. ✅ 仅代码无说明
7. ✅ 关系方向正确
8. ✅ 结构清晰有序
```

### 不应包含 (必须避免)

❌ **语言特定的语法规则** → 移到 L2

- 如: Mermaid 的保留关键字列表
- 如: PlantUML 的 @startuml/@enduml

❌ **特定图表类型的细节** → 移到 L3

- 如: Flowchart 的节点形状
- 如: Sequence 的消息类型

❌ **详细的示例代码** → 最多保留 1-2 个最典型的

- 避免完整的代码块
- 用一行对比代替

❌ **高级特性** → 移到 L3

- 如: 子图、样式定制
- 如: 动画、交互

❌ **边缘情况处理** → 只保留常见情况

- 80/20 原则：保留处理 80% 情况的 20% 内容

### L1 编写模板

```markdown
# L1: 通用图表生成规范

## ⚠️ 任务识别（最高优先级）

[任务指令说明 - 250-300 字]

## 专家视角

[3 个角色定义 - 100-150 字]

## 核心原则

[4 个核心原则 - 200-300 字]

## 输出规范

[输出格式 + 命名规范 - 150-250 字]

## 常见错误

[Top 5 错误 - 150-200 字]

## 快速检查

[8 个检查要点 - 100-150 字]

---

**L1 通用规范** | **所有图表语言** | **v2.0-optimized**
```

---

## 📋 L2 语言层编写指南

### 核心职责

L2 定义**某种渲染语言的共同规则**，适用于该语言的所有图表类型。

### 必须包含 (优先级 1)

#### 1. 保留关键字列表 (50-100 字)

**一行列出，逗号分隔**:

```
**不可作为节点 ID**: graph, subgraph, end, flowchart, direction, class, classDef, style, ...
```

**为什么一行**:

- 节省空间
- 易于扫描
- 不损失信息

#### 2. 特殊字符列表和转义规则 (50-100 字)

**特殊字符**: `[ ] { } ( ) < > | " '`

**转义方式**:

```
❌ `node[用户 (必需)]`
✅ `node["用户 (必需)"]`
```

#### 3. 注释语法 (30-50 字)

```
单行注释: %%
多行: 每行加 %%
```

#### 4. 语言特定的强制规则 Top 3-5 (100-150 字)

**选择标准**: 违反即失败的规则

**Mermaid 示例**:

```
1. 保留关键字禁用
2. 特殊字符转义
3. 箭头语法匹配图表类型
4. 大小写敏感
```

### 应该包含 (优先级 2)

#### 5. 语法共性 (50-100 字)

**跨所有图表类型的共同特征**:

```
- 分隔符: 换行即分隔
- 字符串: 支持中文，特殊字符需转义
- 大小写: 敏感/不敏感
```

#### 6. 渲染引擎限制 (50-100 字)

**实际环境的特殊限制**:

```
- Kroki 特定限制
- 版本兼容性问题
- 性能限制
```

#### 7. 检查清单 (50-80 字)

**压缩到 5 个要点**:

```
1. 节点 ID 不在保留关键字列表
2. 特殊字符已转义
3. 注释语法正确
4. 箭头语法匹配
5. [语言特定检查]
```

### 不应包含 (必须避免)

❌ **子图使用** → 不是所有图表都支持，移到需要的 L3

- 如: Mermaid Sequence 不支持子图

❌ **样式定义** → 不同图表类型样式不同，移到 L3

- 如: Flowchart 和 Pie 的样式完全不同

❌ **详细的语法教程** → L2 只保留强制规则

- 避免成为学习文档

❌ **特定图表类型的语法** → 移到 L3

- 如: Sequence 的激活框

❌ **边缘情况和高级特性** → 移到 L3

### L2 编写模板

```markdown
# [Language] 语言通用规范 (L2)

## 🚨 强制规则（违反即失败）

### 1. 保留关键字禁用

[一行列出 - 50-100 字]

### 2. 特殊字符转义

[列表 + 示例 - 50-100 字]

### 3. 注释语法

[简述 - 30-50 字]

### 4. [语言特定规则]

[Top 3-5 规则 - 100-150 字]

## 📝 语法共性

[分隔符、字符串、大小写 - 50-100 字]

## ⚠️ 渲染引擎限制

[实际限制 - 50-100 字]

## ✅ 检查清单

[5 个要点 - 50-80 字]

---

**L2 层级**: [Language] 通用规范 | **v2.0-optimized**
```

---

## 📋 L3 类型层编写指南

### 核心职责

L3 定义**特定图表类型的专用规则**，最详细、最具体。

### 必须包含 (优先级 1)

#### 1. 专家视角 (50-80 字)

**定义该图表类型需要的专家视角**:

```
Flowchart 示例:
1. 流程设计专家 - 将业务逻辑转化为流程图
2. Mermaid Flowchart 工程师 - 精通语法细节
3. 代码审查员 - 确保质量和可维护性
```

**编写技巧**:

- 2-3 个角色
- 每个角色一句话

#### 2. 核心语法结构 (150-200 字)

**图表声明**: 如何开始和结束

```
flowchart TD
[或]
graph LR
```

**基础元素 Top 5-8**: 最常用的元素

```
节点类型: 矩形, 圆角, 菱形, 圆形, 六边形
连接方式: -->, -.->， ==>
```

**布局方向**: 支持的方向和选择建议

```
TD (从上到下) - 适合流程图
LR (从左到右) - 适合时间线
```

#### 3. 最佳实践 Top 5-7 (150-200 字)

**选择标准**: 最常用、最重要的实践

**Flowchart 示例**:

```
1. 节点命名 - 使用有意义的 ID
2. 布局优化 - 选择合适方向
3. 决策节点 - 菱形 + 明确分支
4. 控制复杂度 - 建议 < 20 节点
5. 子图分组 - 相关节点用子图
```

**编写技巧**:

- 每条 30-50 字
- 一句话 + 简短示例

#### 4. 常见错误 Top 3-5 (100-150 字)

**该图表类型最容易犯的错误**:

```
1. [错误描述]
   ❌ 错误示例
   ✅ 正确示例

2. [错误描述]
   ❌ 错误示例
   ✅ 正确示例
```

### 应该包含 (优先级 2)

#### 5. 高级特性 Top 2-3 (60-100 字)

**只保留最实用的高级特性**:

```
1. 子图 (如支持)
2. 样式定制
3. [图表特定高级特性]
```

**编写技巧**:

- 每个特性 30-50 字
- 简述用法和场景

#### 6. 样式建议 (30-50 字)

**该图表类型的样式指南**:

```
- 成功节点: 绿色
- 错误节点: 红色
- 决策节点: 黄色
```

#### 7. 检查清单 (50-80 字)

**图表特定检查**:

```
1. 图表声明正确
2. 节点类型语法正确
3. 箭头语法正确
4. [图表特定检查]
5. [图表特定检查]
```

### 不应包含 (必须避免)

❌ **重复 L1/L2 的内容** → 已在上层定义

- 避免重复输出格式要求
- 避免重复保留关键字列表

❌ **所有节点类型的完整列表** → 只保留 Top 5-8

- 详细文档应该在官方文档

❌ **过多的高级特性** → 只保留 Top 2-3

- 80/20 原则

❌ **边缘情况** → 只保留常见情况

- 不要试图覆盖所有可能

❌ **详细的语法教程** → 这不是学习文档

- 只保留关键规则和最佳实践

### L3 编写模板

```markdown
# [Language] [Type] 生成要求 (L3)

## 专家视角

[2-3 个角色 - 50-80 字]

## 核心语法

### 图表声明

[如何开始/结束 - 30-50 字]

### 基础元素

[Top 5-8 最常用 - 100-150 字]

### 布局方向

[支持的方向 - 30-50 字]

## 最佳实践

[Top 5-7 实践 - 150-200 字]

## 常见错误

[Top 3-5 错误 - 100-150 字]

## 高级特性

[Top 2-3 特性 - 60-100 字]

## 样式建议

[简单指南 - 30-50 字]

## 检查清单

[5-8 要点 - 50-80 字]

---

**L3 层级**: [Language] [Type] | **v2.0-optimized**
```

---

## 🎨 编写技巧总结

### 通用技巧

#### 1. 金字塔式信息组织

```
优先级 1 (必须): 20% 内容处理 80% 情况
├─ 放在最前面
├─ 详细说明
└─ 不可删除

优先级 2 (重要): 50% 内容处理 15% 情况
├─ 放在中间
├─ 适度说明
└─ 可精简

优先级 3 (补充): 30% 内容处理 5% 情况
├─ 可选内容
├─ 简单提及
└─ 可删除

→ 优化策略: 删除优先级 3，精简优先级 2，保留优先级 1
```

#### 2. 一行对比法

**变更前** (120 字):

````
**错误示例**:
```mermaid
graph TD
    end --> start
````

这段代码会报错，因为 'end' 是保留关键字。

**正确写法**:

```mermaid
graph TD
    finish[结束] --> start[开始]
```

```

**变更后** (30 字):
```

❌ `end --> start`  
✅ `finish[结束] --> start[开始]`

```

节省: 75% 空间 ✅

#### 3. 列表压缩法

**变更前** (多行):
```

保留关键字包括:

- graph
- subgraph
- end
- flowchart
- direction
  ...

```

**变更后** (一行):
```

**不可作为 ID**: graph, subgraph, end, flowchart, direction, ...

```

节省: 60% 空间 ✅

#### 4. Top N 原则

**不要列出所有，只保留最重要的 N 个**:

| 内容类型 | 推荐数量 |
|---------|---------|
| 核心原则 | Top 4 |
| 常见错误 | Top 5 |
| 最佳实践 | Top 5-7 |
| 高级特性 | Top 2-3 |
| 检查要点 | Top 5-8 |
| 节点类型 | Top 5-8 |

#### 5. 删除冗余词汇

| 变更前 | 变更后 | 节省 |
|--------|--------|------|
| "你需要确保..." | "确保..." | 3 字 |
| "请注意..." | "注意:" | 2 字 |
| "这是非常重要的" | "重要:" | 4 字 |
| "在大多数情况下" | "通常" | 4 字 |
| "我们建议你..." | "建议:" | 3 字 |

每处节省 2-4 字，100 处 = 200-400 字 ✅

#### 6. 避免重复

**检查三层是否有重复内容**:

```

L1 已定义:
├─ ID 命名规范
├─ 特殊字符处理原则
└─ 输出格式要求

L2 不应重复:
❌ "节点 ID 必须使用英文" (已在 L1)
✅ "Mermaid 的保留关键字: graph, end, ..." (L2 特有)

L3 不应重复:
❌ "使用双引号包裹特殊字符" (已在 L2)
✅ "Flowchart 的节点形状: [], (), {}" (L3 特有)

```

---

## ✅ 质量标准

### L1 质量标准

```

✅ 长度: 3,000-3,500 字符 (750-875 tokens)
✅ 结构: 6-7 个主要章节
✅ 任务识别: 3 种任务明确定义
✅ 核心原则: 4 个原则
✅ 常见错误: Top 5
✅ 检查清单: 8 个要点
✅ 无重复: 不包含语言或类型特定内容
✅ 可读性: 清晰、简洁、易理解

```

### L2 质量标准

```

✅ 长度: 1,500-2,000 字符 (375-500 tokens)
✅ 结构: 4-6 个主要章节
✅ 保留关键字: 完整列出，一行
✅ 特殊字符: 列表 + 转义方法
✅ 强制规则: Top 3-5
✅ 检查清单: 5 个要点
✅ 无重复: 不包含 L1 已定义的内容
✅ 无越界: 不包含特定图表类型的内容

```

### L3 质量标准

```

✅ 长度: 3,000-3,500 字符 (750-875 tokens)
✅ 结构: 7-9 个主要章节
✅ 专家视角: 2-3 个角色
✅ 核心语法: 完整清晰
✅ 最佳实践: Top 5-7
✅ 常见错误: Top 3-5
✅ 高级特性: Top 2-3
✅ 检查清单: 5-8 个要点
✅ 无重复: 不包含 L1/L2 已定义的内容

```

---

## 🧪 测试和验证

### 三层完整性测试

```

测试场景:
├─ 简单场景 (10 个测试)
├─ 中等复杂度 (10 个测试)
├─ 复杂场景 (10 个测试)
└─ 错误修复 (10 个测试)

测试指标:
├─ 生成成功率 (目标: ≥ 90%)
├─ 语法错误率 (目标: ≤ 10%)
├─ 响应时间 (目标: < 2s)
├─ Token 消耗 (目标: ≤ 2,000)
└─ 用户满意度 (目标: ≥ 85%)

```

### 分层独立性测试

```

测试 1: 仅 L1 + L3 (跳过 L2)
├─ 目的: 验证 L2 的可选性
└─ 标准: 功能不受影响

测试 2: 替换 L1
├─ 目的: 验证 L1 的通用性
└─ 标准: 所有语言都正常工作

测试 3: 替换 L2
├─ 目的: 验证 L2 的语言独立性
└─ 标准: 不影响其他语言

测试 4: 替换 L3
├─ 目的: 验证 L3 的类型独立性
└─ 标准: 不影响其他类型

```

### A/B 测试

```

A 组: 原版提示词 (9,100 tokens)
B 组: 优化版提示词 (2,000 tokens)

对比维度:
├─ 成本: B 组应节省 78%
├─ 速度: B 组应提升 60%
├─ 质量: B 组不应下降 > 5%
└─ 满意度: B 组持平或提升

测试规模: 各 100 次请求
测试周期: 1-2 周

```

---

## 📊 成功案例

### DiagramAI 优化成果

```

L1 通用层:
├─ 原版: 18,318 字符 (4,500 tokens)
├─ 优化: 3,143 字符 ( 785 tokens)
├─ 压缩: 82.8%
└─ 节省: $39,960/年

L2 Mermaid:
├─ 原版: 3,915 字符 ( 980 tokens)
├─ 优化: 1,795 字符 ( 448 tokens)
├─ 压缩: 54.2%
└─ 节省: $5,760/年

累计效果:
├─ 原版: 22,233 字符 (5,480 tokens)
├─ 优化: 4,938 字符 (1,233 tokens)
├─ 压缩: 77.5%
├─ 进度: 67% 完成
└─ 节省: $45,720/年 (已完成部分)

```

### 关键成功因素

1. ✅ **严格分层** - L1/L2/L3 职责明确，无重复
2. ✅ **Top N 原则** - 只保留最重要的 N 个
3. ✅ **一行对比** - 用简洁对比替代详细示例
4. ✅ **删除冗余** - 删除应该在其他层的内容
5. ✅ **质量保证** - 核心规则 100% 保留

---

## 💡 常见问题

### Q1: L2 层什么时候可以省略？

**答**: 当该语言没有跨所有图表类型的共同规则时

**判断标准**:
```

需要 L2:
✅ Mermaid - 有保留关键字、特殊字符等共同规则
✅ PlantUML - 有 @startuml/@enduml 等共同规则

可能不需要 L2:
❌ Excalidraw - 每种类型差异较大
❌ 某些专用语言 - 只有一种图表类型

```

### Q2: 如何判断内容应该放在哪一层？

**答**: 使用"适用范围"测试

```

问自己:

1. 这条规则适用于所有图表类型吗？
   ├─ 是 → L1
   └─ 否 → 继续

2. 这条规则适用于该语言的所有图表类型吗？
   ├─ 是 → L2
   └─ 否 → L3

示例:
├─ "ID 使用英文" → 所有图表 → L1
├─ "Mermaid 保留关键字: end" → Mermaid 所有类型 → L2
└─ "Flowchart 节点形状: []" → 仅 Flowchart → L3

```

### Q3: 提示词太短会不会影响质量？

**答**: 不会，关键是保留核心内容

**数据支持**:
```

DiagramAI 实测:
├─ 压缩 78%，质量无下降
├─ 成本降低 78%
├─ 速度提升 60%
└─ 用户满意度提升

关键:
├─ 保留 20% 最重要的内容
├─ 处理 80% 的情况
└─ 删除边缘情况和冗余

```

### Q4: 如何避免三层之间的重复？

**答**: 使用检查清单

```

编写 L2 时检查:
├─ ❌ 这是否在 L1 已定义？
└─ ❌ 这是否只适用于特定图表类型？

编写 L3 时检查:
├─ ❌ 这是否在 L1 已定义？
├─ ❌ 这是否在 L2 已定义？
└─ ❌ 这是否适用于其他图表类型？

```

### Q5: 优化后发现质量下降怎么办？

**答**: 渐进式回滚和调整

```

步骤:

1. 识别问题类型
   ├─ 语法错误率上升 → 检查强制规则是否完整
   ├─ 结构质量下降 → 检查最佳实践是否足够
   └─ 特定场景失败 → 添加该场景的规则

2. 微调提示词
   ├─ 增加缺失的关键规则
   └─ 保持总长度在目标范围

3. 重新测试
   └─ 验证改进效果

4. 如无法解决
   └─ 回滚到上一个稳定版本

```

---

## 🚀 实施建议

### 新建三级提示词系统

```

步骤 1: 设计架构
├─ 确定目标 Token 分配 (建议 2,000 total)
├─ L1: 800 tokens (40%)
├─ L2: 400 tokens (20%)
└─ L3: 800 tokens (40%)

步骤 2: 编写 L1
├─ 使用本指南的 L1 模板
├─ 遵循质量标准
└─ 目标: 3,000-3,500 字符

步骤 3: 编写 L2
├─ 对每种语言创建 L2
├─ 使用本指南的 L2 模板
└─ 目标: 1,500-2,000 字符

步骤 4: 编写 L3
├─ 对每种图表类型创建 L3
├─ 使用本指南的 L3 模板
└─ 目标: 3,000-3,500 字符

步骤 5: 测试验证
├─ 功能测试
├─ 性能测试
└─ 质量测试

```

### 优化现有系统

```

步骤 1: 现状分析
├─ 测量当前 Token 消耗
├─ 识别冗余内容
└─ 确定优化目标

步骤 2: 优先级排序
├─ 先优化 L1 (影响最大)
├─ 再优化 L3 (节省最多)
└─ 最后优化 L2 (相对简单)

步骤 3: 渐进式优化
├─ 一次优化一层
├─ 每次优化后测试
└─ 确保质量无下降

步骤 4: A/B 测试
├─ 对比优化前后
├─ 收集数据和反馈
└─ 必要时回滚或微调

步骤 5: 全面切换
├─ 效果验证通过后
├─ 切换到优化版本
└─ 持续监控质量

```

---

## 📚 参考资源

### 编写工具

```

Token 计数:
├─ 在线工具: https://platform.openai.com/tokenizer
└─ 公式: 中文约 4 字符 = 1 token

质量检查:
├─ 长度检查: wc -c filename
├─ 重复检查: diff L1 L2 L3
└─ 完整性检查: 对照质量标准清单

```

### 学习资源

```

AI 提示词工程:
├─ 2025 年最佳实践
├─ 长度优化技巧
└─ 质量保证方法

三层架构设计:
├─ 分层原则
├─ 复用策略
└─ 维护方法

```

---

## ✅ 总结

### 核心原则

```

1. 严格分层 - L1 通用，L2 语言，L3 类型
2. 避免重复 - 每层只包含该层特有内容
3. Top N 原则 - 只保留最重要的 N 个
4. 80/20 法则 - 20% 内容处理 80% 情况
5. 质量优先 - 压缩但不能损失核心规则

```

### 长度目标

```

L1: 3,000-3,500 字符 (750-875 tokens) - 40%
L2: 1,500-2,000 字符 (375-500 tokens) - 20%
L3: 3,000-3,500 字符 (750-875 tokens) - 40%
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
总计: 7,500-9,000 字符 (1,875-2,250 tokens)

```

### 成功关键

```

✅ 使用模板 - 基于本指南的模板
✅ 遵循标准 - 符合质量标准
✅ 测试验证 - A/B 测试确保质量
✅ 持续优化 - 根据反馈迭代
✅ 文档记录 - 记录设计决策

```

---

**文档版本**: 1.0
**创建时间**: 2025-10-18
**基于经验**: DiagramAI 实际优化项目
**适用范围**: 所有三层提示词系统

```
