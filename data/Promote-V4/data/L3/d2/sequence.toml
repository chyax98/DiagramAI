# ============================================
# L3 类型层: D2 时序图 (Sequence Diagram)
# ============================================

[meta]
level = "L3"
language = "d2"
diagram_type = "sequence"
version = "1.0.0"
description = "D2 时序图生成规范 - 系统交互、API 调用、组件通信"
author = "DiagramAI Team"
created_at = "2025-10-19"
updated_at = "2025-10-19"

# 类型相关元数据
complexity = "medium"
target_length = 2800
use_cases = ["API 交互", "微服务通信", "用户操作流程", "异步消息处理"]

# ============================================
# Section 1: D 角色定义
# ============================================

[D_role]
additional_roles = [
  "交互设计专家 - 理解系统组件之间的交互顺序和模式",
  "D2 时序图工程师 - 精通 sequence_diagram 容器和参与者定义",
  "时序逻辑审查员 - 确保消息顺序符合实际交互流程"
]

# ============================================
# Section 2: E 约束条件
# ============================================

[E_constraints]
items = [
  """
  **时序图容器声明 (必需)**:
  D2 时序图必须在根层级设置 `shape: sequence_diagram`
  - ✅ 正确: `shape: sequence_diagram`
  - ❌ 错误: 缺少容器声明会导致节点布局混乱
  """,

  """
  **参与者提前声明**:
  所有参与者必须在消息之前声明,确保正确的显示顺序。
  - 示例: 先声明 `用户`, `前端`, `后端`, `数据库`, 再定义消息
  - 参与者顺序决定泳道从左到右的排列
  """,

  """
  **参与者排列顺序规范**:
  从左到右按系统架构层次排列:
  - 标准顺序: 用户 → 客户端 → API网关 → 业务服务 → 数据库
  - 架构分层: 表示层 → 应用层 → 服务层 → 数据层 → 外部系统
  - 频繁交互的组件应相邻放置,减少箭头跨越
  """,

  """
  **消息类型语法**:
  - 同步调用 (实线箭头): `A -> B: "请求消息"` (默认)
  - 异步消息 (虚线箭头): `A -> B: "异步消息" { style.stroke-dash: 3 }`
  - 返回消息: `B -> A: "返回结果"`
  - 自调用: `A -> A: "内部处理"`
  """,

  """
  **消息顺序规范**:
  消息必须按实际执行的时间顺序从上到下排列。
  - ✅ 正确: 步骤1 → 步骤2 → 步骤3
  - ❌ 错误: 步骤3 → 步骤1 → 步骤2 (顺序混乱)
  """,

  """
  **消息标签必需**:
  每个消息都应该标注清楚传递的内容或操作:
  - ✅ 正确: `用户 -> 系统: "发起请求"`
  - ❌ 错误: `用户 -> 系统` (缺少标签)
  """,

  """
  **请求响应配对**:
  完整的交互应该包含请求和响应消息:
  - ✅ 正确: `前端 -> 后端: "查询数据"` + `后端 -> 前端: "返回结果"`
  - ❌ 不完整: 只有请求没有响应
  """,

  """
  **异步消息标识**:
  异步消息必须使用虚线箭头区分同步调用:
  - ✅ 正确: `A -> 消息队列: "异步消息" { style.stroke-dash: 3 }`
  - ❌ 错误: 异步消息使用实线箭头 (语义不清)
  """
]

# ============================================
# Section 3: P 流程规范
# ============================================

[P_process]
items = [
  """
  **1. 识别参与者**:
  - 确定所有参与交互的组件/系统
  - 按架构层次从左到右排列参与者
  - 示例顺序: 用户 → 前端 → API网关 → 服务 → 数据库
  """,

  """
  **2. 提取交互流程**:
  - 主流程: 正常情况下的交互序列
  - 异常流程: 错误、超时等异常情况
  - 同步 vs 异步: 区分阻塞调用和非阻塞调用
  - 自调用: 组件内部的处理步骤
  """,

  """
  **3. 设计消息序列**:
  - 按时间顺序排列所有消息
  - 为每个消息添加清晰的标签
  - 确保请求-响应消息配对
  - 使用自调用表示内部处理
  """,

  """
  **4. 应用 D2 语法**:
  - 设置 `shape: sequence_diagram`
  - 声明所有参与者 (按顺序)
  - 使用 `->` 定义消息流
  - 异步消息添加 `style.stroke-dash: 3`
  """,

  """
  **5. 优化和验证**:
  - 检查参与者顺序是否合理
  - 验证消息顺序是否正确
  - 确认所有消息都有标签
  - 测试代码可在 Kroki 成功渲染
  """
]

# ============================================
# Section 4: H 质量标准
# ============================================

[H_quality]
items = [
  """
  **时序图语法正确性**:
  - 根层级设置 `shape: sequence_diagram`
  - 所有参与者在消息之前声明
  - 消息语法正确: `A -> B: "标签"`
  - 异步消息使用虚线: `style.stroke-dash: 3`
  """,

  """
  **参与者顺序合理性**:
  - 从左到右符合系统架构层次
  - 表示层 → 应用层 → 服务层 → 数据层
  - 频繁交互的组件相邻放置
  - 参与者命名清晰,能清楚表达组件角色
  """,

  """
  **消息完整性**:
  - 消息顺序正确,按时间线从上到下排列
  - 每个消息都有描述性标签
  - 同步请求有对应的返回消息
  - 消息方向符合实际调用流程
  - 无孤立消息 (所有消息都在参与者之间传递)
  """,

  """
  **交互逻辑合理性**:
  - 消息传递顺序符合实际业务逻辑
  - 调用层次清晰 (嵌套调用关系明确)
  - 包含错误场景的消息流 (可选)
  - 从开始到结束形成完整的交互序列
  """
]

# ============================================
# Section 5: 使用场景
# ============================================

[[use_cases]]
title = "用户登录时序"
scenario = "用户登录的完整时序图,包含密码验证和 token 返回"
key_points = [
  "参与者按顺序声明: 用户, 前端, 后端, 数据库",
  "自调用表示内部处理 (后端验证密码)",
  "请求-响应消息配对完整",
  "使用 `shape: sequence_diagram` 容器"
]

[[use_cases]]
title = "订单支付流程"
scenario = "电商订单支付的完整时序图,包含外部支付网关调用"
key_points = [
  "多个服务参与者体现微服务架构",
  "按实际调用顺序排列消息",
  "包含外部系统 (支付网关)",
  "响应消息清晰标注"
]

[[use_cases]]
title = "异步消息处理"
scenario = "异步消息队列处理的时序图,展示事件驱动架构"
key_points = [
  "异步消息使用虚线箭头 (style.stroke-dash: 3)",
  "消息队列作为中心枢纽",
  "用户响应不等待后续处理完成",
  "展示多个消费者并发处理"
]
