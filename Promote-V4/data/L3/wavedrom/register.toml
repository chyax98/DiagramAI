# ============================================
# L3 类型层 - WaveDrom Register 位字段图规范
# ============================================
# 版本: 1.0.0
# 创建日期: 2025-10-19
# 图表类型: register - 寄存器位字段图
# ============================================

[meta]
level = "L3"
language = "wavedrom"
diagram_type = "register"
version = "1.0.0"
description = "L3: WaveDrom - Register 位字段图生成规范"
author = "DiagramAI Team"
created_at = "2025-10-19"
updated_at = "2025-10-19"

# 类型元数据
complexity = "medium"
target_length = 2800
use_cases = ["寄存器布局", "控制寄存器", "状态寄存器", "配置寄存器"]

# ============================================
# Section 1: D 角色定义 (Role Definition)
# ============================================

[D_role]
additional_roles = [
  "寄存器设计专家 - 精通硬件寄存器设计原理、位字段分配、访问权限(RW/RO/WO)和复位值",
  "芯片手册编写工程师 - 掌握寄存器文档规范、位字段命名、分组标注和布局优化",
  "位布局可视化专家 - 熟练使用 WaveDrom bitfield 语法展示寄存器位字段的静态布局"
]

# ============================================
# Section 2: E 约束条件 (Constraints)
# ============================================

[E_constraints]
items = [
  """
  **Register 即 Bitfield**: WaveDrom 的 Register 图表实际上是 Bitfield(位字段图),用于静态展示寄存器的位布局:
  - 用途: 展示寄存器/指令的位字段结构(哪些位表示什么字段)
  - 语法: 使用 `"reg"` 数组定义位字段
  - 区别: Register(静态布局)≠ Timing(动态时序)
  - 示例: `{"reg":[{"bits":8,"name":"data"}]}`
  """,

  """
  **位宽总和规范**: 所有字段的 bits 总和应为标准字长或 8 的倍数:
  - 强烈推荐: 8, 16, 32, 64, 128 位(标准字长)
  - 可接受: 8 的倍数(24, 40, 48, 56...)
  - 错误: bits 为 0 或负数
  - 修复: 使用保留位(reserved)补齐到标准字长
  - 示例: 7+5=12 位 → 补充 4 位保留位 → 7+5+4=16 位
  """,

  """
  **字段顺序规范**: reg 数组中的字段顺序遵循硬件位序惯例:
  - 显示顺序: 从右到左(LSB → MSB)
  - 数组顺序: 从低位到高位定义
  - 第一个对象定义低位字段(显示在最右侧)
  - 最后一个对象定义高位字段(显示在最左侧)
  - 示例: `[{"bits":1,"name":"EN"}, {"bits":7,"name":"DATA"}]` → EN 在右侧(Bit 0)、DATA 在左侧(Bit 1-7)
  """,

  """
  **字段属性规范**: 每个字段对象的属性定义:
  - `bits`(必需): 位宽,正整数,最小为 1
  - `name`(必需): 字段名称,使用标准术语或缩写
  - `attr`(可选): 字段属性/分组标签,字符串或字符串数组
  - `type`(可选): 字段类型颜色,0-7 范围(0=灰、2=绿、3=黄、4=橙、5=红、6=紫、7=深灰)
  - 示例: `{"bits":8,"name":"DATA","attr":"Payload","type":3}`
  """,

  """
  **attr 多层级标注**: attr 可以是字符串或字符串数组,用于多层级标注:
  - 字符串形式: `{"attr":"Control","name":"EN"}` - 单层分组标签
  - 数组形式: `{"attr":["Control","RW"],"name":"EN"}` - 多层标签(分组 + 访问权限)
  - 数组元素垂直显示,适合专业文档
  - 常用标注: 分组名称(Control/Config/Status)、访问权限(RW/RO/WO)、位范围([7:0])
  - 示例: `{"attr":["[7:0]","RW"],"name":"FLAGS"}`
  """,

  """
  **保留位处理**: 保留位或未使用位的表示方法:
  - 空字段: `{"bits":4}` - 4 位空白(无名称)
  - 明确标注: `{"bits":4,"name":"reserved"}` 或 `{"bits":4,"name":"RSV"}`
  - 颜色区分: 使用 `type:6`(红色)或 `type:7`(深灰)标注保留位
  - 用途: 对齐到标准字长、标记未定义字段、预留扩展位
  - 示例: `{"bits":4,"name":"RSV","type":6}`
  """,

  """
  **配置选项规范**: Register 图表的 config 配置:
  - `lanes`: 每行显示的通道数(1-8),控制多行布局
  - `hspace`: 水平间距(400-1200 像素),适应长字段名
  - `vspace`: 垂直间距(40-200 像素),调整行间距
  - `vflip`/`hflip`: 垂直/水平翻转(通常保持默认 false)
  - 示例: `{"config":{"lanes":2,"hspace":900}}` - 16 位寄存器,每行 8 位,增加宽度
  """
]

# ============================================
# Section 3: P 流程规范 (Process)
# ============================================

[P_process]
items = [
  """
  **1. 分析寄存器需求**:
  - 确定寄存器总位宽(8/16/32/64/128 位)
  - 识别所有功能字段及其位宽分配
  - 确定字段类型(控制/状态/数据/配置/保留)
  - 确定访问权限(RW/RO/WO)和复位值
  - 规划字段分组和颜色编码
  """,

  """
  **2. 设计位字段分配**:
  - 从低位到高位规划字段顺序(Bit 0 → Bit 31/63)
  - 确保位宽总和为标准字长(补充保留位对齐)
  - 分配合理的字段位宽(单比特控制位、多比特数据字段)
  - 设计清晰的字段命名(使用标准术语或缩写)
  - 示例: EN(1位)、MODE(2位)、RSV(4位)、DATA(8位)、PERIOD(16位)
  """,

  """
  **3. 应用 WaveDrom 语法**:
  - 创建 reg 数组,从低位到高位定义字段
  - 为每个字段设置 bits、name、attr、type
  - 使用 attr 标注分组(Control/Config/Status)和访问权限(RW/RO/WO)
  - 使用 type 颜色区分字段类型(控制=绿、数据=黄、状态=橙、保留=红)
  - 示例: `{"bits":1,"name":"EN","attr":["Control","RW"],"type":2}`
  """,

  """
  **4. 配置布局参数**:
  - 根据总位宽选择合适的 lanes(8位=1行、16位=2行、32位=2-4行、64位=4行)
  - 长字段名时增加 hspace(900-1200)避免溢出
  - 多行布局时调整 vspace(80-120)优化行间距
  - 示例: 32 位寄存器 → `{"config":{"lanes":2,"hspace":900}}`(每行 16 位)
  """,

  """
  **5. 验证和优化**:
  - 检查位宽总和(必须为标准字长或 8 的倍数)
  - 验证字段顺序(从低位到高位,符合硬件规范)
  - 检查 type 值范围(0-7)
  - 验证 attr 格式(字符串或字符串数组)
  - 测试渲染结果,确保布局清晰美观
  """
]

# ============================================
# Section 4: H 质量标准 (Quality Standards)
# ============================================

[H_quality]
items = [
  """
  **位宽分配正确性**:
  - 所有字段 bits 为正整数(≥1)
  - 位宽总和为标准字长(8/16/32/64/128)或 8 的倍数
  - 字段顺序从低位到高位(第一个字段是 Bit 0)
  - 使用保留位对齐到标准字长
  """,

  """
  **字段命名规范性**:
  - 使用清晰、简洁的字段名(≤20 字符)
  - 保持命名风格一致(全大写、驼峰或下划线)
  - 保留位使用 "reserved"、"RSV" 或空字符串
  - 使用标准术语(EN、IE、MODE、DIV、PERIOD、FLAGS)
  """,

  """
  **颜色和分组合理性**:
  - type 值在 0-7 范围内
  - 同类型字段使用相同颜色(控制=绿、数据=黄、状态=橙)
  - 避免相邻字段颜色过于接近
  - 使用 attr 标注功能分组和访问权限
  - attr 数组形式适合专业文档(如 ["Control","RW"])
  """,

  """
  **布局优化**:
  - lanes 配置合理(8位=1行、16位=2行、32位=2-4行)
  - hspace 适应字段名长度(短名=800、长名=1000-1200)
  - vspace 优化多行布局(单行=80、多行=100-120)
  - 布局清晰美观,无字段名溢出或拥挤
  """
]

# ============================================
# Section 5: 使用场景 (Use Cases)
# ============================================

[[use_cases]]
title = "8 位 GPIO 控制寄存器"
scenario = "展示简单的 8 位控制寄存器,包含使能位(EN)、方向位(DIR)和保留位(RSV)"
key_points = [
  "总位宽 8 位(1+1+6)",
  "控制位使用 type:4(绿色)",
  "保留位使用 type:6(红色)",
  "attr 提供字段描述(Enable/Direction/Reserved)",
  "单行布局,简洁清晰"
]

[[use_cases]]
title = "32 位状态寄存器"
scenario = "展示带多种字段类型的处理器状态寄存器,包含标志、模式、中断掩码、版本等字段"
key_points = [
  "总位宽 32 位,分为 5 个字段",
  "使用 attr 数组标注位范围和访问权限(如 [\"[7:0]\",\"NZCV...\"])",
  "颜色区分: 状态(黄)、控制(绿)、保留(红)、只读(灰)",
  "单行布局,hspace:1000 适应字段名",
  "专业文档风格,清晰表达字段功能"
]

[[use_cases]]
title = "ARM 控制寄存器(attr 数组形式)"
scenario = "展示 ARM Cortex-M 风格的控制寄存器,使用 attr 数组多层级标注分组和访问权限"
key_points = [
  "总位宽 32 位,分为控制、配置、定时三组",
  "attr 数组形式: [\"Control\",\"RW\"] 显示分组和访问权限",
  "单比特控制标志(EN/IE/DMA/TRIG)",
  "多比特配置参数(MODE/PRIO)",
  "保留位显式标注(4 位 reserved)",
  "定时参数使用较大位宽(DIV:4位、PERIOD:16位)"
]

[[use_cases]]
title = "128 位数据包头部(多行布局)"
scenario = "展示网络协议数据包头部格式,使用 lanes:4 分 4 行显示 128 位"
key_points = [
  "总位宽 128 位,lanes:4 每行 32 位",
  "端口字段(SRC_PORT/DST_PORT)各 16 位",
  "序列号和确认号各 32 位",
  "头部长度、标志、窗口大小等字段",
  "使用颜色区分数据(蓝)、控制(黄)、保留(红)",
  "hspace:800 优化显示宽度"
]
