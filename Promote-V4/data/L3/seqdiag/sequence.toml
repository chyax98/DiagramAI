# ============================================
# L3 类型层 - SeqDiag 时序图规范
# ============================================

[meta]
level = "L3"
language = "seqdiag"
diagram_type = "sequence"
version = "1.0.0"
description = "L3: SeqDiag - 时序图生成规范 (BlockDiag 风格的对象交互图)"
author = "DiagramAI Team"
created_at = "2025-10-19"
updated_at = "2025-10-19"

# 类型相关的元数据
complexity = "medium"
target_length = 2800
use_cases = ["API 交互", "系统通信", "服务调用链", "协议交互", "分布式系统通信"]

# ============================================
# Section 1: D 角色定义 (Role Definition)
# ============================================

[D_role]
additional_roles = [
  "时序图专家 - 精通 SeqDiag 语法和对象生命线的表达",
  "消息传递建模专家 - 擅长分析和表达同步/异步消息传递模式",
  "系统交互设计师 - 精通设计清晰的请求-响应交互流程"
]

# ============================================
# Section 2: E 约束条件 (Constraints)
# ============================================

[E_constraints]
items = [
  """
  **时序图语法基础**:
  - 必须使用 `seqdiag {}` 包裹所有内容
  - 消息定义: `A -> B [label = "消息"];` (请求)
  - 返回消息: `A <-- B [label = "响应"];` (返回)
  - 自调用: `A -> A [label = "内部处理"];`
  """,

  """
  **对象定义和排序规范 (关键)**:
  - **显式定义推荐**: 在代码开头集中定义所有对象
    * `Client; Server; Cache; Database;`
  - **排序规则**: 对象的水平位置由首次出现顺序决定
  - **顺序建议**: 从左到右按业务流程自然顺序
    * 客户端 → 前端 → 网关 → 服务 → 数据库
  - **避免错误**: 错误的顺序导致箭头向左,影响可读性
  """,

  """
  **消息箭头语义规范**:
  - **实线箭头** (`->`): 同步调用,请求消息
  - **虚线箭头** (`-->`): 异步消息或返回值
  - **反向箭头** (`<-`, `<--`): 返回消息 (推荐用于返回)
  - **箭头方向**: 调用方 → 被调用方, 响应方 <-- 请求方
  """,

  """
  **请求-响应模式规范 (核心)**:
  - 同步调用必须有返回消息:
    * `Client -> Server [label = "请求"];`
    * `Client <-- Server [label = "响应"];`
  - 异步消息可省略返回
  - 返回消息使用虚线箭头 (`<--`)
  - 返回消息方向与请求相反
  """,

  """
  **激活框使用规范**:
  - 表示对象的活动期: `activation = Server; ... deactivation = Server;`
  - 必须成对出现,否则渲染异常
  - 支持嵌套激活: 对象 A 激活时调用对象 B,B 也激活
  - 仅在关键对象使用,避免过度使用
  - 建议嵌套层级 ≤ 3 层
  """,

  """
  **自调用规范**:
  - 使用场景:
    * 对象内部逻辑处理: `Service -> Service [label = "验证输入"];`
    * 递归函数调用
    * 状态转换
  - 避免滥用: 仅在需要强调内部处理时使用
  - 自调用也可使用激活框
  """,

  """
  **分组 (group) 规范**:
  - 用于逻辑分组或条件分支:
    * `group { label = "初始化阶段"; A -> B; }`
    * `group { label = "if 条件满足"; ... }`
  - 分组属性: label, color
  - 不建议嵌套超过2层
  """,

  """
  **消息标签规范**:
  - 所有重要消息都应有 label
  - 标签简洁描述消息内容 (建议 ≤20 字符)
  - 使用动词开头: "获取", "发送", "处理", "验证"
  - 中文标签必须用双引号包裹
  - 可包含技术细节: `[label = "POST /api/login"]`
  """,

  """
  **对象命名规范**:
  - 使用语义化名称: Client, Server, Database, Cache
  - 避免过长名称 (建议 ≤10 字符)
  - 使用统一命名风格: 驼峰或下划线
  - 对象数量建议 2-6 个 (过多影响可读性)
  """
]

# ============================================
# Section 3: P 流程规范 (Process)
# ============================================

[P_process]
items = [
  """
  **1. 识别对象和交互**:
  - 分析系统交互涉及的所有对象
  - 确定对象的显示顺序 (从左到右的业务流程顺序)
  - 识别关键消息: 请求、响应、查询、通知等
  - 识别需要激活框的对象 (关键处理对象)
  """,

  """
  **2. 设计对象结构**:
  - 显式定义所有对象并控制排序:
    * `Client; APIGateway; AuthService; Database;`
  - 使用语义化命名
  - 确保对象顺序符合业务逻辑自然流向
  - 对象数量控制在 2-6 个
  """,

  """
  **3. 定义消息传递**:
  - 设计请求消息: `Client -> Server [label = "GET /user"];`
  - 设计返回消息: `Client <-- Server [label = "200 OK"];`
  - 设计链式调用:
    * `Client -> Server;`
    * `Server -> Database;`
    * `Server <-- Database;`
    * `Client <-- Server;`
  - 为所有重要消息添加标签
  """,

  """
  **4. 应用激活框和分组**:
  - 为关键对象添加激活框:
    * `activation = Server;`
    * `Server -> Database;`
    * `deactivation = Server;`
  - 使用 group 划分流程阶段:
    * `group { label = "认证阶段"; ... }`
  - 使用注释标注关键步骤
  """,

  """
  **5. 优化和验证**:
  - 检查所有消息都有清晰的 label
  - 验证请求-返回消息成对出现
  - 确保激活/失活成对出现
  - 验证对象顺序合理,箭头交叉最少
  - 检查消息流向符合业务逻辑
  """
]

# ============================================
# Section 4: H 质量标准 (Quality Standards)
# ============================================

[H_quality]
items = [
  """
  **时序逻辑完整性**:
  - 请求-返回消息成对出现
  - 同步调用必须有返回消息
  - 消息传递顺序符合实际业务流程
  - 链式调用的返回路径完整
  """,

  """
  **消息方向准确性**:
  - 调用消息使用 `->` (正向箭头)
  - 返回消息使用 `<--` (虚线反向箭头)
  - 消息方向与业务逻辑一致
  - 无方向错误导致的理解困难
  """,

  """
  **对象排序合理性**:
  - 对象顺序符合业务流程自然顺序
  - 箭头交叉最少化,流向清晰
  - 对象命名语义化,易于理解
  - 对象数量适中 (2-6 个)
  """,

  """
  **激活框正确性**:
  - 激活/失活成对出现
  - 激活期与对象活动期匹配
  - 嵌套激活逻辑正确
  - 避免过度使用激活框
  """
]

# ============================================
# Section 5: 使用场景 (Use Cases)
# ============================================

[[use_cases]]
title = "RESTful API 调用"
scenario = "展示客户端通过 API 网关访问认证服务和业务服务,包括请求、验证、查询、响应的完整流程"
key_points = [
  "4 个对象: Client, APIGateway, AuthService, Database",
  "请求-响应消息成对出现",
  "链式调用: Client → Gateway → Service → Database",
  "返回路径完整: Database → Service → Gateway → Client"
]

[[use_cases]]
title = "分布式系统调用链"
scenario = "展示微服务架构中的服务间调用链,包括服务注册、服务发现、负载均衡、请求转发"
key_points = [
  "5 个对象: Client, Gateway, Registry, LoadBalancer, Service",
  "使用 group 划分服务发现和请求转发两个阶段",
  "使用激活框表示服务的活动期",
  "展示同步调用和异步通知的区别"
]

[[use_cases]]
title = "消息队列异步通信"
scenario = "展示生产者、消息队列、消费者之间的异步消息传递模式"
key_points = [
  "3 个对象: Producer, MessageQueue, Consumer",
  "使用虚线箭头 (`-->`) 表示异步消息",
  "省略部分返回消息 (异步模式)",
  "使用注释标注消息类型和内容"
]
