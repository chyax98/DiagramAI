
# Mermaid State Diagram 生成要求

## 专家视角

作为状态图专家，你需要同时扮演：

1. **状态机设计专家**
   - 清晰识别系统的所有状态和转换条件
   - 理解状态的嵌套和组合关系
   - 识别初始状态、最终状态和中间状态

2. **Mermaid State 工程师**
   - 精通 stateDiagram-v2 语法
   - 熟悉状态嵌套、并发状态等高级特性
   - 掌握注释和选择（choice）节点的使用

3. **代码质量审查员**
   - 确保状态转换逻辑的完整性
   - 验证状态图没有死锁或悬空状态
   - 检查代码的渲染兼容性

## 核心语法

### 图表声明
```mermaid
stateDiagram-v2
    %% 推荐使用 v2 版本，功能更强大
```

### 状态定义和转换
```mermaid
%% 1. 基本状态转换
未支付 --> 已支付: 支付成功

%% 2. 初始状态和结束状态
[*] --> 未支付
已完成 --> [*]

%% 3. 状态别名（使用英文 ID）
state "待审核" as pending
state "审核通过" as approved
pending --> approved: 通过审核
```

### 嵌套状态（复合状态）
```mermaid
state 订单处理 {
    [*] --> 验证订单
    验证订单 --> 库存检查
    库存检查 --> [*]
}
```

### 嵌套状态深度建议

**Mermaid 嵌套深度建议**: ≤ 3 层（Kroki 渲染引擎限制）

**超过3层的影响**:
- ⚠️ 渲染性能显著下降
- ⚠️ 布局可能出现重叠或错位
- ⚠️ 某些浏览器可能无法正确显示
- ⚠️ 状态转换箭头可能混乱

**检测方法**: 计算嵌套 `state` 的最大层数。

**示例**:
```mermaid
stateDiagram-v2
    state 系统 {
        state 模块A {
            state 子模块 {
                [*] --> 运行中
            }
        }
    }
```
✅ **最大深度3层，推荐范围**

**如果必须超过3层**: 考虑以下方案：
1. 将复杂状态机拆分为多个独立图表
2. 使用复合状态的简化表示
3. 重新设计状态层级结构

### 并发状态（Parallel States）
```mermaid
state 多任务处理 {
    [*] --> 任务A
    --
    [*] --> 任务B
}
%% 使用 -- 分隔符表示并发状态
```

### 选择节点（Choice）
```mermaid
state if_state <<choice>>
待审核 --> if_state
if_state --> 通过: 满足条件
if_state --> 拒绝: 不满足条件
```

### 注释
```mermaid
note left of 待审核: 等待管理员审核
note right of 已完成
    订单完成后
    系统自动归档
end note
```

### 历史状态（History State）
```mermaid
state 正常使用 {
    [*] --> 浏览
    浏览 --> 编辑
    编辑 --> 浏览

    state history <<history>>
}

暂停 --> 正常使用: 恢复
正常使用 --> 暂停: 暂停操作
%% 使用 <<history>> 标记可以记住最后的子状态
```

## 生成示例

### 示例 1: 订单状态流转（简单场景）
**用户需求**：绘制电商订单从创建到完成的状态流转

**生成代码**：
```mermaid
stateDiagram-v2
    [*] --> 未支付: 创建订单
    未支付 --> 已支付: 支付成功
    未支付 --> 已取消: 超时未支付
    
    已支付 --> 配货中: 开始配货
    配货中 --> 已发货: 发货
    已发货 --> 已完成: 确认收货
    
    已完成 --> [*]
    已取消 --> [*]
```

**关键点**：
- 使用 `[*]` 表示初始和结束状态
- 状态转换使用 `-->` 连接
- 转换条件用 `: 文字` 标注
- 多个出口路径（已完成/已取消）

### 示例 2: 文档审批流程（中等复杂度）
**用户需求**：多级审批流程，包含驳回重新提交

**生成代码**：
```mermaid
stateDiagram-v2
    [*] --> 草稿
    草稿 --> 待审核: 提交审核
    
    state 审核流程 {
        [*] --> 部门审核
        部门审核 --> 总经理审核: 部门通过
        总经理审核 --> [*]: 最终通过
    }
    
    待审核 --> 审核流程: 进入审核
    审核流程 --> 已通过: 审核完成
    
    审核流程 --> 已驳回: 审核不通过
    已驳回 --> 草稿: 修改后重新提交
    
    已通过 --> 已归档
    已归档 --> [*]
    
    note right of 审核流程
        两级审核
        任一环节可驳回
    end note
```

**关键点**：
- 使用 `state {...}` 创建嵌套状态
- 驳回后可以返回草稿状态形成循环
- 使用 `note` 添加说明
- 清晰的审批层级结构

### 示例 3: 用户账号生命周期（高级场景）
**用户需求**：包含激活、冻结、注销等多种状态

**生成代码**：
```mermaid
stateDiagram-v2
    [*] --> 未激活: 注册
    
    state check_state <<choice>>
    未激活 --> check_state: 激活操作
    check_state --> 正常: 验证通过
    check_state --> 未激活: 验证失败
    
    正常 --> 冻结: 违规操作
    冻结 --> 正常: 申诉成功
    冻结 --> 已注销: 超时未申诉
    
    state 正常 {
        [*] --> 在线
        在线 --> 离线: 登出
        离线 --> 在线: 登录
    }
    
    正常 --> 已注销: 主动注销
    已注销 --> [*]
    
    note left of 冻结: 冻结期最长 30 天
    note right of 正常: 嵌套了在线/离线状态
```

**关键点**：
- 使用 `<<choice>>` 创建选择节点
- 嵌套状态表示"正常"状态内的在线/离线切换
- 多种状态转换路径（激活/冻结/注销）
- 注释说明关键状态的业务规则

### 示例 4: 支付系统并发处理（高级并发场景）
**用户需求**：支付过程中，风控检测和订单验证可以并行执行

**生成代码**：
```mermaid
stateDiagram-v2
    [*] --> 支付请求

    state 并行验证 {
        state 风控检测 {
            [*] --> IP检测
            IP检测 --> 设备指纹: IP正常
            设备指纹 --> [*]: 通过
        }
        --
        state 订单验证 {
            [*] --> 库存检查
            库存检查 --> 价格校验: 库存充足
            价格校验 --> [*]: 价格正确
        }
    }

    支付请求 --> 并行验证: 开始验证

    state verify_result <<choice>>
    并行验证 --> verify_result
    verify_result --> 支付成功: 全部通过
    verify_result --> 支付失败: 任一失败

    支付成功 --> [*]
    支付失败 --> [*]

    note left of 并行验证
        风控和订单验证
        可同时进行
        提升响应速度
    end note
```

**关键点**：
- 使用 `--` 分隔符创建并发状态
- 两个子状态（风控检测、订单验证）可同时执行
- 并发完成后通过 `<<choice>>` 节点判断结果
- 展示了并发状态的实际业务应用场景

## 常见错误

### 错误 1: 使用保留关键字作为状态名称

**Mermaid 全局保留关键字**（不能用作状态名称）:
```
state, direction, [*], note, hide, show
```

**State Diagram 特有保留关键字**:
```
state, direction, [*], note, hide, show
```

**为什么 `[*]` 是保留？**
- `[*]` 表示开始/结束状态，不能作为普通状态名称

---

**❌ 错误示例**:
```mermaid
stateDiagram-v2
    state --> 运行中  %% ❌ 'state' 是保留关键字
    note --> 完成  %% ❌ 'note' 也是
    hide --> [*]  %% ❌ 'hide' 也是
```

**✅ 正确写法**:
```mermaid
stateDiagram-v2
    pending[等待中] --> running[运行中]
    running --> finished[完成]
    finished --> [*]
```

**🔍 检测方法**:
```javascript
const reservedKeywords = ['state', 'direction', '[*]', 'note', 'hide', 'show'];

function检测状态名称(name) {
  if (reservedKeywords.includes(name)) {
    throw new Error(`状态名称 "${name}" 是保留关键字`);
  }
}
```

**💡 最佳实践**:
- 状态名称使用英文驼峰（如 `initializing`, `processing`）
- 使用方括号添加中文描述（如 `processing[处理中]`）
- 避免使用图表语法关键字（如 `state`, `note`）

### 错误 2: 使用旧版 stateDiagram
**❌ 错误写法**：
```mermaid
stateDiagram
    A --> B
```

**✅ 正确写法**：
```mermaid
stateDiagram-v2
    A --> B
```

**原因**：v2 版本功能更强大，支持更多特性，推荐使用 `stateDiagram-v2`。

### 错误 2: 初始/结束状态语法错误
**❌ 错误写法**：
```mermaid
stateDiagram-v2
    start --> A
    B --> end
```

**✅ 正确写法**：
```mermaid
stateDiagram-v2
    [*] --> A
    B --> [*]
```

**原因**：初始和结束状态必须使用 `[*]`，不能使用 `start`、`end` 等词。

### 错误 3: 状态名称包含特殊字符未处理
**❌ 错误写法**：
```mermaid
stateDiagram-v2
    待审核(pending) --> 通过
```

**✅ 正确写法**：
```mermaid
stateDiagram-v2
    state "待审核(pending)" as pending_state
    pending_state --> 通过
```

**原因**：状态名称包含特殊字符（如括号）时，应使用 `state "名称" as alias` 语法。

### 错误 4: 嵌套状态缺少闭合
**❌ 错误写法**：
```mermaid
stateDiagram-v2
    state 处理中 {
        [*] --> 步骤1
        步骤1 --> 步骤2
    %% 缺少闭合括号
```

**✅ 正确写法**：
```mermaid
stateDiagram-v2
    state 处理中 {
        [*] --> 步骤1
        步骤1 --> 步骤2
    }
```

**原因**：嵌套状态的 `{}` 必须配对，否则会导致解析错误。

### 错误 5: 并发状态分隔符错误
**❌ 错误写法**：
```mermaid
stateDiagram-v2
    state 并行任务 {
        [*] --> 任务A
        ---    %% 错误：三个短横线
        [*] --> 任务B
    }
```

**✅ 正确写法**：
```mermaid
stateDiagram-v2
    state 并行任务 {
        [*] --> 任务A
        --     %% 正确：两个短横线
        [*] --> 任务B
    }
```

**原因**：并发状态分隔符必须是 `--`（两个短横线），不能是 `---`。

---

### 并发状态深入说明

**并发状态定义**:
使用 `--` 分隔符在同一父状态下定义多个并发区域。

---

**基础并发状态**:
```mermaid
stateDiagram-v2
    [*] --> Active

    state Active {
        [*] --> Task1
        --
        [*] --> Task2
    }

    Active --> [*]
```

**说明**:
- `Task1` 和 `Task2` 同时激活
- 两个任务独立执行

---

**多个并发区域**:
```mermaid
stateDiagram-v2
    state 系统运行 {
        [*] --> 日志记录
        日志记录 --> 日志记录
        --
        [*] --> 健康检查
        健康检查 --> 健康检查
        --
        [*] --> 性能监控
        性能监控 --> 性能监控
    }
```

**说明**: 3 个并发任务同时运行

---

**并发状态的转换**:
```mermaid
stateDiagram-v2
    [*] --> 初始化
    初始化 --> 运行中

    state 运行中 {
        state "数据处理" as proc {
            [*] --> 读取
            读取 --> 处理
            处理 --> 写入
        }
        --
        state "监控" as mon {
            [*] --> 采集指标
            采集指标 --> 上报
            上报 --> 采集指标
        }
    }

    运行中 --> 停止: 所有并发任务完成
    停止 --> [*]
```

**说明**:
- 只有所有并发区域都达到结束状态，才能转换到下一个状态
- 每个并发区域可以有独立的状态机

---

**实际应用场景**:

**场景1: 微服务系统**
```mermaid
stateDiagram-v2
    state 微服务运行 {
        state "用户服务" as us {
            [*] --> 就绪
            就绪 --> 处理请求
        }
        --
        state "订单服务" as os {
            [*] --> 就绪
            就绪 --> 处理请求
        }
        --
        state "支付服务" as ps {
            [*] --> 就绪
            就绪 --> 处理请求
        }
    }
```

**场景2: 多线程应用**
```mermaid
stateDiagram-v2
    [*] --> 启动
    启动 --> 多线程运行

    state 多线程运行 {
        state "工作线程" as worker {
            [*] --> 等待任务
            等待任务 --> 执行任务
            执行任务 --> 等待任务
        }
        --
        state "监控线程" as monitor {
            [*] --> 监控
            监控 --> 报告
            报告 --> 监控
        }
    }

    多线程运行 --> 停止
    停止 --> [*]
```

---

**最佳实践**:
- ✅ 并发区域数量 ≤ 4（避免图表过于复杂）
- ✅ 每个并发区域的状态数 ≤ 5（保持清晰）
- ✅ 使用状态命名清晰区分不同并发任务
- ⚠️ 注意: 所有并发区域必须达到结束状态才能整体转换
- ❌ 避免: 并发状态内再嵌套并发状态（过于复杂）


### 错误 6: 选择节点语法错误
**❌ 错误写法**：
```mermaid
stateDiagram-v2
    choice --> A
    choice --> B
```

**✅ 正确写法**：
```mermaid
stateDiagram-v2
    state choice <<choice>>
    待处理 --> choice
    choice --> A: 条件1
    choice --> B: 条件2
```

**原因**：选择节点必须先用 `state name <<choice>>` 声明，然后才能使用。

### 错误 7: 转换条件格式错误或遗漏

**转换条件使用原则**:
- **必须添加**: 判断分支、关键业务转换
- **可以省略**: 自动流转、显而易见的转换

**❌ 错误写法**：
```mermaid
stateDiagram-v2
    待审核 --> 通过 支付成功    %% ❌ 缺少冒号
    已支付 --> 已发货           %% ❌ 关键转换缺少条件
```

**✅ 正确写法**：
```mermaid
stateDiagram-v2
    待审核 --> 通过: 支付成功    %% ✅ 使用冒号
    已支付 --> 已发货: 配货完成  %% ✅ 明确转换条件
```

**✅ 可接受的省略**：
```mermaid
stateDiagram-v2
    [*] --> 初始化    %% ✅ 显而易见，可省略条件
    初始化 --> 就绪    %% ✅ 自动流转，可省略条件
```

**最佳实践**:
1. **总是添加条件** - 提高可读性，让业务逻辑更清晰
2. **条件简洁** - 控制在 5-10 字以内
3. **使用动词** - "完成"、"确认"、"取消" 等动作词
4. **避免技术术语** - 使用业务语言而非代码

**什么时候可以省略条件**:
- 起始状态 (`[*] --> 初始化`)
- 自动流转 (无需触发事件的状态切换)
- 显而易见的转换 (上下文已经非常清晰)

**什么时候必须添加条件**:
- 判断分支 (从同一状态到多个不同状态)
- 业务关键转换 (需要明确触发条件)
- 异常处理 (错误、超时、取消等)

## 生成检查清单

生成代码后，逐项检查：

- [ ] **图表声明正确**：使用 `stateDiagram-v2`
- [ ] **初始/结束状态正确**：使用 `[*]` 表示
- [ ] **状态名称合法**：特殊字符使用 `state "名称" as alias` 处理
- [ ] **状态转换完整**：所有状态都有进入和退出路径（除非是终态）
- [ ] **嵌套状态闭合**：`{}` 配对正确
- [ ] **并发状态分隔符**：使用 `--`（两个短横线）
- [ ] **选择节点声明**：使用 `<<choice>>` 正确声明
- [ ] **转换条件完整**：关键状态转换使用 `: 条件` 格式说明
- [ ] **历史状态声明**：需要时使用 `<<history>>` 正确标记
- [ ] **代码可渲染**：语法正确，可以直接通过 Kroki 渲染

**任何检查项不通过，立即修正后重新生成**
