# DiagramAI 三级提示词系统分析

> 分析时间: 2025-10-18  
> 分析范围: 提示词架构、合成机制、版本管理、数据流

---

## 📊 架构概览

DiagramAI 使用**三层金字塔式 Prompt 架构**，将提示词按照抽象层级分为三层，实现了提示词的模块化、复用和精确控制。

```mermaid
graph TB
    subgraph "提示词层级结构"
        L1["L1: 通用规范<br/>universal.txt<br/>所有图表共享"]
        L2["L2: 语言规范<br/>{language}/common.txt<br/>特定渲染语言<br/>可选"]
        L3["L3: 类型规范<br/>{language}/{type}.txt<br/>特定图表类型<br/>必需"]
    end
    
    subgraph "使用场景示例"
        L1 --> L2_mermaid["L2: Mermaid 通用规范"]
        L2_mermaid --> L3_flow["L3: Mermaid Flowchart"]
        L2_mermaid --> L3_seq["L3: Mermaid Sequence"]
        L2_mermaid --> L3_other["L3: 其他 Mermaid 类型"]
    end
    
    style L1 fill:#e1f5ff
    style L2 fill:#fff3e0
    style L3 fill:#f3e5f5
```

---

## 🔍 三层提示词详解

### L1: 通用规范层（Universal）

**文件位置**: `data/prompts/universal.txt`（约 641 行）

**作用域**: 所有图表类型

**核心内容**:
1. **任务识别系统**（最高优先级）
   - `<<<SYSTEM_INSTRUCTION: GENERATE_NEW_DIAGRAM>>>` - 生成新图表
   - `<<<SYSTEM_INSTRUCTION: ADJUST_EXISTING_DIAGRAM>>>` - 调整现有图表
   - `<<<SYSTEM_INSTRUCTION: FIX_SYNTAX_ERRORS_ONLY>>>` - 仅修复语法错误

2. **通用输出要求**
   - 纯代码输出，无 Markdown 包装
   - 无注释和解释文本
   - 语法正确性保证

3. **AI 行为规范**
   - 理解用户意图的方法
   - 代码生成的原则
   - 错误处理的策略

**示例片段**:
```text
## ⚠️ 【最高优先级指令】任务识别

每条用户消息的**开头**会包含一个 `<<<SYSTEM_INSTRUCTION>>>` 标记，这是系统级指令，
**优先级高于所有其他规范和最佳实践**，必须严格遵守。

### 📋 三种任务指令
...
```

---

### L2: 语言规范层（Language-Specific）

**文件位置**: `data/prompts/{language}/common.txt`

**作用域**: 特定渲染语言的所有图表类型

**特点**: 
- **可选层级** - 21/23 种语言有此文件
- 无 L2 时不影响系统运行

**核心内容**（以 Mermaid 为例）:
1. **语言强制规则**
   - 保留关键字列表
   - 特殊字符转义规则
   - 注释语法规范

2. **语言最佳实践**
   - 命名规范
   - 布局建议
   - 样式约定

**示例片段**（`mermaid/common.txt`）:
```text
## 🚨 Mermaid 强制规则（违反即编译失败）

### 规则1: 保留关键字冲突
**全局保留关键字**（不能用作节点 ID）:
graph, subgraph, end, flowchart, direction,
class, classDef, style, click, call, href, callback,
title, section, note

**检测方法**: 在生成前扫描所有节点 ID，与保留关键字列表对比。
```

---

### L3: 类型规范层（Type-Specific）

**文件位置**: `data/prompts/{language}/{type}.txt`

**作用域**: 特定图表类型

**特点**: 
- **必需层级** - 每个图表类型都必须有对应的 L3 文件
- 最精确、最具针对性的提示词

**核心内容**（以 `mermaid/flowchart.txt` 为例）:
1. **专家视角定义**
   - 流程设计专家
   - Mermaid Flowchart 工程师
   - 代码质量审查员

2. **核心语法规范**
   - 图表声明方式
   - 节点类型定义
   - 连接线规范

3. **高级特性**
   - 子图（subgraph）用法
   - 样式定制
   - 链接和交互

**示例片段**（`mermaid/flowchart.txt`）:
```text
## 专家视角

作为流程图专家，你需要同时扮演：

1. **流程设计专家**
   - 将复杂业务逻辑转化为清晰的流程图
   - 识别流程中的关键决策点和分支路径
   - 确保流程的完整性（有明确的起点和终点）

2. **Mermaid Flowchart 工程师**
   - 精通 Flowchart 语法的所有细节
   - 熟悉各种节点类型和连接方式
   - 掌握样式定制和布局优化技巧
```

---

## 🔧 提示词合成机制

### 合成流程

```mermaid
flowchart TD
    Start[用户请求] --> Parse[解析参数]
    Parse --> |renderLanguage<br/>diagramType| LoadL1[加载 L1 通用规范]
    
    LoadL1 --> CheckDB1{数据库有<br/>自定义版本?}
    CheckDB1 -->|是| UseDB1[使用数据库版本]
    CheckDB1 -->|否| UseFile1[使用 universal.txt]
    
    UseDB1 --> LoadL2[加载 L2 语言规范]
    UseFile1 --> LoadL2
    
    LoadL2 --> CheckDB2{数据库有<br/>自定义版本?}
    CheckDB2 -->|是| UseDB2[使用数据库版本]
    CheckDB2 -->|否| CheckFile2{文件系统有<br/>common.txt?}
    CheckFile2 -->|是| UseFile2[使用 common.txt]
    CheckFile2 -->|否| SkipL2[跳过 L2<br/>可选层]
    
    UseDB2 --> LoadL3[加载 L3 类型规范]
    UseFile2 --> LoadL3
    SkipL2 --> LoadL3
    
    LoadL3 --> CheckDB3{数据库有<br/>自定义版本?}
    CheckDB3 -->|是| UseDB3[使用数据库版本]
    CheckDB3 -->|否| UseFile3[使用 {type}.txt]
    
    UseDB3 --> Merge[合并三层提示词]
    UseFile3 --> Merge
    
    Merge --> Final[最终 Prompt]
    Final --> SendAI[发送给 AI 模型]
    
    style LoadL1 fill:#e1f5ff
    style LoadL2 fill:#fff3e0
    style LoadL3 fill:#f3e5f5
    style Merge fill:#c8e6c9
    style Final fill:#ffccbc
```

### 核心代码实现

#### 1. 主入口函数（`src/lib/constants/prompts/index.ts`）

```typescript
export function getGeneratePrompt(
  renderLanguage: RenderLanguage,
  diagramType: DiagramType
): string {
  const db = getDatabaseInstance();
  const repo = new PromptRepository(db);

  // 1. L1: 通用规范 (所有图表共享)
  const l1 = repo.findActive(1);

  // 2. L2: 语言规范 (如 Mermaid 通用规范)
  const l2 = repo.findActive(2, renderLanguage);

  // 3. L3: 类型规范 (如 Flowchart 特定要求)
  const l3 = repo.findActive(3, renderLanguage, diagramType);

  // 组合所有层级的 prompt
  const parts: string[] = [];
  if (l1) parts.push(l1.content);
  if (l2) parts.push(l2.content);
  if (l3) parts.push(l3.content);

  if (parts.length === 0) {
    throw new Error(`未找到提示词: renderLanguage=${renderLanguage}, diagramType=${diagramType}`);
  }

  // 使用 "---" 分隔符连接
  return parts.join("\n\n---\n\n");
}
```

#### 2. 加载器逻辑（`src/lib/utils/prompt-loader.ts`）

```typescript
export async function loadPrompt(
  renderLanguage: RenderLanguage,
  diagramType: string
): Promise<PromptLoadResult> {
  const db = getDatabaseInstance();
  const promptRepo = new PromptRepository(db);

  // ===== L1: 通用提示词 =====
  let l1_content: string | null = null;
  let l1_version: string | undefined = undefined;
  let l1_id: number | undefined = undefined;

  const l1Custom = promptRepo.findActive(1);
  if (l1Custom) {
    l1_content = l1Custom.content;
    l1_version = l1Custom.version;
    l1_id = l1Custom.id;
  } else {
    // Fallback 到文件系统
    const universalPath = join(PROMPTS_DIR, "universal.txt");
    l1_content = await readFile(universalPath, "utf-8");
    l1_version = "system-default";
  }

  // ===== L2: 语言级提示词 (可选) =====
  let l2_content: string | null = null;
  let l2_version: string | undefined = undefined;
  let l2_id: number | undefined = undefined;

  const l2Custom = promptRepo.findActive(2, renderLanguage);
  if (l2Custom) {
    l2_content = l2Custom.content;
    l2_version = l2Custom.version;
    l2_id = l2Custom.id;
  } else {
    // Fallback 到文件系统 (文件可能不存在,忽略错误)
    try {
      const commonPath = join(PROMPTS_DIR, renderLanguage, "common.txt");
      l2_content = await readFile(commonPath, "utf-8");
      l2_version = "system-default";
    } catch {
      // L2 是可选的,不存在时跳过
      l2_content = null;
    }
  }

  // ===== L3: 类型级提示词 (必需) =====
  let l3_content: string | null = null;
  let l3_version: string | undefined = undefined;
  let l3_id: number | undefined = undefined;

  const l3Custom = promptRepo.findActive(3, renderLanguage, diagramType);
  if (l3Custom) {
    l3_content = l3Custom.content;
    l3_version = l3Custom.version;
    l3_id = l3Custom.id;
  } else {
    // Fallback 到文件系统
    const typePath = join(PROMPTS_DIR, renderLanguage, `${diagramType}.txt`);
    l3_content = await readFile(typePath, "utf-8");
    l3_version = "system-default";
  }

  // ===== 组合最终 Prompt =====
  const parts: string[] = [];
  if (l1_content) parts.push(l1_content);
  if (l2_content) parts.push(l2_content);
  if (l3_content) parts.push(l3_content);

  const final_prompt = parts.join("\n\n---\n\n");

  return {
    l1_content,
    l2_content,
    l3_content,
    final_prompt,
    versions: { l1_version, l2_version, l3_version },
    prompt_ids: { l1_id, l2_id, l3_id },
  };
}
```

#### 3. 数据库查询（`src/lib/repositories/PromptRepository.ts`）

```typescript
/**
 * 获取激活的提示词版本
 */
findActive(level: 1 | 2 | 3, language?: string, type?: string): CustomPrompt | null {
  const stmt = this.db.prepare(`
    SELECT * FROM custom_prompts
    WHERE prompt_level = ?
      AND (render_language = ? OR (render_language IS NULL AND ? IS NULL))
      AND (diagram_type = ? OR (diagram_type IS NULL AND ? IS NULL))
      AND is_active = 1
    LIMIT 1
  `);

  const row = stmt.get(
    level, 
    language || null, 
    language || null, 
    type || null, 
    type || null
  ) as CustomPrompt | undefined;

  return row || null;
}
```

---

## 🔄 数据流向

### 完整的生成流程

```mermaid
sequenceDiagram
    participant User as 用户
    participant API as API 路由<br/>/api/chat
    participant Service as DiagramGenerationService
    participant PromptSystem as 提示词系统
    participant DB as 数据库
    participant FS as 文件系统
    participant AI as AI 模型

    User->>API: POST 请求<br/>{userMessage, renderLanguage, diagramType}
    API->>Service: chat(params)
    
    Service->>PromptSystem: getGeneratePrompt(language, type)
    
    PromptSystem->>DB: 查询 L1 激活版本
    alt 数据库有自定义版本
        DB-->>PromptSystem: 返回自定义 L1
    else 无自定义版本
        PromptSystem->>FS: 读取 universal.txt
        FS-->>PromptSystem: 返回默认 L1
    end
    
    PromptSystem->>DB: 查询 L2 激活版本
    alt 数据库有自定义版本
        DB-->>PromptSystem: 返回自定义 L2
    else 无自定义版本
        PromptSystem->>FS: 读取 {language}/common.txt
        alt 文件存在
            FS-->>PromptSystem: 返回默认 L2
        else 文件不存在
            PromptSystem->>PromptSystem: L2 = null (可选层)
        end
    end
    
    PromptSystem->>DB: 查询 L3 激活版本
    alt 数据库有自定义版本
        DB-->>PromptSystem: 返回自定义 L3
    else 无自定义版本
        PromptSystem->>FS: 读取 {language}/{type}.txt
        FS-->>PromptSystem: 返回默认 L3
    end
    
    PromptSystem->>PromptSystem: 合并: L1 + "---" + L2 + "---" + L3
    PromptSystem-->>Service: 返回完整 Prompt
    
    Service->>Service: 构建任务标记<br/>(GENERATE/ADJUST/FIX)
    Service->>AI: generateText({<br/>  system: prompt,<br/>  messages: [{<br/>    role: "user",<br/>    content: taskHint + userMessage<br/>  }]<br/>})
    
    AI-->>Service: 生成的代码
    Service->>Service: cleanCode() 清理代码
    Service-->>API: 返回结果
    API-->>User: 返回图表代码
```

---

## 📦 版本管理机制

### 版本生命周期

```mermaid
stateDiagram-v2
    [*] --> v0_Official: 系统初始化<br/>导入官方提示词
    
    v0_Official --> v1_Custom: 用户首次编辑<br/>创建 v1
    v1_Custom --> v2_Custom: 再次编辑<br/>创建 v2
    v2_Custom --> v3_Custom: 继续编辑<br/>创建 v3
    v3_Custom --> vN_Custom: ...
    
    v1_Custom --> v0_Official: 激活 v0<br/>(回退到官方版本)
    v2_Custom --> v1_Custom: 激活 v1<br/>(回退到旧版本)
    v3_Custom --> v2_Custom: 激活 v2
    
    note right of v0_Official
        version = "v0"
        is_active = 1
        (官方版本)
    end note
    
    note right of v1_Custom
        version = "v1"
        is_active = 0/1
        (用户版本)
    end note
```

### 版本号生成规则

```typescript
/**
 * 自动版本号生成逻辑
 * 
 * 规则:
 * 1. 查询同一位置的最大版本号
 * 2. 解析版本号: "v123" -> 123
 * 3. 递增: 123 + 1 = 124
 * 4. 返回: "v124"
 */
private getNextVersion(level: 1 | 2 | 3, language?: string, type?: string): string {
  const stmt = this.db.prepare(`
    SELECT version FROM custom_prompts
    WHERE prompt_level = ?
      AND (render_language = ? OR (render_language IS NULL AND ? IS NULL))
      AND (diagram_type = ? OR (diagram_type IS NULL AND ? IS NULL))
    ORDER BY version DESC
    LIMIT 1
  `);

  const row = stmt.get(level, language || null, language || null, type || null, type || null);

  if (!row) {
    return "v1"; // 首个自定义版本
  }

  const currentVersionNum = parseInt(row.version.substring(1), 10);
  
  if (isNaN(currentVersionNum)) {
    return "v1";
  }

  return `v${currentVersionNum + 1}`;
}
```

### 版本激活机制

```typescript
/**
 * 激活指定版本
 * 
 * 功能:
 * 1. 取消同一位置所有版本的激活状态
 * 2. 激活指定版本
 * 3. 使用事务保证原子性
 */
activate(id: number): void {
  const transaction = this.db.transaction((promptId: number) => {
    const prompt = this.findById(promptId);
    if (!prompt) {
      throw new Error(`Prompt with id ${promptId} not found`);
    }

    // 1. 取消同一位置所有版本的激活状态
    const deactivateStmt = this.db.prepare(`
      UPDATE custom_prompts
      SET is_active = 0
      WHERE prompt_level = ?
        AND (render_language = ? OR (render_language IS NULL AND ? IS NULL))
        AND (diagram_type = ? OR (diagram_type IS NULL AND ? IS NULL))
        AND id != ?
    `);

    deactivateStmt.run(
      prompt.prompt_level,
      prompt.render_language,
      prompt.render_language,
      prompt.diagram_type,
      prompt.diagram_type,
      promptId
    );

    // 2. 激活指定版本
    const activateStmt = this.db.prepare(`
      UPDATE custom_prompts
      SET is_active = 1
      WHERE id = ?
    `);

    activateStmt.run(promptId);
  });

  transaction(id);
}
```

---

## 🗄️ 数据库设计

### custom_prompts 表结构

```sql
CREATE TABLE IF NOT EXISTS custom_prompts (
  -- 主键
  id INTEGER PRIMARY KEY AUTOINCREMENT,

  -- 提示词层级 (L1/L2/L3)
  prompt_level INTEGER NOT NULL CHECK(prompt_level IN (1, 2, 3)),

  -- 渲染语言 (L2/L3 必填, L1 为 NULL)
  render_language TEXT,

  -- 图表类型 (L3 必填, L1/L2 为 NULL)
  diagram_type TEXT,

  -- 版本号 (如 "v1", "v2", "v3")
  version TEXT NOT NULL,

  -- 版本名称 (可选)
  name TEXT,

  -- 版本描述 (可选)
  description TEXT,

  -- 当前激活版本标记 (0: 历史版本, 1: 当前激活版本)
  is_active INTEGER DEFAULT 0 CHECK(is_active IN (0, 1)),

  -- 提示词内容
  content TEXT NOT NULL CHECK(length(content) > 0),

  -- 审计字段
  created_by INTEGER NOT NULL,
  created_at TEXT NOT NULL DEFAULT (datetime('now')),
  updated_at TEXT NOT NULL DEFAULT (datetime('now')),

  -- 业务逻辑约束
  -- L1: render_language 和 diagram_type 必须为 NULL
  CHECK (
    (prompt_level = 1 AND render_language IS NULL AND diagram_type IS NULL)
    OR prompt_level IN (2, 3)
  ),

  -- L2: render_language 必须有值, diagram_type 必须为 NULL
  CHECK (
    (prompt_level = 2 AND render_language IS NOT NULL AND diagram_type IS NULL)
    OR prompt_level IN (1, 3)
  ),

  -- L3: render_language 和 diagram_type 必须都有值
  CHECK (
    (prompt_level = 3 AND render_language IS NOT NULL AND diagram_type IS NOT NULL)
    OR prompt_level IN (1, 2)
  )
);
```

### 数据示例

```sql
-- L1: 通用提示词
INSERT INTO custom_prompts (prompt_level, render_language, diagram_type, version, name, content, is_active, created_by)
VALUES (1, NULL, NULL, 'v0', '官方通用规范', '...', 1, 0);

-- L2: Mermaid 语言规范
INSERT INTO custom_prompts (prompt_level, render_language, diagram_type, version, name, content, is_active, created_by)
VALUES (2, 'mermaid', NULL, 'v0', 'Mermaid 官方规范', '...', 1, 0);

-- L3: Mermaid Flowchart 类型规范
INSERT INTO custom_prompts (prompt_level, render_language, diagram_type, version, name, content, is_active, created_by)
VALUES (3, 'mermaid', 'flowchart', 'v0', 'Flowchart 官方规范', '...', 1, 0);

-- 用户自定义版本
INSERT INTO custom_prompts (prompt_level, render_language, diagram_type, version, name, content, is_active, created_by)
VALUES (3, 'mermaid', 'flowchart', 'v1', '优化箭头样式', '...', 1, 1);
```

---

## 🎯 最佳实践

### 1. 提示词分层原则

**L1（通用层）**:
- ✅ 放置适用于**所有图表类型**的通用规则
- ✅ 任务识别、输出格式、AI 行为准则
- ❌ 避免放置特定语言的语法细节

**L2（语言层）**:
- ✅ 放置**某种渲染语言**的通用规则
- ✅ 保留关键字、特殊字符、注释语法
- ❌ 避免放置特定图表类型的细节

**L3（类型层）**:
- ✅ 放置**特定图表类型**的专用规则
- ✅ 节点类型、布局方式、高级特性
- ❌ 避免重复 L1/L2 已有的内容

### 2. 版本管理策略

**何时创建新版本**:
- ✅ 发现语法错误需要修正
- ✅ 需要添加新的规则或最佳实践
- ✅ 优化提示词以提高生成质量
- ❌ 避免频繁创建无意义的版本

**版本命名建议**:
```typescript
// 好的版本名称
"修正箭头语法 -> 改为 -->"
"添加子图使用规范"
"优化节点命名约定"

// 不好的版本名称
"新版本"
"更新"
"v2"
```

### 3. 合成优化

**缓存策略**:
```typescript
// 可以考虑添加缓存层
const promptCache = new Map<string, string>();

function getCachedPrompt(key: string): string | null {
  return promptCache.get(key) || null;
}

function setCachedPrompt(key: string, value: string): void {
  promptCache.set(key, value);
}
```

**性能优化**:
- 数据库查询使用索引（`prompt_level`, `render_language`, `diagram_type`, `is_active`）
- L2 可选层的处理要高效（避免不必要的文件读取）
- 使用事务保证版本激活的原子性

---

## 🚨 常见问题

### Q1: L2 层可选，何时需要 L2？

**答**: 当某种渲染语言有**跨所有图表类型**的通用规则时需要 L2。

例如:
- ✅ Mermaid: 有保留关键字、特殊字符转义等通用规则 → 需要 L2
- ❌ Excalidraw: 每种图表类型的规则差异较大 → 不需要 L2

### Q2: 为什么使用 `---` 作为分隔符？

**答**: 
1. Markdown 标准的水平分隔线，AI 模型能很好识别
2. 视觉上清晰，便于调试和阅读
3. 不会与任何图表语言的语法冲突

### Q3: 如何调试合成后的最终 Prompt？

**答**: 在开发环境中添加日志：

```typescript
if (process.env.NODE_ENV === "development") {
  console.log("=== 最终 Prompt ===");
  console.log(final_prompt);
  console.log("=== L1 ===");
  console.log(l1_content);
  console.log("=== L2 ===");
  console.log(l2_content);
  console.log("=== L3 ===");
  console.log(l3_content);
}
```

### Q4: 用户自定义版本会影响其他用户吗？

**答**: 
- ❌ **当前设计**: 全局共享模式，一个用户的修改会影响所有用户
- ✅ **如需隔离**: 可以在数据库中恢复 `user_id` 字段，实现用户级隔离

### Q5: 如何回退到官方版本？

**答**: 激活 `version = "v0"` 的提示词：

```typescript
// 1. 查找官方版本
const officialVersion = repo.findVersions(level, language, type)
  .find(v => v.version === 'v0');

// 2. 激活官方版本
if (officialVersion) {
  repo.activate(officialVersion.id);
}
```

---

## 📊 系统统计

### 提示词文件统计

| 渲染语言 | L2 (common.txt) | L3 文件数量 | 总计 |
|---------|----------------|-----------|------|
| mermaid | ✅ | 14 | 15 |
| plantuml | ✅ | 8 | 9 |
| d2 | ✅ | 7 | 8 |
| graphviz | ✅ | 4 | 5 |
| excalidraw | ✅ | 7 | 8 |
| ... | ... | ... | ... |
| **总计** | **21** | **100+** | **120+** |

### 数据流统计

**每次生成请求**:
- 数据库查询: 3 次（L1/L2/L3）
- 文件系统读取: 0-3 次（Fallback 时）
- 字符串拼接: 1 次
- AI 模型调用: 1 次

**性能数据** (估算):
- 提示词加载时间: < 10ms
- 数据库查询时间: < 5ms
- 文件读取时间: < 5ms (缓存命中率 90%+)
- 总体开销: 可忽略（相比 AI 生成时间）

---

## 🔮 未来优化方向

### 1. 提示词压缩

**问题**: L1 提示词较长（641 行），可能影响 Token 使用

**方案**:
```typescript
// 使用最小化版本
const l1_minimal = repo.findActive(1, undefined, undefined, { minimal: true });
```

### 2. 动态提示词

**问题**: 不同复杂度的需求可能需要不同详细程度的提示词

**方案**:
```typescript
// 根据用户输入复杂度选择提示词版本
function selectPromptVersion(userInput: string): 'minimal' | 'standard' | 'detailed' {
  const complexity = analyzeComplexity(userInput);
  if (complexity < 0.3) return 'minimal';
  if (complexity < 0.7) return 'standard';
  return 'detailed';
}
```

### 3. A/B 测试支持

**目标**: 对比不同提示词版本的效果

**方案**:
```typescript
// 添加实验标记
interface CustomPrompt {
  // ... 现有字段
  experiment_group?: string; // 'A' | 'B' | 'control'
  success_rate?: number;    // 基于用户反馈计算
}
```

### 4. 自动优化

**目标**: 基于失败日志自动改进提示词

**方案**:
```typescript
// 分析失败模式
function analyzeFailurePatterns(logs: RenderFailureLog[]): PromptImprovement[] {
  // 1. 提取常见错误类型
  // 2. 识别提示词不足的部分
  // 3. 生成改进建议
  return improvements;
}
```

---

## 📝 总结

DiagramAI 的三级提示词系统是一个**模块化、可扩展、版本可控**的 AI 提示词管理方案：

### 核心优势

✅ **模块化设计**: L1/L2/L3 各司其职，易于维护  
✅ **灵活组合**: 支持 100+ 种图表类型的精确控制  
✅ **版本管理**: 完整的版本历史，可随时回退  
✅ **Fallback 机制**: 数据库优先，文件系统兜底，保证可用性  
✅ **性能优化**: 数据库索引 + 文件缓存，响应迅速  

### 关键数据

- **3** 个层级（L1/L2/L3）
- **23** 种渲染语言
- **100+** 种图表类型组合
- **120+** 个提示词文件
- **<10ms** 提示词加载时间

### 核心公式

```
最终 Prompt = L1 (通用) + "---" + L2 (语言) + "---" + L3 (类型)
              ↓                    ↓                    ↓
         universal.txt    {language}/common.txt  {language}/{type}.txt
              ↓                    ↓                    ↓
         (数据库优先)          (可选层)           (必需层)
```

---

**文档版本**: 1.0  
**最后更新**: 2025-10-18  
**维护者**: DiagramAI Team

