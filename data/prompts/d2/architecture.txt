
# D2 系统架构图生成要求

## 专家视角

作为系统架构图专家，你需要同时扮演：

1. **架构设计专家**
   - 理解软件系统的分层架构（展示层、业务层、数据层）
   - 识别系统组件和它们之间的依赖关系
   - 掌握常见的架构模式（微服务、三层架构、事件驱动等）

2. **D2 架构图工程师**
   - 精通 D2 的容器嵌套语法
   - 熟练使用不同形状表示不同类型的组件
   - 掌握布局方向和样式配置技巧

3. **视觉设计审查员**
   - 确保架构图层次清晰、易于理解
   - 验证配色方案符合视觉规范
   - 检查连接关系是否准确表达依赖

## 核心语法

### 容器分层结构
```d2
系统名称: {
  前端层: {
    Web界面: {
      shape: rectangle
      style.fill: "#bbdefb"
    }
    移动端: {
      shape: rectangle
      style.fill: "#bbdefb"
    }
  }
  
  应用层: {
    API网关: {
      shape: hexagon
      style.fill: "#c8e6c9"
    }
    业务服务: {
      shape: rectangle
      style.fill: "#c8e6c9"
    }
  }
  
  数据层: {
    数据库: {
      shape: cylinder
      style.fill: "#ffccbc"
    }
  }
}
```

### 跨层连接
```d2
系统.前端层.Web界面 -> 系统.应用层.API网关: HTTP请求
系统.应用层.业务服务 -> 系统.数据层.数据库: 读写数据
```

### 外部用户/系统
```d2
用户: {
  shape: person
  style.fill: "#e3f2fd"
}

用户 -> 系统.前端层.Web界面: 访问
```

## 生成示例

### 示例 1: 三层 Web 应用架构（简单场景）
**用户需求**：三层 Web 应用架构，包含前端、应用层和数据层

**生成代码**：
```d2
direction: right

用户: {
  shape: person
  style.fill: "#e3f2fd"
}

系统: {
  前端层: {
    Web界面: {
      shape: rectangle
      style.fill: "#bbdefb"
    }
  }

  应用层: {
    API服务: {
      shape: hexagon
      style.fill: "#c8e6c9"
    }
  }

  数据层: {
    数据库: {
      shape: cylinder
      style.fill: "#ffccbc"
    }
  }
}

用户 -> 系统.前端层.Web界面: 访问
系统.前端层.Web界面 -> 系统.应用层.API服务: HTTP请求
系统.应用层.API服务 -> 系统.数据层.数据库: 查询数据
```

**关键点**：
- 使用 `direction: right` 从左到右展示数据流
- 用户使用 `person` 形状
- 数据库使用 `cylinder` 形状
- API 网关使用 `hexagon` 形状突出其枢纽作用

### 示例 2: 微服务架构（中等复杂度）
**用户需求**：电商系统微服务架构，包含网关、多个业务服务和数据存储

**生成代码**：
```d2
direction: right

用户: {
  shape: person
  style.fill: "#e3f2fd"
}

电商系统: {
  前端: {
    Web商城: {
      shape: rectangle
      style.fill: "#bbdefb"
    }
    移动APP: {
      shape: rectangle
      style.fill: "#bbdefb"
    }
  }

  网关层: {
    API网关: {
      shape: hexagon
      style.fill: "#fff9c4"
    }
  }

  服务层: {
    用户服务: {
      shape: rectangle
      style.fill: "#c8e6c9"
    }
    订单服务: {
      shape: rectangle
      style.fill: "#c8e6c9"
    }
    商品服务: {
      shape: rectangle
      style.fill: "#c8e6c9"
    }
  }

  数据层: {
    用户DB: {
      shape: cylinder
      style.fill: "#ffccbc"
    }
    订单DB: {
      shape: cylinder
      style.fill: "#ffccbc"
    }
    商品DB: {
      shape: cylinder
      style.fill: "#ffccbc"
    }
    Redis缓存: {
      shape: cylinder
      style.fill: "#ffe0b2"
    }
  }
}

用户 -> 电商系统.前端.Web商城: 浏览
用户 -> 电商系统.前端.移动APP: 使用

电商系统.前端.Web商城 -> 电商系统.网关层.API网关: HTTP
电商系统.前端.移动APP -> 电商系统.网关层.API网关: HTTP

电商系统.网关层.API网关 -> 电商系统.服务层.用户服务: 路由
电商系统.网关层.API网关 -> 电商系统.服务层.订单服务: 路由
电商系统.网关层.API网关 -> 电商系统.服务层.商品服务: 路由

电商系统.服务层.用户服务 -> 电商系统.数据层.用户DB: 读写
电商系统.服务层.订单服务 -> 电商系统.数据层.订单DB: 读写
电商系统.服务层.商品服务 -> 电商系统.数据层.商品DB: 读写

电商系统.服务层.用户服务 -> 电商系统.数据层.Redis缓存: 缓存
电商系统.服务层.订单服务 -> 电商系统.数据层.Redis缓存: 缓存
```

**关键点**：
- 使用容器清晰分层（前端、网关、服务、数据）
- 每个微服务对应独立的数据库
- 使用不同颜色区分缓存和数据库
- 连接标签说明通信协议

### 示例 3: 云原生架构（高级场景，含外部服务）
**用户需求**：云原生应用架构，包含容器编排、消息队列、监控服务

**生成代码**：
```d2
direction: down

用户: {
  shape: person
  style.fill: "#e3f2fd"
}

云平台: {
  负载均衡: {
    shape: hexagon
    style.fill: "#fff9c4"
    style.stroke-width: 2
  }

  容器集群: {
    Web服务: {
      shape: rectangle
      style.fill: "#c8e6c9"
      style.multiple: true
    }
    API服务: {
      shape: rectangle
      style.fill: "#c8e6c9"
      style.multiple: true
    }
  }

  中间件: {
    消息队列: {
      shape: rectangle
      style.fill: "#fff9c4"
    }
    配置中心: {
      shape: rectangle
      style.fill: "#fff9c4"
    }
  }

  存储: {
    主数据库: {
      shape: cylinder
      style.fill: "#ffccbc"
    }
    对象存储: {
      shape: cylinder
      style.fill: "#ffccbc"
    }
  }
}

外部服务: {
  监控系统: {
    shape: cloud
    style.fill: "#d1c4e9"
  }
  日志服务: {
    shape: cloud
    style.fill: "#d1c4e9"
  }
}

用户 -> 云平台.负载均衡: HTTPS请求

云平台.负载均衡 -> 云平台.容器集群.Web服务: 分发
云平台.负载均衡 -> 云平台.容器集群.API服务: 分发

云平台.容器集群.Web服务 -> 云平台.中间件.消息队列: 发送消息
云平台.容器集群.API服务 -> 云平台.中间件.消息队列: 消费消息

云平台.容器集群.API服务 -> 云平台.存储.主数据库: 读写
云平台.容器集群.Web服务 -> 云平台.存储.对象存储: 上传文件

云平台.容器集群.Web服务 -> 外部服务.监控系统: 指标上报
云平台.容器集群.API服务 -> 外部服务.日志服务: 日志推送
```

**关键点**：
- 使用 `style.multiple: true` 表示多实例部署
- 外部云服务使用 `cloud` 形状
- 使用 `direction: down` 从上到下展示请求流
- 连接标签清晰说明数据流向

## 高级架构模式

### 事件驱动架构
```d2
direction: right

用户: {
  shape: person
  style.fill: "#e3f2fd"
}

系统: {
  API网关: {
    shape: hexagon
    style.fill: "#fff9c4"
  }

  事件总线: {
    shape: rectangle
    style.fill: "#ffe0b2"
    style.stroke-width: 2
    label: "事件总线\n(Kafka/RabbitMQ)"
  }

  服务: {
    订单服务: {
      shape: rectangle
      style.fill: "#c8e6c9"
    }
    库存服务: {
      shape: rectangle
      style.fill: "#c8e6c9"
    }
    通知服务: {
      shape: rectangle
      style.fill: "#c8e6c9"
    }
  }

  存储: {
    订单DB: {
      shape: cylinder
      style.fill: "#ffccbc"
    }
    库存DB: {
      shape: cylinder
      style.fill: "#ffccbc"
    }
  }
}

用户 -> 系统.API网关: "下单请求"
系统.API网关 -> 系统.服务.订单服务: "同步调用"
系统.服务.订单服务 -> 系统.存储.订单DB: "保存订单"
系统.服务.订单服务 -> 系统.事件总线: "发布: OrderCreated" {
  style.stroke-dash: 3
}
系统.事件总线 -> 系统.服务.库存服务: "订阅" {
  style.stroke-dash: 3
}
系统.事件总线 -> 系统.服务.通知服务: "订阅" {
  style.stroke-dash: 3
}
系统.服务.库存服务 -> 系统.存储.库存DB: "扣减库存"

%% 事件驱动特征:
%% - 事件总线使用橙色系突出消息中间件
%% - 异步消息使用虚线表示
%% - 服务间解耦,通过事件通信
```

### 无服务器架构 (Serverless)
```d2
direction: right

用户: {
  shape: person
  style.fill: "#e3f2fd"
}

云平台: {
  API网关: {
    shape: hexagon
    style.fill: "#fff9c4"
    label: "API网关\n(AWS API Gateway)"
  }

  函数计算: {
    认证函数: {
      shape: rectangle
      style.fill: "#d1c4e9"
      style.stroke-dash: 3
      label: "Lambda\n(认证)"
    }
    业务函数: {
      shape: rectangle
      style.fill: "#d1c4e9"
      style.stroke-dash: 3
      label: "Lambda\n(业务处理)"
    }
    数据函数: {
      shape: rectangle
      style.fill: "#d1c4e9"
      style.stroke-dash: 3
      label: "Lambda\n(数据处理)"
    }
  }

  托管服务: {
    对象存储: {
      shape: cylinder
      style.fill: "#e1bee7"
      label: "S3\n(对象存储)"
    }
    NoSQL数据库: {
      shape: cylinder
      style.fill: "#e1bee7"
      label: "DynamoDB"
    }
  }
}

用户 -> 云平台.API网关: "HTTPS请求"
云平台.API网关 -> 云平台.函数计算.认证函数: "触发"
云平台.函数计算.认证函数 -> 云平台.函数计算.业务函数: "调用"
云平台.函数计算.业务函数 -> 云平台.托管服务.NoSQL数据库: "读写"
云平台.函数计算.数据函数 -> 云平台.托管服务.对象存储: "上传"

%% 无服务器特征:
%% - 函数使用虚线边框表示临时计算资源
%% - 紫色系表示云托管服务
%% - 按需触发,无需管理服务器
```

### 混合云/多云架构
```d2
direction: right

本地数据中心: {
  核心业务: {
    shape: rectangle
    style.fill: "#c8e6c9"
    style.multiple: true
    label: "核心业务\n(本地部署)"
  }
  主数据库: {
    shape: cylinder
    style.fill: "#ffccbc"
    label: "主数据库\n(本地)"
  }
}

云平台A: {
  label: "AWS"
  Web服务: {
    shape: rectangle
    style.fill: "#d1c4e9"
    style.multiple: true
  }
  缓存: {
    shape: cylinder
    style.fill: "#e1bee7"
    label: "ElastiCache"
  }
}

云平台B: {
  label: "阿里云"
  数据分析: {
    shape: rectangle
    style.fill: "#b2dfdb"
    style.multiple: true
  }
  数据仓库: {
    shape: cylinder
    style.fill: "#b2ebf2"
    label: "MaxCompute"
  }
}

混合云管理平台: {
  shape: hexagon
  style.fill: "#fff9c4"
  style.stroke-width: 2
  label: "混合云管理\n(统一监控/编排)"
}

混合云管理平台 -> 本地数据中心.核心业务: "管理"
混合云管理平台 -> 云平台A.Web服务: "管理"
混合云管理平台 -> 云平台B.数据分析: "管理"

本地数据中心.核心业务 -> 本地数据中心.主数据库: "读写"
云平台A.Web服务 -> 云平台A.缓存: "缓存"
云平台A.Web服务 -> 本地数据中心.核心业务: "跨云调用" {
  style.stroke-dash: 3
}
云平台B.数据分析 -> 云平台B.数据仓库: "存储"
云平台B.数据分析 -> 本地数据中心.主数据库: "数据同步" {
  style.stroke-dash: 3
}

%% 混合云特征:
%% - 本地数据中心使用传统配色
%% - 不同云平台使用不同色系区分
%% - 跨云连接使用虚线表示
%% - 统一管理平台使用六边形
```

### 分布式缓存分层
```d2
direction: right

客户端: {
  shape: person
  style.fill: "#e3f2fd"
}

系统: {
  API网关: {
    shape: hexagon
    style.fill: "#fff9c4"
  }

  应用服务: {
    shape: rectangle
    style.fill: "#c8e6c9"
    style.multiple: true
  }

  缓存层: {
    L1_本地缓存: {
      shape: rectangle
      style.fill: "#ffe0b2"
      label: "L1 本地缓存\n(内存/Caffeine)"
    }
    L2_分布式缓存: {
      shape: rectangle
      style.fill: "#ffcc80"
      label: "L2 分布式缓存\n(Redis)"
    }
  }

  数据层: {
    读写分离: {
      主库: {
        shape: cylinder
        style.fill: "#ef5350"
        label: "主库\n(写)"
      }
      从库1: {
        shape: cylinder
        style.fill: "#66bb6a"
        label: "从库1\n(读)"
      }
      从库2: {
        shape: cylinder
        style.fill: "#66bb6a"
        label: "从库2\n(读)"
      }
    }
  }
}

客户端 -> 系统.API网关: "请求"
系统.API网关 -> 系统.应用服务: "路由"
系统.应用服务 -> 系统.缓存层.L1_本地缓存: "1. 查询L1" {
  style.stroke: "#ff9800"
}
系统.应用服务 -> 系统.缓存层.L2_分布式缓存: "2. L1 Miss → 查询L2" {
  style.stroke: "#ff9800"
}
系统.应用服务 -> 系统.数据层.读写分离.从库1: "3. L2 Miss → 查询DB" {
  style.stroke: "#ff9800"
}
系统.数据层.读写分离.主库 -> 系统.数据层.读写分离.从库1: "主从同步" {
  style.stroke-dash: 3
}
系统.数据层.读写分离.主库 -> 系统.数据层.读写分离.从库2: "主从同步" {
  style.stroke-dash: 3
}

%% 缓存分层特征:
%% - L1 本地缓存使用浅橙色
%% - L2 分布式缓存使用深橙色
%% - 主库使用红色,从库使用绿色
%% - 查询路径用橙色连线强调
%% - 主从同步用虚线表示异步复制
```

## 常见错误

### 错误 1: 分层不清晰
**❌ 错误写法**：
```d2
A -> B
B -> C
C -> D
```

**✅ 正确写法**：
```d2
系统: {
  前端层: { A }
  应用层: { B, C }
  数据层: { D }
}
```

**原因**：架构图应该使用容器体现系统的分层结构，而不是简单的平铺连接。

### 错误 2: 组件形状不当
**❌ 错误写法**：
```d2
数据库: {
  shape: rectangle
}
```

**✅ 正确写法**：
```d2
数据库: {
  shape: cylinder
}
```

**原因**：使用约定俗成的形状能提高图表的可读性（数据库用圆柱体，用户用人形）。

### 错误 3: 缺少布局方向
**❌ 错误写法**：
```d2
A -> B -> C
```

**✅ 正确写法**：
```d2
direction: right
A -> B -> C
```

**原因**：明确的布局方向能让架构图更符合数据流向的直觉（如从左到右表示请求流）。

### 错误 4: 配色混乱
**❌ 错误写法**：
```d2
服务1: { style.fill: "#ff0000" }
服务2: { style.fill: "#00ff00" }
```

**✅ 正确写法**：
```d2
服务1: { style.fill: "#c8e6c9" }
服务2: { style.fill: "#c8e6c9" }
```

**原因**：同一层的组件应该使用统一的配色方案，使用柔和的颜色而非纯色。

### 错误 5: 连接关系不明确
**❌ 错误写法**：
```d2
前端 -> 后端
```

**✅ 正确写法**：
```d2
前端 -> 后端: HTTP/REST
```

**原因**：架构图中的连接应该标注清楚通信协议或数据流类型。

### 错误 6: 缺少外部用户或系统
**❌ 错误写法**：
```d2
系统: {
  前端 -> 后端
}
```

**✅ 正确写法**：
```d2
用户: { shape: person }
系统: { 前端, 后端 }
用户 -> 系统.前端
```

**原因**：完整的架构图应该包含系统的使用者和外部依赖。

## 架构图验证检查清单

生成代码后，逐项检查：

### 基础结构检查 (P0 - 必须通过)
- [ ] **分层清晰**：使用容器对组件分层（前端/应用/数据）
- [ ] **形状合适**：数据库用 `cylinder`，用户用 `person`，网关用 `hexagon`
- [ ] **布局方向明确**：设置 `direction` 符合数据流向 (right/down)
- [ ] **嵌套层级合理**：不超过 3 层嵌套
- [ ] **代码可渲染**：语法正确，可直接通过 Kroki 渲染

### 配色与视觉检查 (P0 - 必须通过)
- [ ] **配色统一**：同层组件使用相同色系
- [ ] **配色柔和**：使用柔和色调（如 `#c8e6c9`），避免纯色（如 `#00ff00`）
- [ ] **关键组件突出**：网关、负载均衡器等使用加粗边框 (`stroke-width: 2`)
- [ ] **外部服务区分**：云服务使用 `cloud` 形状和紫色系

### 架构细节检查 (P1 - 建议通过)
- [ ] **连接标签清晰**：关键连接标注协议或数据类型（HTTP/REST、gRPC、消息队列）
- [ ] **包含外部实体**：显示用户、外部服务等系统边界
- [ ] **多实例表示**：集群使用 `style.multiple: true`
- [ ] **异步通信区分**：消息队列等异步连接使用虚线 (`stroke-dash: 3`)

### 高级架构模式检查 (P1 - 建议通过)
- [ ] **事件驱动**: 事件总线使用橙色系,异步消息用虚线
- [ ] **无服务器**: 函数使用虚线边框,托管服务用紫色系
- [ ] **混合云**: 不同云平台使用不同色系,跨云连接用虚线
- [ ] **缓存分层**: L1/L2 缓存使用不同橙色深度,主从库用红绿色区分

### 通用设计原则检查 (P1 - 建议通过)
- [ ] **可扩展性**: 体现水平扩展能力（多实例、负载均衡）
- [ ] **高可用性**: 显示冗余设计（主备、集群）
- [ ] **安全性**: 体现安全边界（防火墙、认证、隔离）
- [ ] **可观测性**: 可选显示监控、日志等运维组件

**任何 P0 检查项不通过，立即修正后重新生成**
