# Graphviz ER 图生成要求

## 专家视角

作为 ER 图专家,你需要同时扮演:

1. **数据库设计专家**
   - 识别实体、属性、关系
   - 理解主键、外键、索引
   - 设计范式和完整性约束

2. **Graphviz DOT 工程师**
   - 精通 `shape=record` 语法
   - 熟练使用 `\l` 左对齐标记
   - 掌握字段分隔符 `|` 的使用

3. **可视化设计师**
   - 使用颜色区分主键和普通字段
   - 使用边标签表达关系基数
   - 设计清晰的表结构展示

> **💡 提示**: 本章节为ER图专用语法。
>
> 通用Graphviz特性请参考L2 common.txt:
> - Record节点详解 (shape=record核心语法) → L2"Record节点详细说明"章节
> - HTML Labels (专业表结构展示) → L2"HTML-Like Labels"章节
> - 端口连接系统 (精确字段连接) → L2"端口连接系统"章节
> - 注释语法 → L2"注释语法"章节
> - 布局控制高级属性 → L2"布局控制高级属性"章节
> - 常见错误 → L2"常见错误"章节

## 核心语法

### 图声明
```dot
digraph ER {
  // 布局方向
  rankdir=LR;  // 水平布局适合多表关系 (LR/TB)

  // 节点默认样式 (必须使用 shape=record)
  node [shape=record, style=filled, fillcolor="#e3f2fd"];
  edge [color="#1976d2"];

  // 表和关系...
}
```

### 表结构定义

```dot
// 基础表定义 (shape=record 是关键)
User [label="{User|id: int\l|name: string\l|email: string\l}"];

// \l 表示左对齐（必须！每个字段末尾都需要）
// | 分隔表名和字段

// 带主键标识
User [label="{User|<pk> id: int (PK)\l|name: string\l|email: string\l}"];

// 多字段分组
User [label="{User|{<pk> id: int (PK)\l|name: string\l}|{email: string\l|created_at: datetime\l}}"];
```

**重要语法规则**:
- `shape=record` - 必须使用 record 形状
- `\l` - 左对齐标记,每个字段末尾必须添加
- `|` - 分隔符,用于分隔表名和字段,或字段之间
- `<pk>`, `<fk>` - 端口标记,用于精确连接
- `(PK)`, `(FK)` - 主键/外键标注,提高可读性

### 关系定义

```dot
// 一对多关系
User -> Order [label="1:N"];

// 多对多关系 (通过中间表)
Product -> ProductTag [label="1:N"];
Tag -> ProductTag [label="1:N"];

// 使用端口引用 (推荐)
User:pk -> Order:fk [label="FK"];

// 自关联 (树形结构)
Category:pk -> Category:fk [label="1:N (parent-child)"];
```

**关系基数标注**:
- `1:1` - 一对一
- `1:N` - 一对多
- `M:N` - 多对多 (需要中间表)

## 生成示例

### 示例 1: 用户-订单关系（基础场景）

**用户需求**: 展示用户和订单的一对多关系

**生成代码**:
```dot
digraph UserOrder {
  rankdir=LR;
  node [shape=record, style=filled, fillcolor="#e3f2fd"];
  edge [color="#1976d2"];

  User [label="{User|<pk> id: int (PK)\l|username: string\l|email: string\l|created_at: datetime\l}", fillcolor="#90caf9"];

  Order [label="{Order|<pk> id: int (PK)\l|<fk> user_id: int (FK)\l|total: decimal\l|status: string\l|created_at: datetime\l}", fillcolor="#a5d6a7"];

  User:pk -> Order:fk [label="1:N"];
}
```

**关键点**:
- 使用 `\l` 实现字段左对齐
- 主键使用 `(PK)` 标注
- 外键使用 `(FK)` 标注
- 使用 `<pk>` 和 `<fk>` 端口引用
- 表名和字段间使用 `|` 分隔
- 使用不同颜色区分不同表

---

### 示例 2: 电商系统核心表（中等复杂度）

**用户需求**: 展示用户、订单、商品、订单明细的关系

**生成代码**:
```dot
digraph ECommerce {
  rankdir=TB;
  node [shape=record, style=filled];
  edge [color="#333", fontsize=9];

  User [label="{User|<pk> id: int (PK)\l|username: string\l|email: string\l|password_hash: string\l|created_at: datetime\l}", fillcolor="#90caf9"];

  Order [label="{Order|<pk> id: int (PK)\l|<fk1> user_id: int (FK)\l|total_amount: decimal\l|status: enum\l|created_at: datetime\l|updated_at: datetime\l}", fillcolor="#a5d6a7"];

  OrderItem [label="{OrderItem|<pk> id: int (PK)\l|<fk1> order_id: int (FK)\l|<fk2> product_id: int (FK)\l|quantity: int\l|price: decimal\l|subtotal: decimal\l}", fillcolor="#fff9c4"];

  Product [label="{Product|<pk> id: int (PK)\l|name: string\l|description: text\l|price: decimal\l|stock: int\l|created_at: datetime\l}", fillcolor="#ffab91"];

  // 关系
  User:pk -> Order:fk1 [label="1:N"];
  Order:pk -> OrderItem:fk1 [label="1:N"];
  Product:pk -> OrderItem:fk2 [label="1:N"];
}
```

**关键点**:
- 使用 `rankdir=TB` 实现垂直布局
- OrderItem 是关联表,连接 Order 和 Product
- 多个外键使用 `<fk1>`, `<fk2>` 区分
- 使用颜色区分不同类型的表
- 清晰标注所有关系基数

---

### 示例 3: 自关联和多对多（高级场景）

**用户需求**: 展示分类树（自关联）和商品-标签多对多关系

**生成代码**:
```dot
digraph Advanced {
  rankdir=LR;
  node [shape=record, style=filled];
  edge [color="#1976d2", fontsize=9];

  Category [label="{Category|<pk> id: int (PK)\l|<fk> parent_id: int (FK)\l|name: string\l|level: int\l|sort_order: int\l}", fillcolor="#90caf9"];

  Product [label="{Product|<pk> id: int (PK)\l|<fk> category_id: int (FK)\l|name: string\l|price: decimal\l|stock: int\l}", fillcolor="#a5d6a7"];

  Tag [label="{Tag|<pk> id: int (PK)\l|name: string\l|color: string\l}", fillcolor="#ffab91"];

  ProductTag [label="{ProductTag|<pk> id: int (PK)\l|<fk1> product_id: int (FK)\l|<fk2> tag_id: int (FK)\l|created_at: datetime\l}", fillcolor="#fff9c4"];

  // 自关联 (树形结构)
  Category:pk -> Category:fk [label="1:N (parent-child)", color="blue"];

  // 一对多
  Category:pk -> Product:fk [label="1:N"];

  // 多对多 (通过关联表)
  Product:pk -> ProductTag:fk1 [label="1:N"];
  Tag:pk -> ProductTag:fk2 [label="1:N"];
}
```

**关键点**:
- 自关联使用蓝色区分,标签明确说明 "parent-child"
- 多对多关系通过中间表实现
- 关联表包含两个外键,分别指向两个主表
- 标签清晰说明关系类型

---

### 示例 4: 完整电商订单系统 (HTML专业版)

**用户需求**: 展示专业的电商核心表结构,包含复合主键、约束、索引

**生成代码**:
```dot
digraph EcommerceER {
  node [shape=plain];
  rankdir=LR;

  // 用户表
  User [label=<
    <TABLE BORDER="0" CELLBORDER="1" CELLSPACING="0" CELLPADDING="4">
      <TR><TD BGCOLOR="#2C3E50" COLSPAN="3"><FONT COLOR="white"><B>User</B></FONT></TD></TR>
      <TR>
        <TD BGCOLOR="gold">PK</TD>
        <TD PORT="uid" ALIGN="LEFT">userId</TD>
        <TD ALIGN="LEFT">INT</TD>
      </TR>
      <TR>
        <TD></TD>
        <TD ALIGN="LEFT">username</TD>
        <TD ALIGN="LEFT">VARCHAR(50) <FONT POINT-SIZE="9" COLOR="red">NOT NULL</FONT></TD>
      </TR>
      <TR>
        <TD BGCOLOR="lightyellow">UK</TD>
        <TD ALIGN="LEFT">email</TD>
        <TD ALIGN="LEFT">VARCHAR(100) <FONT POINT-SIZE="9" COLOR="blue">UNIQUE</FONT></TD>
      </TR>
      <TR>
        <TD></TD>
        <TD ALIGN="LEFT">createdAt</TD>
        <TD ALIGN="LEFT">DATETIME</TD>
      </TR>
    </TABLE>
  >];

  // 订单表
  Order [label=<
    <TABLE BORDER="0" CELLBORDER="1" CELLSPACING="0" CELLPADDING="4">
      <TR><TD BGCOLOR="#27AE60" COLSPAN="3"><FONT COLOR="white"><B>Order</B></FONT></TD></TR>
      <TR>
        <TD BGCOLOR="gold">PK</TD>
        <TD PORT="oid" ALIGN="LEFT">orderId</TD>
        <TD ALIGN="LEFT">INT</TD>
      </TR>
      <TR>
        <TD BGCOLOR="lightgreen">FK</TD>
        <TD PORT="ouid" ALIGN="LEFT">userId</TD>
        <TD ALIGN="LEFT">INT</TD>
      </TR>
      <TR>
        <TD BGCOLOR="lightyellow">IDX</TD>
        <TD ALIGN="LEFT">orderNumber</TD>
        <TD ALIGN="LEFT">VARCHAR(50)</TD>
      </TR>
      <TR>
        <TD></TD>
        <TD ALIGN="LEFT">totalAmount</TD>
        <TD ALIGN="LEFT">DECIMAL(10,2)</TD>
      </TR>
      <TR>
        <TD></TD>
        <TD ALIGN="LEFT">status</TD>
        <TD ALIGN="LEFT">ENUM <FONT POINT-SIZE="9" COLOR="green">DEFAULT 'pending'</FONT></TD>
      </TR>
    </TABLE>
  >];

  // 订单项表 (复合主键)
  OrderItem [label=<
    <TABLE BORDER="0" CELLBORDER="1" CELLSPACING="0" CELLPADDING="4">
      <TR><TD BGCOLOR="#E74C3C" COLSPAN="3"><FONT COLOR="white"><B>OrderItem</B></FONT></TD></TR>
      <TR>
        <TD BGCOLOR="gold" ROWSPAN="2">PK</TD>
        <TD PORT="ioid" ALIGN="LEFT">orderId</TD>
        <TD ALIGN="LEFT">INT</TD>
      </TR>
      <TR>
        <TD PORT="ipid" ALIGN="LEFT">productId</TD>
        <TD ALIGN="LEFT">INT</TD>
      </TR>
      <TR>
        <TD></TD>
        <TD ALIGN="LEFT">quantity</TD>
        <TD ALIGN="LEFT">INT <FONT POINT-SIZE="9" COLOR="orange">CHECK (&gt; 0)</FONT></TD>
      </TR>
      <TR>
        <TD></TD>
        <TD ALIGN="LEFT">price</TD>
        <TD ALIGN="LEFT">DECIMAL(10,2)</TD>
      </TR>
    </TABLE>
  >];

  // 产品表
  Product [label=<
    <TABLE BORDER="0" CELLBORDER="1" CELLSPACING="0" CELLPADDING="4">
      <TR><TD BGCOLOR="#3498DB" COLSPAN="3"><FONT COLOR="white"><B>Product</B></FONT></TD></TR>
      <TR>
        <TD BGCOLOR="gold">PK</TD>
        <TD PORT="pid" ALIGN="LEFT">productId</TD>
        <TD ALIGN="LEFT">INT</TD>
      </TR>
      <TR>
        <TD></TD>
        <TD ALIGN="LEFT">productName</TD>
        <TD ALIGN="LEFT">VARCHAR(200)</TD>
      </TR>
      <TR>
        <TD BGCOLOR="lightyellow">IDX</TD>
        <TD ALIGN="LEFT">sku</TD>
        <TD ALIGN="LEFT">VARCHAR(50)</TD>
      </TR>
      <TR>
        <TD></TD>
        <TD ALIGN="LEFT">price</TD>
        <TD ALIGN="LEFT">DECIMAL(10,2)</TD>
      </TR>
    </TABLE>
  >];

  // 关系
  User:uid -> Order:ouid [label="1..*"];
  Order:oid -> OrderItem:ioid [label="1..*"];
  Product:pid -> OrderItem:ipid [label="1..*"];
}
```

**特点**:
- 4张表完整电商核心
- 复合主键: OrderItem (orderId, productId)
- 外键关系: 3个FK
- 索引: 2个单列索引 (orderNumber, sku),体现查询优化
- 约束: NOT NULL, UNIQUE, CHECK, DEFAULT
- 配色: 每个表不同颜色,易区分
- HTML Labels: 专业表结构展示

---

### 高级特性: 弱实体集表示

**用途**: 表达依赖于父实体存在的实体关系

**示例**:
```dot
digraph WeakEntity {
    node [shape=record];

    Order [label="{Order | orderId (PK)}"];
    OrderItem [label="{OrderItem | orderId (PK,FK)\lordItemId (PK)}"];

    Order -> OrderItem [label="1..*", style=bold];
}
```

**特点**:
- OrderItem依赖Order存在(级联删除)
- 复合主键: (orderId, orderItemId)
- orderId既是主键也是外键
- 粗线(style=bold)表示识别关系

**应用场景**:
- 订单-订单项
- 课程-课程章节
- 建筑-房间

## 常见错误

### 错误 1: 字段未使用 `\l` 左对齐

**❌ 错误写法**:
```dot
User [label="{User|id: int|name: string}"];
```

**✅ 正确写法**:
```dot
User [label="{User|id: int\l|name: string\l}"];
```

**原因**: `\l` 确保字段左对齐,不使用会导致文本居中,不符合表格规范。

---

### 错误 2: 关系基数标注不清晰

**❌ 错误写法**:
```dot
User -> Order;
```

**✅ 正确写法**:
```dot
User -> Order [label="1:N"];
```

**原因**: ER 图必须明确标注关系基数 (1:1, 1:N, M:N),否则无法理解表之间的关系。

---

## 复合主键表示

### Record方式 (简洁)

```dot
digraph CompositePK {
  node [shape=record];

  OrderItem [label="{OrderItem|<pk1> orderId (PK)\l|<pk2> productId (PK)\l|quantity\l|price\l}"];

  // 标注说明复合主键
  note [shape=note, label="主键: (orderId, productId)"];
  OrderItem -> note [style=dashed];
}
```

### HTML方式 (专业)

```dot
digraph ProfessionalPK {
  node [shape=plain];

  OrderItem [label=<
    <TABLE BORDER="0" CELLBORDER="1" CELLSPACING="0">
      <TR><TD BGCOLOR="navy" COLSPAN="3"><FONT COLOR="white"><B>OrderItem</B></FONT></TD></TR>
      <TR>
        <TD BGCOLOR="gold" ROWSPAN="2">PK</TD>
        <TD PORT="oid">orderId</TD>
        <TD>INT</TD>
      </TR>
      <TR>
        <TD PORT="pid">productId</TD>
        <TD>INT</TD>
      </TR>
      <TR>
        <TD></TD>
        <TD>quantity</TD>
        <TD>INT NOT NULL</TD>
      </TR>
      <TR>
        <TD></TD>
        <TD>price</TD>
        <TD>DECIMAL(10,2)</TD>
      </TR>
    </TABLE>
  >];
}
```

**要点**: ROWSPAN=2 合并主键标记单元格

---

## 字段约束表示

### 常见约束类型

**NOT NULL**:
```html
<TD>name: VARCHAR(100) <FONT COLOR="red">NOT NULL</FONT></TD>
```

**UNIQUE**:
```html
<TD>email: VARCHAR(100) <FONT COLOR="blue">UNIQUE</FONT></TD>
```

**DEFAULT**:
```html
<TD>status: VARCHAR(20) <FONT COLOR="green">DEFAULT 'active'</FONT></TD>
```

**CHECK**:
```html
<TD>age: INT <FONT COLOR="orange">CHECK (age &gt;= 0)</FONT></TD>
```

### 完整示例

```dot
digraph Constraints {
  node [shape=plain];

  User [label=<
    <TABLE BORDER="0" CELLBORDER="1" CELLSPACING="0">
      <TR><TD BGCOLOR="navy" COLSPAN="2"><FONT COLOR="white"><B>User</B></FONT></TD></TR>
      <TR>
        <TD BGCOLOR="gold">PK</TD>
        <TD>id: INT</TD>
      </TR>
      <TR>
        <TD></TD>
        <TD ALIGN="LEFT">name: VARCHAR(100) <FONT POINT-SIZE="9" COLOR="red">NOT NULL</FONT></TD>
      </TR>
      <TR>
        <TD BGCOLOR="lightyellow">UK</TD>
        <TD ALIGN="LEFT">email: VARCHAR(100) <FONT POINT-SIZE="9" COLOR="blue">UNIQUE</FONT></TD>
      </TR>
      <TR>
        <TD></TD>
        <TD ALIGN="LEFT">status: VARCHAR(20) <FONT POINT-SIZE="9" COLOR="green">DEFAULT 'active'</FONT></TD>
      </TR>
      <TR>
        <TD></TD>
        <TD ALIGN="LEFT">age: INT <FONT POINT-SIZE="9" COLOR="orange">CHECK (&gt;= 18)</FONT></TD>
      </TR>
    </TABLE>
  >];
}
```

**注意**: HTML实体 `&gt;` 表示 `>` 符号

---

## Mrecord形状 (圆角Record)

**用途**: 更柔和的视觉效果,适合现代UI风格

**对比**:
```dot
digraph MrecordDemo {
  node [shape=record];
  Table1 [label="{User|id\l|name\l}"];

  node [shape=Mrecord];
  Table2 [label="{Order|orderId\l|total\l}"];

  Table1 -> Table2 [label="圆角更柔和"];
}
```

**语法**: 与record完全相同,仅形状参数不同

---

## 索引表示

### 单列索引

```html
<TR>
  <TD BGCOLOR="lightyellow">IDX</TD>
  <TD>email: VARCHAR(100)</TD>
</TR>
```

### 复合索引

```html
<TR>
  <TD BGCOLOR="lightyellow" ROWSPAN="2">IDX</TD>
  <TD>userId: INT</TD>
</TR>
<TR>
  <TD>createTime: DATETIME</TD>
</TR>
```

### 完整示例

```dot
digraph IndexDemo {
  node [shape=plain];

  Order [label=<
    <TABLE BORDER="0" CELLBORDER="1" CELLSPACING="0">
      <TR><TD BGCOLOR="navy" COLSPAN="3"><FONT COLOR="white"><B>Order</B></FONT></TD></TR>
      <TR>
        <TD BGCOLOR="gold">PK</TD>
        <TD>orderId</TD>
        <TD>INT</TD>
      </TR>
      <TR>
        <TD BGCOLOR="lightgreen">FK</TD>
        <TD>userId</TD>
        <TD>INT</TD>
      </TR>
      <TR>
        <TD BGCOLOR="lightyellow">IDX</TD>
        <TD>orderNumber</TD>
        <TD>VARCHAR(50)</TD>
      </TR>
      <TR>
        <TD BGCOLOR="lightyellow" ROWSPAN="2">IDX</TD>
        <TD>userId</TD>
        <TD>INT</TD>
      </TR>
      <TR>
        <TD>createTime</TD>
        <TD>DATETIME</TD>
      </TR>
    </TABLE>
  >];
}
```

**颜色标准**:
- PK: gold (金色)
- FK: lightgreen (浅绿)
- UK: lightyellow (浅黄)
- IDX: lightyellow (浅黄)

---

### 错误 3: 主键外键未区分

**❌ 错误写法**:
```dot
Order [label="{Order|id: int\l|user_id: int\l}"];
```

**✅ 正确写法**:
```dot
Order [label="{Order|<pk> id: int (PK)\l|<fk> user_id: int (FK)\l}"];
```

**原因**: 主键和外键是数据库设计的核心,必须明确标识。

---

### 错误 4: 缺少端口引用

**❌ 错误写法**:
```dot
User -> Order [label="FK"];
```

**✅ 正确写法**:
```dot
User:pk -> Order:fk [label="FK"];
```

**原因**: 使用端口引用可以精确连接到特定字段,更清晰直观。

---

### 错误 5: 多对多未使用关联表

**❌ 错误写法**:
```dot
Product -> Tag [label="M:N"];
```

**✅ 正确写法**:
```dot
ProductTag [label="{ProductTag|<pk> id: int (PK)\l|<fk1> product_id: int (FK)\l|<fk2> tag_id: int (FK)\l}"];

Product:pk -> ProductTag:fk1 [label="1:N"];
Tag:pk -> ProductTag:fk2 [label="1:N"];
```

**原因**: 多对多关系应该通过中间表展示,这是数据库设计规范。

---

### 错误 6: 语句缺少分号

**❌ 错误写法**:
```dot
digraph ER {
  User [label="{User|id: int\l}"]
  Order [label="{Order|id: int\l}"]
  User -> Order
}
```

**✅ 正确写法**:
```dot
digraph ER {
  User [label="{User|id: int\l}"];
  Order [label="{Order|id: int\l}"];
  User -> Order;
}
```

**原因**: DOT 语法要求所有语句以分号结尾（这是 Graphviz 的强制规则 2）。

---

## 生成检查清单

生成代码后,逐项检查:

- [ ] **图类型正确**: 使用 `digraph` 声明
- [ ] **节点形状正确**: 所有表使用 `shape=record`
- [ ] **字段左对齐**: 所有字段末尾使用 `\l`
- [ ] **分隔符正确**: 表名和字段用 `|` 分隔
- [ ] **主键标识**: 主键字段标注 `(PK)` 和 `<pk>`
- [ ] **外键标识**: 外键字段标注 `(FK)` 和 `<fk>`
- [ ] **端口引用**: 关系使用 `表名:端口` 语法
- [ ] **关系基数**: 所有关系标注基数 (1:1, 1:N, M:N)
- [ ] **多对多正确**: 多对多使用中间表,不直接连接
- [ ] **语句分号**: 所有语句以分号结尾
- [ ] **布局方向**: `rankdir` 在节点定义之前
- [ ] **代码可渲染**: 语法正确,可直接通过 Kroki 渲染

**任何检查项不通过,立即修正后重新生成**
