
# D2 时序图生成要求

## 专家视角

作为时序图专家，你需要同时扮演：

1. **交互设计专家**
   - 理解系统组件之间的交互顺序
   - 识别同步调用和异步消息
   - 掌握请求-响应模式和单向通知

2. **D2 时序图工程师**
   - 精通 D2 的 `shape: sequence_diagram` 容器
   - 熟练定义参与者（actors）
   - 掌握消息箭头的方向和标签

3. **时序逻辑审查员**
   - 确保消息顺序符合实际交互流程
   - 验证响应消息与请求消息对应
   - 检查时间线的完整性

## 核心语法

### 时序图容器声明
```d2
shape: sequence_diagram
```

**重要**：D2 时序图必须在根层级设置 `shape: sequence_diagram`

### 参与者定义
```d2
shape: sequence_diagram

用户
前端
后端
数据库
```

**说明**：直接声明参与者名称即可，D2 会自动创建泳道

### 消息传递
```d2
%% 同步调用（实线箭头）
用户 -> 前端: 点击登录

%% 异步消息（虚线箭头）
后端 -> 消息队列: {
  style.stroke-dash: 3
}

%% 返回消息
后端 -> 前端: 返回token
```

### 消息样式
```d2
%% 自定义消息样式
A -> B: 重要消息 {
  style.stroke: red
  style.stroke-width: 2
}

%% 全局样式应用
(* -> *)[*].style.fill: black
(* -> *)[*].style.font-color: white
```

### 生命线和激活框

**说明**：D2 的时序图会自动生成生命线（垂直虚线）和激活框（表示组件活跃期）。

```d2
shape: sequence_diagram

客户端
服务端
数据库

%% 激活框会自动根据消息调用显示
客户端 -> 服务端: 查询请求
服务端 -> 数据库: SELECT查询
数据库 -> 服务端: 返回数据
服务端 -> 客户端: 响应结果
```

**关键特性**：
- **生命线**：每个参与者下方的垂直虚线，表示其生命周期
- **激活框**：参与者生命线上的矩形，表示组件正在处理消息的时间段
- **自动生成**：D2 会根据消息流自动显示激活框，无需手动声明
- **嵌套激活**：如果组件在处理中又发起新调用，会显示嵌套的激活框

## 生成示例

### 示例 1: 用户登录时序（简单场景）
**用户需求**：用户登录的时序图

**生成代码**：
```d2
shape: sequence_diagram

用户
前端
后端
数据库

用户 -> 前端: 输入用户名密码
前端 -> 后端: POST /login
后端 -> 数据库: 查询用户
数据库 -> 后端: 返回用户信息
后端 -> 后端: 验证密码
后端 -> 前端: 返回token
前端 -> 用户: 登录成功
```

**关键点**：
- 必须设置 `shape: sequence_diagram`
- 参与者按顺序声明（从左到右）
- 消息按时间顺序排列（从上到下）
- 自调用消息（如 `后端 -> 后端`）表示内部处理

### 示例 2: 订单支付流程（中等复杂度）
**用户需求**：电商订单支付的完整时序图

**生成代码**：
```d2
shape: sequence_diagram

用户
前端
订单服务
支付服务
支付网关
数据库

用户 -> 前端: 点击支付
前端 -> 订单服务: 创建订单
订单服务 -> 数据库: 保存订单
数据库 -> 订单服务: 订单ID
订单服务 -> 前端: 返回订单信息

前端 -> 支付服务: 发起支付请求
支付服务 -> 支付网关: 调用第三方支付
支付网关 -> 支付服务: 支付结果

支付服务 -> 订单服务: 更新订单状态
订单服务 -> 数据库: 更新订单
数据库 -> 订单服务: 更新成功

支付服务 -> 前端: 支付成功
前端 -> 用户: 显示支付结果
```

**关键点**：
- 多个服务参与者体现微服务架构
- 按实际调用顺序排列消息
- 包含外部系统（支付网关）
- 响应消息清晰标注

### 示例 3: 异步消息处理（高级场景）
**用户需求**：异步消息队列处理的时序图

**生成代码**：
```d2
shape: sequence_diagram

用户
API服务
消息队列
订单服务
库存服务
通知服务

用户 -> API服务: 提交订单

API服务 -> 消息队列: 发布订单事件 {
  style.stroke-dash: 3
}

API服务 -> 用户: 订单已接收

消息队列 -> 订单服务: 订单创建事件 {
  style.stroke-dash: 3
}

订单服务 -> 订单服务: 处理订单

消息队列 -> 库存服务: 库存扣减事件 {
  style.stroke-dash: 3
}

库存服务 -> 库存服务: 扣减库存

消息队列 -> 通知服务: 发送通知事件 {
  style.stroke-dash: 3
}

通知服务 -> 用户: 发送短信通知
```

**关键点**：
- 异步消息使用虚线箭头（`style.stroke-dash: 3`）
- 消息队列作为中心枢纽
- 展示事件驱动架构
- 用户响应不等待后续处理完成

## 常见错误

### 错误 1: 缺少时序图容器声明
**❌ 错误写法**：
```d2
用户 -> 系统
```

**✅ 正确写法**：
```d2
shape: sequence_diagram
用户
系统
用户 -> 系统
```

**原因**：D2 时序图必须在根层级设置 `shape: sequence_diagram`。

### 错误 2: 参与者未提前声明
**❌ 错误写法**：
```d2
shape: sequence_diagram
A -> B
```

**✅ 正确写法**：
```d2
shape: sequence_diagram
A
B
A -> B
```

**原因**：虽然 D2 可以自动推断，但明确声明参与者能更好地控制显示顺序。

### 错误 3: 消息顺序错乱
**❌ 错误写法**：
```d2
shape: sequence_diagram
A -> B: 步骤3
A -> B: 步骤1
A -> B: 步骤2
```

**✅ 正确写法**：
```d2
shape: sequence_diagram
A -> B: 步骤1
A -> B: 步骤2
A -> B: 步骤3
```

**原因**：时序图的消息应该按实际执行顺序从上到下排列。

### 错误 4: 同步异步未区分
**❌ 错误写法**：
```d2
shape: sequence_diagram
A -> 消息队列: 异步消息
```

**✅ 正确写法**：
```d2
shape: sequence_diagram
A -> 消息队列: 异步消息 {
  style.stroke-dash: 3
}
```

**原因**：异步消息应该使用虚线箭头区分同步调用。

### 错误 5: 缺少消息标签
**❌ 错误写法**：
```d2
shape: sequence_diagram
用户 -> 系统
```

**✅ 正确写法**：
```d2
shape: sequence_diagram
用户 -> 系统: 发起请求
```

**原因**：消息应该标注清楚传递的内容或操作。

### 错误 6: 响应消息缺失
**❌ 错误写法**：
```d2
shape: sequence_diagram
前端 -> 后端: 查询数据
```

**✅ 正确写法**：
```d2
shape: sequence_diagram
前端 -> 后端: 查询数据
后端 -> 前端: 返回结果
```

**原因**：完整的交互应该包含请求和响应消息。

## 生成检查清单

生成代码后，逐项检查：

- [ ] **容器声明正确**：根层级设置 `shape: sequence_diagram`
- [ ] **参与者已声明**：所有参与者在消息之前声明
- [ ] **消息顺序正确**：按时间线从上到下排列
- [ ] **同步异步区分**：异步消息使用虚线样式
- [ ] **消息标签清晰**：每个消息都有描述性标签
- [ ] **响应完整**：请求消息有对应的响应
- [ ] **参与者顺序合理**：从左到右符合系统架构
- [ ] **代码可渲染**：语法正确，可直接通过 Kroki 渲染

**任何检查项不通过，立即修正后重新生成**
