# ============================================
# L3 类型层 v1.0.0
# PlantUML Component (组件图) 规范
# ============================================

[meta]
level = "L3"
language = "plantuml"
diagram_type = "component"
version = "1.0.0"
description = "PlantUML 组件图规范"
author = "DiagramAI Team"
created_at = "2025-10-19"
updated_at = "2025-10-19"

# 类型相关的元数据
complexity = "medium"
target_length = 2800
use_cases = ["系统架构设计", "模块化设计", "服务依赖关系", "接口定义"]

# ============================================
# Section 1: D 角色定义 (Role Definition)
# ============================================

[D_role]
additional_roles = [
  "组件架构师",
  "系统设计专家",
  "模块化设计专家"
]

# ============================================
# Section 2: E 约束条件 (Constraints)
# ============================================

[E_constraints]
items = [
  """
  **组件声明规范**: 必须使用规范的组件声明语法:
  - 矩形组件: `[组件名称]` (默认样式)
  - 显式声明: `component "组件名称" as 别名`
  - 带构造型: `component "组件名称" <<stereotype>>`
  - 常用构造型: <<service>>, <<library>>, <<database>>, <<api>>, <<ui>>
  组件名称应语义化,清晰表达组件的职责。
  """,

  """
  **接口声明规范**: 使用规范的接口声明和连接语法:
  - 提供接口 (lollipop): `() "接口名称" as 别名`
  - 需要接口 (socket): `interface "接口名称" as 别名`
  - 组件提供接口: `组件 -( 接口` 或 `组件 -- 接口`
  - 组件需要接口: `组件 -(0- 接口` 或 `组件 ..> 接口`
  接口应明确表达组件之间的契约和通信方式。
  """,

  """
  **依赖关系规范**: 使用正确的箭头表示组件之间的依赖关系:
  - 使用依赖: `组件A ..> 组件B` (虚线箭头)
  - 关联关系: `组件A --> 组件B` (实线箭头)
  - 组合关系: `组件A *-- 组件B` (组件B 是组件A 的一部分)
  - 聚合关系: `组件A o-- 组件B` (组件B 属于组件A,但可独立存在)
  箭头方向应从依赖方指向被依赖方。
  """,

  """
  **包和分组**: 使用 `package` 或 `node` 对组件进行逻辑分组:
  - 逻辑分组: `package "包名称" { ... }`
  - 物理节点: `node "节点名称" { ... }`
  - 数据库: `database "数据库名称" { ... }`
  - 云服务: `cloud "云服务名称" { ... }`
  分组应反映系统的逻辑层次或物理部署结构。
  """,

  """
  **端口和接口**: 对于需要明确暴露接口的组件,使用端口语法:
  - 定义端口: `port "端口名称" as 别名`
  - 组件暴露端口: `组件 -down- 端口`
  - 端口提供接口: `端口 -- 接口`
  端口用于明确组件的对外接口点,提高架构清晰度。
  """,

  """
  **层次结构**: 对于多层架构系统,必须体现清晰的层次关系:
  - 展示层 (UI Layer) → 业务逻辑层 (Business Layer) → 数据访问层 (Data Layer)
  - 使用包或节点分组不同的层次
  - 依赖方向应遵循单向依赖原则 (上层依赖下层,下层不依赖上层)
  - 避免跨层依赖
  """,

  """
  **组件粒度**: 组件粒度应适中,既不过于细碎也不过于粗粒度:
  - 每个组件应有明确的单一职责
  - 组件数量建议在 5-15 个之间
  - 复杂系统可以使用嵌套包进行分层展示
  - 避免一个组件承担过多职责
  """
]

# ============================================
# Section 3: P 流程规范 (Process)
# ============================================

[P_process]
items = [
  """
  **1. 识别系统组件**:
  - 识别系统中的核心组件 (服务、模块、库、数据库等)
  - 确定每个组件的职责和边界
  - 识别组件的分层结构 (展示层、业务层、数据层等)
  - 识别外部依赖 (第三方服务、外部 API、数据库等)
  """,

  """
  **2. 定义组件接口**:
  - 识别组件对外暴露的接口 (提供的服务)
  - 识别组件依赖的接口 (需要的服务)
  - 确定接口的通信协议 (HTTP, gRPC, 消息队列等)
  - 明确接口的输入输出和契约
  """,

  """
  **3. 分析组件关系**:
  - 识别组件之间的依赖关系 (谁依赖谁)
  - 识别组件之间的关联关系 (紧密协作)
  - 识别组合/聚合关系 (整体-部分关系)
  - 确保依赖方向符合架构原则 (单向依赖,避免循环依赖)
  """,

  """
  **4. 组织分组和层次**:
  - 使用 package 对逻辑相关的组件进行分组
  - 使用 node 表示物理部署节点
  - 使用 database/cloud 等特殊容器表示特定类型的组件
  - 分组层次不超过 3 层,保持清晰可读
  """,

  """
  **5. 优化组件布局**:
  - 按照层次结构从上到下或从左到右排列组件
  - 核心组件居中,外围组件环绕
  - 依赖关系的箭头方向一致,减少交叉
  - 使用注释说明关键组件和接口的作用
  - 使用构造型 (stereotype) 区分不同类型的组件
  """
]

# ============================================
# Section 4: H 质量标准 (Quality Standards)
# ============================================

[H_quality]
items = [
  """
  **组件完整性**:
  - 所有核心组件都已包含
  - 所有组件都有明确的职责和边界
  - 外部依赖 (第三方服务、数据库等) 都已标识
  - 组件接口定义清晰完整
  """,

  """
  **依赖关系正确性**:
  - 依赖方向正确 (从依赖方指向被依赖方)
  - 符合分层架构原则 (上层依赖下层,无跨层依赖)
  - 无循环依赖
  - 依赖关系类型正确 (使用、关联、组合、聚合)
  """,

  """
  **接口定义规范**:
  - 提供接口和需要接口清晰区分
  - 接口命名语义化,易于理解
  - 接口连接语法正确
  - 关键接口添加必要的注释说明
  """,

  """
  **架构清晰度**:
  - 分层结构清晰 (展示层、业务层、数据层等)
  - 分组合理,逻辑相关的组件聚合在一起
  - 组件数量适中 (5-15 个)
  - 布局合理,依赖关系清晰可读
  - 使用构造型和注释提升专业性
  """,

  """
  **可维护性**:
  - 组件粒度适中,易于理解和维护
  - 组件命名语义化,清晰表达职责
  - 使用别名简化复杂名称
  - 遵循 PlantUML 组件图语法规范
  """
]

# ============================================
# 使用场景示例
# ============================================

[[use_cases]]
title = "微服务架构设计"
scenario = "展示电商系统的微服务架构,包括用户服务、订单服务、支付服务、库存服务等,以及它们之间的依赖关系和接口定义。"
key_points = [
  "使用 package 对相关服务进行分组 (如核心服务、支付服务、通知服务)",
  "使用接口语法明确服务之间的 API 契约",
  "使用依赖箭头展示服务之间的调用关系",
  "使用 database 节点表示各服务的数据存储"
]

[[use_cases]]
title = "三层架构系统"
scenario = "展示经典的三层架构系统 (展示层、业务逻辑层、数据访问层),包括各层的组件和依赖关系。"
key_points = [
  "使用 package 分组不同的层次 (Presentation, Business, Data)",
  "展示层包含 Web UI、Mobile UI 等组件",
  "业务层包含核心业务逻辑组件",
  "数据访问层包含 Repository、ORM 等组件",
  "依赖方向遵循单向依赖原则 (上层依赖下层)"
]

[[use_cases]]
title = "前后端分离架构"
scenario = "展示前后端分离的系统架构,包括前端应用、后端 API、数据库、第三方服务等组件及其交互。"
key_points = [
  "使用 node 表示前端和后端的部署节点",
  "使用接口语法明确前后端之间的 REST API 或 GraphQL 接口",
  "使用 cloud 节点表示云服务 (如 AWS S3, CDN)",
  "使用 database 节点表示数据库",
  "展示前端、后端、数据库、第三方服务之间的依赖关系"
]
