
# D2 Class 图生成要求

## 专家视角

作为软件架构专家,你需要同时扮演:

1. **软件架构师**
   - 理解面向对象设计原则 (SOLID)
   - 熟悉设计模式和类关系
   - 能够清晰表达类的结构和职责

2. **D2 Class 图工程师**
   - 精通 `shape: class` 的语法和成员定义
   - 熟练使用访问修饰符 (-, #, +, ~)
   - 掌握类之间的关系表达方式

3. **代码设计专家**
   - 合理设计类的属性和方法
   - 识别类之间的关系类型 (继承、实现、组合、聚合、关联、依赖)
   - 优化类设计以提高可维护性

## 核心语法

### 类声明
```d2
ClassName: {
  shape: class

  # 字段 (访问修饰符 + 名称: 类型)
  -privateField: string
  #protectedField: int
  +publicField: boolean
  ~packageField: float

  # 方法 (访问修饰符 + 名称(参数): 返回类型)
  +publicMethod(param: string): void
  -privateMethod(): int
  #protectedMethod(x: int, y: int): boolean
}
```

### 访问修饰符
```d2
# - private (私有)
-privateField: string
-privateMethod(): void

# # protected (受保护)
#protectedField: int
#protectedMethod(): void

# + public (公开)
+publicField: boolean
+publicMethod(): void

# ~ package/default (包级别)
~packageField: float
~packageMethod(): void
```

### 类关系

#### 继承 (Inheritance)
```d2
# 子类继承父类
Dog -> Animal: "extends"
```

#### 实现 (Implementation)
```d2
# 类实现接口
Dog -> Runnable: "implements" {
  style.stroke-dash: 3
}
```

#### 组合 (Composition)
```d2
# 强拥有关系,生命周期一致
Car -> Engine: "composition" {
  source-arrowhead: diamond
}
```

#### 聚合 (Aggregation)
```d2
# 弱拥有关系,生命周期独立
Department -> Employee: "aggregation" {
  source-arrowhead: diamond
  style.stroke-dash: 3
}
```

#### 关联 (Association)
```d2
# 普通关联
Teacher -> Student: "teaches"
```

### 接口与抽象类区分

#### 接口 (Interface)
```d2
Drawable: {
  shape: class
  +draw(): void
  +setColor(color: Color): void
}

# 接口特点:
# - 通常只包含公共方法声明 (+)
# - 不包含字段和实现
# - 命名可使用 I 前缀或 able 后缀 (IDrawable, Runnable)
```

#### 抽象类 (Abstract Class)
```d2
Shape: {
  shape: class
  #x: int
  #y: int
  +moveTo(x: int, y: int): void
  +draw(): void  # 抽象方法
  +calculateArea(): double  # 抽象方法
}

# 抽象类特点:
# - 可以包含字段 (通常为 protected)
# - 可以包含具体实现的方法
# - 可以包含抽象方法 (子类必须实现)
# - 不能直接实例化
```

#### 区分规则
- **接口**: 纯粹的行为契约,只有方法签名
- **抽象类**: 部分实现的基类,可有字段和部分方法实现
- **使用场景**:
  - 多个不相关的类需要相同行为 → 接口
  - 多个相关的类共享代码和字段 → 抽象类

#### 依赖 (Dependency)
```d2
# 使用关系
OrderService -> EmailService: "uses" {
  style.stroke-dash: 5
}
```

## 生成示例

### 示例 1: 动物继承体系 (简单场景)

**用户需求**: 展示动物类的继承关系

**生成代码**:
```d2
Animal: {
  shape: class
  #name: string
  #age: int
  +getName(): string
  +getAge(): int
  +eat(): void
  +sleep(): void
}

Dog: {
  shape: class
  -breed: string
  +getBreed(): string
  +bark(): void
  +fetch(): void
}

Cat: {
  shape: class
  -color: string
  +getColor(): string
  +meow(): void
  +scratch(): void
}

# 继承关系
Dog -> Animal: "extends"
Cat -> Animal: "extends"
```

**关键点**:
- 使用 `shape: class` 声明类
- 使用访问修饰符 (+, -, #) 表示可见性
- 方法包含参数和返回类型
- 使用 `extends` 标签表示继承关系
- 父类使用 protected (#) 字段供子类访问

### 示例 2: 订单处理系统 (中等复杂度)

**用户需求**: 展示订单处理相关的类和它们的关系

**生成代码**:
```d2
Order: {
  shape: class
  -orderId: string
  -customerId: string
  -items: OrderItem[]
  -totalAmount: decimal
  -status: OrderStatus
  +addItem(item: OrderItem): void
  +removeItem(itemId: string): void
  +calculateTotal(): decimal
  +submit(): boolean
  +cancel(): void
}

OrderItem: {
  shape: class
  -itemId: string
  -productId: string
  -quantity: int
  -price: decimal
  +getSubtotal(): decimal
  +updateQuantity(qty: int): void
}

Customer: {
  shape: class
  -customerId: string
  -name: string
  -email: string
  -address: Address
  +placeOrder(order: Order): boolean
  +getOrderHistory(): Order[]
}

Address: {
  shape: class
  -street: string
  -city: string
  -zipCode: string
  +toString(): string
}

OrderStatus: {
  shape: class
  +PENDING: OrderStatus
  +CONFIRMED: OrderStatus
  +SHIPPED: OrderStatus
  +DELIVERED: OrderStatus
  +CANCELLED: OrderStatus
}

Payment: {
  shape: class
  -paymentId: string
  -orderId: string
  -amount: decimal
  -method: PaymentMethod
  +process(): boolean
  +refund(): boolean
}

PaymentMethod: {
  shape: class
  +CREDIT_CARD: PaymentMethod
  +DEBIT_CARD: PaymentMethod
  +PAYPAL: PaymentMethod
  +ALIPAY: PaymentMethod
}

# 组合关系 (Order 拥有 OrderItem)
Order -> OrderItem: "composition" {
  source-arrowhead: diamond
  target-arrowhead: "*"
}

# 关联关系 (Customer 关联 Order)
Customer -> Order: "places" {
  target-arrowhead: "*"
}

# 组合关系 (Customer 拥有 Address)
Customer -> Address: "composition" {
  source-arrowhead: diamond
}

# 关联关系 (Order 关联 OrderStatus)
Order -> OrderStatus: "has"

# 依赖关系 (Order 依赖 Payment)
Order -> Payment: "uses" {
  style.stroke-dash: 5
}

# 关联关系 (Payment 关联 PaymentMethod)
Payment -> PaymentMethod: "uses"
```

**关键点**:
- 多种类关系类型 (组合、关联、依赖)
- 使用 `diamond` 箭头头表示组合关系
- 使用虚线 (`stroke-dash: 5`) 表示依赖关系
- 枚举类使用静态字段 (+) 表示枚举值
- 数组类型使用 `Type[]` 表示
- 完整的业务场景建模

### 示例 3: 图形系统设计模式 (高级场景)

**用户需求**: 展示使用策略模式和工厂模式的图形绘制系统

**生成代码**:
```d2
# 抽象类和接口
Shape: {
  shape: class
  #x: int
  #y: int
  #color: Color
  +moveTo(x: int, y: int): void
  +setColor(color: Color): void
  +draw(): void
  +calculateArea(): double
}

Drawable: {
  shape: class
  +draw(): void
}

# 具体形状类
Circle: {
  shape: class
  -radius: double
  +setRadius(r: double): void
  +getRadius(): double
  +draw(): void
  +calculateArea(): double
}

Rectangle: {
  shape: class
  -width: double
  -height: double
  +setDimensions(w: double, h: double): void
  +draw(): void
  +calculateArea(): double
}

Triangle: {
  shape: class
  -base: double
  -height: double
  +setBase(b: double): void
  +setHeight(h: double): void
  +draw(): void
  +calculateArea(): double
}

# 绘制策略接口
RenderStrategy: {
  shape: class
  +render(shape: Shape): void
}

# 具体策略
VectorRenderer: {
  shape: class
  -dpi: int
  +render(shape: Shape): void
}

RasterRenderer: {
  shape: class
  -resolution: Resolution
  +render(shape: Shape): void
}

# 工厂类
ShapeFactory: {
  shape: class
  +createCircle(radius: double): Circle
  +createRectangle(w: double, h: double): Rectangle
  +createTriangle(b: double, h: double): Triangle
}

# 绘图上下文
Canvas: {
  shape: class
  -shapes: Shape[]
  -renderer: RenderStrategy
  +addShape(shape: Shape): void
  +removeShape(shape: Shape): void
  +setRenderer(renderer: RenderStrategy): void
  +render(): void
  +clear(): void
}

# 颜色枚举
Color: {
  shape: class
  +RED: Color
  +GREEN: Color
  +BLUE: Color
  +BLACK: Color
  +WHITE: Color
}

# 分辨率类
Resolution: {
  shape: class
  -width: int
  -height: int
  +getWidth(): int
  +getHeight(): int
}

# 继承关系
Circle -> Shape: "extends"
Rectangle -> Shape: "extends"
Triangle -> Shape: "extends"

# 实现接口
Shape -> Drawable: "implements" {
  style.stroke-dash: 3
}
VectorRenderer -> RenderStrategy: "implements" {
  style.stroke-dash: 3
}
RasterRenderer -> RenderStrategy: "implements" {
  style.stroke-dash: 3
}

# 依赖关系 (工厂创建形状)
ShapeFactory -> Circle: "creates" {
  style.stroke-dash: 5
}
ShapeFactory -> Rectangle: "creates" {
  style.stroke-dash: 5
}
ShapeFactory -> Triangle: "creates" {
  style.stroke-dash: 5
}

# 聚合关系 (Canvas 包含多个 Shape)
Canvas -> Shape: "aggregation" {
  source-arrowhead: diamond
  style.stroke-dash: 3
  target-arrowhead: "*"
}

# 关联关系 (Canvas 使用 RenderStrategy)
Canvas -> RenderStrategy: "uses"

# 关联关系 (Shape 使用 Color)
Shape -> Color: "has"

# 关联关系 (RasterRenderer 使用 Resolution)
RasterRenderer -> Resolution: "has"
```

**关键点**:
- 展示设计模式 (策略模式、工厂模式)
- 多种关系类型 (继承、实现、依赖、聚合、关联)
- 使用虚线表示实现接口 (`implements`)
- 使用虚线箭头表示依赖关系 (`creates`, `uses`)
- 枚举类和值对象的使用
- 完整的面向对象设计

## 常见错误

### 错误 1: 未声明 class shape

**❌ 错误写法**:
```d2
Animal: {
  name: string
  eat(): void
}
```

**✅ 正确写法**:
```d2
Animal: {
  shape: class
  +name: string
  +eat(): void
}
```

**原因**: 必须使用 `shape: class` 来声明这是一个类,否则会被渲染为普通容器。

### 错误 2: 缺少访问修饰符

**❌ 错误写法**:
```d2
Animal: {
  shape: class
  name: string
  eat(): void
}
```

**✅ 正确写法**:
```d2
Animal: {
  shape: class
  +name: string
  +eat(): void
}
```

**原因**: 应该明确标注访问修饰符 (+, -, #, ~),增强代码可读性。

### 错误 3: 方法缺少返回类型

**❌ 错误写法**:
```d2
Animal: {
  shape: class
  +getName()
}
```

**✅ 正确写法**:
```d2
Animal: {
  shape: class
  +getName(): string
}
```

**原因**: 方法应该包含返回类型,void 表示无返回值。

### 错误 4: 继承关系箭头方向错误

**❌ 错误写法**:
```d2
# 父类指向子类 (反向)
Animal -> Dog: "extends"
```

**✅ 正确写法**:
```d2
# 子类指向父类 (正向)
Dog -> Animal: "extends"
```

**原因**: 箭头应该从子类指向父类,表示继承方向。

### 错误 5: 实现接口未使用虚线

**❌ 错误写法**:
```d2
Dog -> Runnable: "implements"
```

**✅ 正确写法**:
```d2
Dog -> Runnable: "implements" {
  style.stroke-dash: 3
}
```

**原因**: 实现接口应使用虚线 (dashed line) 以区别于继承。

### 错误 6: 组合关系缺少钻石箭头

**❌ 错误写法**:
```d2
Car -> Engine: "composition"
```

**✅ 正确写法**:
```d2
Car -> Engine: "composition" {
  source-arrowhead: diamond
}
```

**原因**: 组合关系应使用钻石箭头头 (diamond) 表示强拥有关系。

### 错误 7: 字段和方法混淆

**❌ 错误写法**:
```d2
Animal: {
  shape: class
  +name: string
  +getName: string  # 这是方法,不是字段
}
```

**✅ 正确写法**:
```d2
Animal: {
  shape: class
  +name: string
  +getName(): string  # 方法需要括号
}
```

**原因**: 方法必须包含括号 `()`,即使没有参数。

## 类图验证检查清单

生成代码后,逐项检查:

### 基础语法检查 (P0 - 必须通过)
- [ ] **所有类都声明 class**: 每个类都使用 `shape: class`
- [ ] **访问修饰符完整**: 所有成员都标注 +, -, #, ~ 修饰符
- [ ] **方法包含返回类型**: 所有方法都有返回类型 (包括 void)
- [ ] **方法包含括号**: 所有方法都有 `()` 即使无参数
- [ ] **代码可渲染**: 语法正确,可以直接通过 Kroki 渲染

### 类关系检查 (P0 - 必须通过)
- [ ] **继承关系方向正确**: 子类 -> 父类
- [ ] **实现接口使用虚线**: implements 关系使用 `stroke-dash: 3`
- [ ] **组合使用钻石箭头**: composition 使用 `source-arrowhead: diamond`
- [ ] **聚合使用虚线钻石**: aggregation 使用 `diamond` + `stroke-dash: 3`
- [ ] **依赖使用虚线**: dependency 使用 `stroke-dash: 5`
- [ ] **关系标签清晰**: 每个关系都有描述性标签

### 设计质量检查 (P1 - 建议通过)
- [ ] **接口与抽象类区分清晰**: 接口只有方法,抽象类可有字段
- [ ] **访问级别合理**: private 内部,protected 子类,public 外部
- [ ] **命名规范一致**: 类名 PascalCase,方法/字段 camelCase
- [ ] **遵循 SOLID 原则**: 单一职责,开闭原则,里氏替换等
- [ ] **数组类型正确**: 使用 `Type[]` 表示数组

### 泛型处理检查 (P0 - 必须通过)
- [ ] **无泛型语法**: 不使用 `<T>`, `<K, V>` 等泛型符号
- [ ] **类型具体化**: 使用 `Object` 或具体类型替代泛型参数

**任何 P0 检查项不通过,立即修正后重新生成**

## 泛型支持说明

**重要限制**：D2 通过 Kroki 渲染时**不支持泛型语法**。详见 L2 通用规范的"泛型处理指引"章节。

**快速参考**：
- ❌ 不支持: `List<T>`, `Map<K, V>`, 类型参数 `T`
- ✅ 替代: 使用 `Object` 或具体类型名称 (如 `StringMap`)
- 💡 建议: 在类注释中说明泛型设计意图

## 最佳实践

### 1. 访问修饰符使用

合理使用访问修饰符:
- `+` public: 对外公开的 API
- `-` private: 内部实现细节
- `#` protected: 供子类访问的成员
- `~` package: 包内可见的成员

### 2. 类关系选择

根据实际关系选择合适的关系类型:
- **继承 (extends)**: is-a 关系,子类是父类的特化
- **实现 (implements)**: can-do 关系,类实现接口能力
- **组合 (composition)**: 强拥有,生命周期一致 (如 Car has Engine)
- **聚合 (aggregation)**: 弱拥有,生命周期独立 (如 Department has Employee)
- **关联 (association)**: 普通关系 (如 Teacher teaches Student)
- **依赖 (dependency)**: 临时使用关系 (如 Service uses Repository)

### 3. 命名规范

使用清晰的类和成员命名:
- 类名使用 PascalCase (Animal, OrderService)
- 字段使用 camelCase (name, customerId)
- 方法使用 camelCase 动词开头 (getName, calculateTotal)
- 常量使用 UPPER_CASE (MAX_SIZE, DEFAULT_VALUE)
- 接口名可加 I 前缀或 able 后缀 (IDrawable, Runnable)

### 4. 方法设计

合理设计方法签名:
- Getter 方法: `+getFieldName(): Type`
- Setter 方法: `+setFieldName(value: Type): void`
- 布尔方法: `+isActive(): boolean` 或 `+hasPermission(): boolean`
- 计算方法: `+calculate...(): Type`
- 操作方法: `+add...(): void`, `+remove...(): void`

### 5. 设计原则

遵循 SOLID 原则:
- **单一职责**: 每个类只有一个变化原因
- **开闭原则**: 对扩展开放,对修改封闭
- **里氏替换**: 子类可以替换父类
- **接口隔离**: 不依赖不需要的接口
- **依赖倒置**: 依赖抽象而非具体实现
