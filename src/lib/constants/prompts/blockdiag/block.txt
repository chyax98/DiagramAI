
# BlockDiag Block 生成要求

## 图表类型：块状流程图（Block Diagram）

块状流程图用于展示简化的流程和关系，比传统流程图更简洁，适用于：
- 简化的业务流程展示
- 系统模块关系图
- 快速原型设计

## 块状图特点

### 核心优势
1. **结构清晰**: 矩形块 + 箭头直观展示系统模块关系
2. **易于维护**: 简洁语法,代码可读性高
3. **灵活布局**: 支持横向/纵向布局,适应不同展示需求
4. **丰富样式**: 14种形状 + class 系统支持复杂样式

### 适用场景排序 (优先级从高到低)
1. **系统架构图**: 展示模块、组件、服务之间的依赖关系
2. **流程图**: 业务流程、决策树 (配合 `diamond` 形状)
3. **网络拓扑**: 服务器、网络设备连接关系 (配合 `cloud`, `actor` 形状)
4. **组织结构**: 部门、团队层级关系 (配合 `group` 分组)
5. **状态机**: 状态转换图 (配合 `circle`, `ellipse` 形状)

## 与 common.txt 的关系

**common.txt (L2)**: 定义 BlockDiag 通用语法规则
- 节点定义、连接语法、样式属性
- 分组、class 系统、图表级属性

**block.txt (L3)**: 专注块状图特定最佳实践
- 形状选择建议 (流程图用 `roundedbox`, 架构图用 `box`)
- 布局优化技巧 (何时用 `portrait`, 何时用 `landscape`)
- 典型场景模板 (系统架构、决策树、网络拓扑)

**使用建议**:
- 简单图表: 仅参考 common.txt 基础语法
- 复杂图表: 结合 block.txt 最佳实践,使用 class 系统和高级布局

## 核心语法

### 基础块状流程图
```
blockdiag {
  A [label = "开始"];
  B [label = "处理"];
  C [label = "结束"];

  A -> B -> C;
}
```

**语法要点**：
- 节点使用字母或数字标识
- `label` 定义节点显示文本
- `->` 定义连接关系

### 节点形状
```
blockdiag {
  A [label = "开始", shape = "roundedbox"];
  B [label = "处理", shape = "box"];
  C [label = "决策", shape = "diamond"];
  D [label = "结束", shape = "ellipse"];
}
```

**常用形状**：
- `box` - 矩形（默认）
- `roundedbox` - 圆角矩形
- `diamond` - 菱形（决策）
- `ellipse` - 椭圆
- `circle` - 圆形
- `note` - 便签

## 生成示例

### 示例 1: 简单登录流程（简单场景）
**用户需求**：用户登录流程，包含验证和跳转

**生成代码**：
```
blockdiag {
  A [label = "用户访问"];
  B [label = "登录页面"];
  C [label = "输入凭证"];
  D [label = "验证", shape = "diamond"];
  E [label = "主页"];
  F [label = "错误提示"];

  A -> B -> C -> D;
  D -> E [label = "成功"];
  D -> F [label = "失败"];
  F -> C;
}
```

**关键点**：
- 使用菱形表示决策点
- 带标签的连接线表示条件分支
- 失败路径可以返回到输入步骤

### 示例 2: 订单处理流程（中等复杂度）
**用户需求**：电商订单处理流程，包含多个处理阶段

**生成代码**：
```
blockdiag {
  // 节点定义
  A [label = "接收订单", shape = "roundedbox"];
  B [label = "库存检查", shape = "diamond"];
  C [label = "支付验证", shape = "diamond"];
  D [label = "发货", shape = "box"];
  E [label = "完成", shape = "roundedbox"];
  F [label = "缺货通知", shape = "note"];
  G [label = "支付失败", shape = "note"];

  // 连接关系
  A -> B;
  B -> C [label = "有库存"];
  B -> F [label = "无库存"];
  C -> D [label = "支付成功"];
  C -> G [label = "支付失败"];
  D -> E;

  // 分组
  group {
    label = "订单验证阶段";
    color = "#FFE0E0";
    A; B; C;
  }

  group {
    label = "履约阶段";
    color = "#E0FFE0";
    D; E;
  }
}
```

**关键点**：
- 使用 `shape = "diamond"` 表示决策点
- 使用 `shape = "note"` 表示通知类节点
- 使用 `group` 和 `color` 区分不同阶段
- 带标签的连接线清晰表示条件

### 示例 3: 系统架构模块关系（高级场景）
**用户需求**：展示微服务系统各模块间的依赖关系

**生成代码**：
```
blockdiag {
  // 前端层
  UI [label = "Web UI", color = "#FFE0E0"];
  Mobile [label = "Mobile App", color = "#FFE0E0"];

  // API 网关
  Gateway [label = "API Gateway", shape = "roundedbox", color = "#E0FFE0"];

  // 服务层
  Auth [label = "认证服务", color = "#E0E0FF"];
  Order [label = "订单服务", color = "#E0E0FF"];
  Payment [label = "支付服务", color = "#E0E0FF"];
  Inventory [label = "库存服务", color = "#E0E0FF"];

  // 数据层
  Redis [label = "Redis Cache", shape = "ellipse", color = "#FFFFE0"];
  MySQL [label = "MySQL", shape = "ellipse", color = "#FFFFE0"];
  Queue [label = "Message Queue", shape = "ellipse", color = "#FFFFE0"];

  // 连接关系
  UI -> Gateway;
  Mobile -> Gateway;

  Gateway -> Auth;
  Gateway -> Order;
  Gateway -> Payment;

  Order -> Inventory;
  Payment -> Order;

  Auth -> Redis;
  Order -> MySQL;
  Payment -> MySQL;
  Inventory -> MySQL;

  Order -> Queue;
  Inventory -> Queue;

  // 分组
  group {
    label = "客户端";
    color = "#FFE0E0";
    UI; Mobile;
  }

  group {
    label = "业务服务";
    color = "#E0E0FF";
    Auth; Order; Payment; Inventory;
  }

  group {
    label = "基础设施";
    color = "#FFFFE0";
    Redis; MySQL; Queue;
  }
}
```

**关键点**：
- 使用颜色区分不同层级（前端、服务、数据）
- 使用 `shape = "ellipse"` 表示数据存储
- 使用 `group` 进行层级划分
- 连接线清晰展示依赖关系

## 常见错误

### 错误 1: 节点未定义标签
**❌ 错误写法**：
```
blockdiag {
  A -> B -> C;
}
```

**✅ 正确写法**：
```
blockdiag {
  A [label = "步骤 A"];
  B [label = "步骤 B"];
  C [label = "步骤 C"];

  A -> B -> C;
}
```

**原因**：所有节点都应该定义清晰的标签，提高可读性。

### 错误 2: 缺少图表声明
**❌ 错误写法**：
```
A -> B -> C;
```

**✅ 正确写法**：
```
blockdiag {
  A [label = "步骤 A"];
  B [label = "步骤 B"];
  C [label = "步骤 C"];

  A -> B -> C;
}
```

**原因**：必须使用 `blockdiag {}` 包裹所有内容。

### 错误 3: 决策节点未使用菱形
**❌ 错误写法**：
```
blockdiag {
  A [label = "判断条件"];
  A -> B;
  A -> C;
}
```

**✅ 正确写法**：
```
blockdiag {
  A [label = "判断条件", shape = "diamond"];
  A -> B [label = "是"];
  A -> C [label = "否"];
}
```

**原因**：判断节点应该使用 `shape = "diamond"` 并标注分支条件。

## 典型场景模板

### 场景 1: 决策树 (Decision Tree)
**特点**: 使用 `diamond` 表示决策点,分支边带标签

```blockdiag
blockdiag {
  default_shape = roundedbox;
  edge_layout = flowchart;

  开始 [shape = beginpoint];
  输入数据 [label = "用户输入"];
  验证 [shape = diamond, label = "数据有效?"];
  处理 [label = "业务处理"];
  检查 [shape = diamond, label = "需要审批?"];
  审批 [label = "人工审批"];
  保存 [label = "保存结果"];
  通知 [label = "发送通知"];
  结束 [shape = endpoint];

  开始 -> 输入数据 -> 验证;
  验证 -> 处理 [label = "是", color = green];
  验证 -> 输入数据 [label = "否", color = red, style = dashed];
  处理 -> 检查;
  检查 -> 审批 [label = "是"];
  检查 -> 保存 [label = "否"];
  审批 -> 保存;
  保存 -> 通知 -> 结束;
}
```

### 场景 2: 分层系统架构
**特点**: 使用 `group` + `orientation = portrait` 表达层级关系

```blockdiag
blockdiag {
  orientation = portrait;
  default_shape = roundedbox;

  class frontend [color = blue, background = "#E3F2FD"];
  class backend [color = green, background = "#E8F5E9"];
  class data [color = red, background = "#FFEBEE"];

  group 前端层 [color = blue] {
    orientation = landscape;
    Web [class = "frontend"];
    Mobile [class = "frontend"];
  }

  group 业务层 [color = green] {
    orientation = landscape;
    API网关 [class = "backend"];
    认证服务 [class = "backend"];
    业务服务 [class = "backend"];
  }

  group 数据层 [color = red] {
    orientation = landscape;
    主库 [class = "data", stacked];
    缓存 [class = "data", shape = ellipse];
  }

  Web -> API网关;
  Mobile -> API网关;
  API网关 -> 认证服务;
  API网关 -> 业务服务;
  业务服务 -> 主库;
  业务服务 -> 缓存;
}
```

## 生成检查清单

- [ ] **图表声明**：使用 `blockdiag {}` 包裹
- [ ] **节点标签**：所有节点都定义了清晰的 `label`
- [ ] **节点形状**：决策节点使用 `diamond`，起止节点使用 `roundedbox` 或 `ellipse`
- [ ] **连接关系**：使用 `->` 正确定义节点间的连接
- [ ] **条件分支**：分支连接线有 `label` 标注条件
- [ ] **分组合理**：使用 `group` 进行逻辑分组
- [ ] **颜色区分**：使用 `color` 属性区分不同类型的节点或分组
- [ ] **代码可渲染**：语法正确，可直接通过 Kroki 渲染

**任何检查项不通过，立即修正后重新生成**
