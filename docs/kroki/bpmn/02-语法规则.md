# BPMN 语法规则详解

> **验证时间**: 2025-10-13
> **参考来源**: OMG BPMN 2.0 Specification, bpmn.io Documentation

---

## 🎯 核心语法规则

### 1. XML 结构规则

#### 1.1 基本文档结构

```xml
<?xml version="1.0" encoding="UTF-8"?>
<definitions xmlns="http://www.omg.org/spec/BPMN/20100524/MODEL"
             xmlns:bpmndi="http://www.omg.org/spec/BPMN/20100524/DI"
             xmlns:dc="http://www.omg.org/spec/DD/20100524/DC"
             xmlns:di="http://www.omg.org/spec/DD/20100524/DI"
             id="Definitions_1"
             targetNamespace="http://bpmn.io/schema/bpmn">

  <!-- 流程定义 -->
  <process id="Process_1" isExecutable="false">
    <!-- Flow Objects -->
  </process>

  <!-- 图形信息 -->
  <bpmndi:BPMNDiagram id="BPMNDiagram_1">
    <bpmndi:BPMNPlane id="BPMNPlane_1" bpmnElement="Process_1">
      <!-- Shapes and Edges -->
    </bpmndi:BPMNPlane>
  </bpmndi:BPMNDiagram>

</definitions>
```

#### 1.2 命名空间规则

**必需命名空间**:
```xml
xmlns="http://www.omg.org/spec/BPMN/20100524/MODEL"        <!-- BPMN 模型 -->
xmlns:bpmndi="http://www.omg.org/spec/BPMN/20100524/DI"    <!-- BPMN 图形 -->
```

**可选命名空间**:
```xml
xmlns:dc="http://www.omg.org/spec/DD/20100524/DC"          <!-- 维度坐标 -->
xmlns:di="http://www.omg.org/spec/DD/20100524/DI"          <!-- 图形信息 -->
xmlns:camunda="http://camunda.org/schema/1.0/bpmn"         <!-- Camunda 扩展 -->
xmlns:modeler="http://camunda.org/schema/modeler/1.0"      <!-- Modeler 元数据 -->
```

#### 1.3 ID 和引用规则

**ID 规则**:
- 必须唯一 (整个文档内)
- 格式: `[A-Za-z_][A-Za-z0-9_.-]*`
- 推荐: `ElementType_Number` (如 `StartEvent_1`)

**引用规则**:
- `sourceRef`: 指向源元素 ID
- `targetRef`: 指向目标元素 ID
- `bpmnElement`: 图形元素指向流程元素

```xml
<!-- 流程元素 -->
<task id="Task_ProcessOrder" name="处理订单"/>

<!-- 顺序流引用 -->
<sequenceFlow id="Flow_1" sourceRef="StartEvent_1" targetRef="Task_ProcessOrder"/>

<!-- 图形元素引用 -->
<bpmndi:BPMNShape id="Shape_Task_ProcessOrder" bpmnElement="Task_ProcessOrder">
  <dc:Bounds x="200" y="100" width="100" height="80"/>
</bpmndi:BPMNShape>
```

### 2. 事件规则

#### 2.1 Start Event (开始事件)

```xml
<!-- None Start Event -->
<startEvent id="StartEvent_1" name="开始"/>

<!-- Message Start Event -->
<startEvent id="StartEvent_Message" name="收到消息">
  <messageEventDefinition messageRef="Message_OrderRequest"/>
</startEvent>

<!-- Timer Start Event -->
<startEvent id="StartEvent_Timer" name="每日执行">
  <timerEventDefinition>
    <timeCycle>0 0 0 * * ?</timeCycle>  <!-- Cron 表达式 -->
  </timerEventDefinition>
</startEvent>

<!-- Signal Start Event -->
<startEvent id="StartEvent_Signal" name="收到信号">
  <signalEventDefinition signalRef="Signal_Alert"/>
</startEvent>

<!-- Conditional Start Event -->
<startEvent id="StartEvent_Conditional" name="条件触发">
  <conditionalEventDefinition>
    <condition>stock &lt; threshold</condition>
  </conditionalEventDefinition>
</startEvent>
```

**规则**:
- ✅ 不能有 incoming sequence flow
- ✅ 必须有至少一个 outgoing sequence flow
- ✅ 可以有多个 Start Event (不同触发条件)

#### 2.2 End Event (结束事件)

```xml
<!-- None End Event -->
<endEvent id="EndEvent_1" name="结束"/>

<!-- Message End Event -->
<endEvent id="EndEvent_Message" name="发送响应">
  <messageEventDefinition messageRef="Message_OrderConfirmation"/>
</endEvent>

<!-- Error End Event -->
<endEvent id="EndEvent_Error" name="错误结束">
  <errorEventDefinition errorRef="Error_ValidationFailed"/>
</endEvent>

<!-- Terminate End Event -->
<endEvent id="EndEvent_Terminate" name="终止">
  <terminateEventDefinition/>
</endEvent>
```

**规则**:
- ✅ 必须有至少一个 incoming sequence flow
- ✅ 不能有 outgoing sequence flow
- ✅ Terminate End 会立即终止所有活动流程

#### 2.3 Intermediate Event (中间事件)

```xml
<!-- Timer Intermediate Event (Catching) -->
<intermediateCatchEvent id="IntermediateEvent_Timer" name="等待 2 小时">
  <timerEventDefinition>
    <timeDuration>PT2H</timeDuration>  <!-- ISO 8601 duration -->
  </timerEventDefinition>
</intermediateCatchEvent>

<!-- Message Intermediate Event (Throwing) -->
<intermediateThrowEvent id="IntermediateEvent_SendNotice" name="发送通知">
  <messageEventDefinition messageRef="Message_Notification"/>
</intermediateThrowEvent>

<!-- Signal Intermediate Event (Catching) -->
<intermediateCatchEvent id="IntermediateEvent_Signal" name="等待信号">
  <signalEventDefinition signalRef="Signal_Continue"/>
</intermediateCatchEvent>

<!-- Link Events (页面跳转) -->
<intermediateThrowEvent id="ThrowLink_1" name="去页面 2">
  <linkEventDefinition name="ToPage2"/>
</intermediateThrowEvent>

<intermediateCatchEvent id="CatchLink_1" name="来自页面 1">
  <linkEventDefinition name="ToPage2"/>
</intermediateCatchEvent>
```

**规则**:
- ✅ 必须有 incoming 和 outgoing sequence flow
- ✅ Catching Event: 等待事件发生
- ✅ Throwing Event: 触发事件
- ✅ Link Event: name 必须匹配才能跳转

#### 2.4 Boundary Event (边界事件)

```xml
<task id="Task_ProcessPayment" name="处理支付">
  <!-- Task 内容 -->
</task>

<!-- Timer Boundary Event (Non-Interrupting) -->
<boundaryEvent id="BoundaryEvent_Reminder" name="2小时提醒"
               attachedToRef="Task_ProcessPayment" cancelActivity="false">
  <timerEventDefinition>
    <timeDuration>PT2H</timeDuration>
  </timerEventDefinition>
</boundaryEvent>

<!-- Error Boundary Event (Interrupting) -->
<boundaryEvent id="BoundaryEvent_Error" name="支付失败"
               attachedToRef="Task_ProcessPayment" cancelActivity="true">
  <errorEventDefinition errorRef="Error_PaymentFailed"/>
</boundaryEvent>

<!-- Message Boundary Event -->
<boundaryEvent id="BoundaryEvent_Cancel" name="取消订单"
               attachedToRef="Task_ProcessPayment" cancelActivity="true">
  <messageEventDefinition messageRef="Message_CancelOrder"/>
</boundaryEvent>
```

**规则**:
- ✅ 必须用 `attachedToRef` 附加到 Activity
- ✅ `cancelActivity="true"`: 中断型 (中断活动)
- ✅ `cancelActivity="false"`: 非中断型 (并行执行)
- ✅ Error Event 只能是中断型
- ✅ 不能有 incoming sequence flow

### 3. Activity 规则

#### 3.1 Task Types (任务类型)

```xml
<!-- User Task -->
<userTask id="Task_ReviewDocument" name="审核文档">
  <documentation>请审核并批准文档</documentation>
</userTask>

<!-- Service Task -->
<serviceTask id="Task_CallAPI" name="调用 API">
  <extensionElements>
    <camunda:connector>
      <camunda:inputOutput>
        <camunda:inputParameter name="url">https://api.example.com</camunda:inputParameter>
        <camunda:inputParameter name="method">POST</camunda:inputParameter>
      </camunda:inputOutput>
    </camunda:connector>
  </extensionElements>
</serviceTask>

<!-- Send Task -->
<sendTask id="Task_SendEmail" name="发送邮件">
  <messageEventDefinition messageRef="Message_Email"/>
</sendTask>

<!-- Receive Task -->
<receiveTask id="Task_WaitForResponse" name="等待响应">
  <messageEventDefinition messageRef="Message_Response"/>
</receiveTask>

<!-- Script Task -->
<scriptTask id="Task_Calculate" name="计算总额" scriptFormat="javascript">
  <script>
    <![CDATA[
      var total = price * quantity;
      execution.setVariable('total', total);
    ]]>
  </script>
</scriptTask>

<!-- Manual Task -->
<manualTask id="Task_PhysicalInspection" name="现场检查"/>

<!-- Business Rule Task -->
<businessRuleTask id="Task_CreditCheck" name="信用评分">
  <extensionElements>
    <camunda:decisionRef>Decision_CreditScore</camunda:decisionRef>
  </extensionElements>
</businessRuleTask>
```

#### 3.2 Sub-Process (子流程)

**Embedded Sub-Process (嵌入式)**:
```xml
<subProcess id="SubProcess_OrderValidation" name="订单验证">
  <startEvent id="StartEvent_Sub1"/>
  <task id="Task_CheckInventory" name="检查库存"/>
  <task id="Task_ValidatePayment" name="验证支付"/>
  <endEvent id="EndEvent_Sub1"/>

  <sequenceFlow id="Flow_Sub1" sourceRef="StartEvent_Sub1" targetRef="Task_CheckInventory"/>
  <sequenceFlow id="Flow_Sub2" sourceRef="Task_CheckInventory" targetRef="Task_ValidatePayment"/>
  <sequenceFlow id="Flow_Sub3" sourceRef="Task_ValidatePayment" targetRef="EndEvent_Sub1"/>
</subProcess>
```

**Call Activity (调用活动)**:
```xml
<!-- 可重用的流程 -->
<process id="Process_EmailNotification">
  <startEvent id="Start"/>
  <task id="Task_Send" name="发送邮件"/>
  <endEvent id="End"/>
</process>

<!-- 调用活动 -->
<callActivity id="CallActivity_Notify" name="发送通知" calledElement="Process_EmailNotification">
  <extensionElements>
    <camunda:in source="email" target="recipientEmail"/>
    <camunda:out source="status" target="notificationStatus"/>
  </extensionElements>
</callActivity>
```

**Multi-Instance (多实例)**:
```xml
<!-- Parallel Multi-Instance -->
<userTask id="Task_Review" name="并行审核">
  <multiInstanceLoopCharacteristics isSequential="false">
    <loopCardinality>3</loopCardinality>  <!-- 3个实例 -->
    <completionCondition>${nrOfCompletedInstances >= 2}</completionCondition>  <!-- 2个完成即可 -->
  </multiInstanceLoopCharacteristics>
</userTask>

<!-- Sequential Multi-Instance -->
<userTask id="Task_Approve" name="顺序审批">
  <multiInstanceLoopCharacteristics isSequential="true">
    <loopCardinality>${approvers.size()}</loopCardinality>
    <inputDataItem>approver</inputDataItem>
    <completionCondition>${approved == false}</completionCondition>  <!-- 任一拒绝则停止 -->
  </multiInstanceLoopCharacteristics>
</userTask>
```

**Loop (标准循环)**:
```xml
<task id="Task_RetryAPI" name="重试 API">
  <standardLoopCharacteristics testBefore="true">
    <loopCondition>${retryCount &lt; maxRetries}</loopCondition>
  </standardLoopCharacteristics>
</task>
```

### 4. Gateway 规则

#### 4.1 Exclusive Gateway (XOR)

```xml
<exclusiveGateway id="Gateway_Decision" name="是否批准?" default="Flow_Reject"/>

<!-- 条件分支 -->
<sequenceFlow id="Flow_Approve" name="是" sourceRef="Gateway_Decision" targetRef="Task_Approve">
  <conditionExpression xsi:type="tFormalExpression">
    ${approved == true}
  </conditionExpression>
</sequenceFlow>

<!-- 默认分支 (其他情况) -->
<sequenceFlow id="Flow_Reject" name="否" sourceRef="Gateway_Decision" targetRef="Task_Reject"/>
```

**规则**:
- ✅ 必须指定 `default` 默认流
- ✅ 其他流必须有 `conditionExpression`
- ✅ 只有一条流会被激活
- ✅ 汇聚时: 等待任一分支到达

#### 4.2 Parallel Gateway (AND)

```xml
<!-- 分支 -->
<parallelGateway id="Gateway_Fork" name="并行执行"/>
<sequenceFlow sourceRef="Gateway_Fork" targetRef="Task_A"/>
<sequenceFlow sourceRef="Gateway_Fork" targetRef="Task_B"/>
<sequenceFlow sourceRef="Gateway_Fork" targetRef="Task_C"/>

<!-- 汇聚 -->
<parallelGateway id="Gateway_Join" name="等待所有"/>
<sequenceFlow sourceRef="Task_A" targetRef="Gateway_Join"/>
<sequenceFlow sourceRef="Task_B" targetRef="Gateway_Join"/>
<sequenceFlow sourceRef="Task_C" targetRef="Gateway_Join"/>
```

**规则**:
- ✅ 分支: 所有 outgoing flow 同时激活
- ✅ 汇聚: 等待所有 incoming flow 到达
- ✅ 不需要条件表达式
- ✅ Fork 和 Join 必须成对使用

#### 4.3 Inclusive Gateway (OR)

```xml
<inclusiveGateway id="Gateway_MultiChoice" name="选择服务" default="Flow_Basic"/>

<sequenceFlow id="Flow_Premium" name="高级服务" sourceRef="Gateway_MultiChoice" targetRef="Task_Premium">
  <conditionExpression>${premiumSelected == true}</conditionExpression>
</sequenceFlow>

<sequenceFlow id="Flow_Standard" name="标准服务" sourceRef="Gateway_MultiChoice" targetRef="Task_Standard">
  <conditionExpression>${standardSelected == true}</conditionExpression>
</sequenceFlow>

<sequenceFlow id="Flow_Basic" name="基础服务" sourceRef="Gateway_MultiChoice" targetRef="Task_Basic"/>

<!-- 汇聚 -->
<inclusiveGateway id="Gateway_Merge" name="汇总"/>
<sequenceFlow sourceRef="Task_Premium" targetRef="Gateway_Merge"/>
<sequenceFlow sourceRef="Task_Standard" targetRef="Gateway_Merge"/>
<sequenceFlow sourceRef="Task_Basic" targetRef="Gateway_Merge"/>
```

**规则**:
- ✅ 可以激活一条或多条流
- ✅ 必须有 `default` 默认流
- ✅ 其他流必须有条件表达式
- ✅ 汇聚时: 等待所有被激活的分支

#### 4.4 Event-Based Gateway (事件网关)

```xml
<eventBasedGateway id="Gateway_Event" name="等待事件"/>

<!-- 等待消息或超时 -->
<intermediateCatchEvent id="Event_Message" name="收到消息">
  <messageEventDefinition messageRef="Message_Response"/>
</intermediateCatchEvent>

<intermediateCatchEvent id="Event_Timeout" name="2小时超时">
  <timerEventDefinition>
    <timeDuration>PT2H</timeDuration>
  </timerEventDefinition>
</intermediateCatchEvent>

<sequenceFlow sourceRef="Gateway_Event" targetRef="Event_Message"/>
<sequenceFlow sourceRef="Gateway_Event" targetRef="Event_Timeout"/>
```

**规则**:
- ✅ outgoing flow 必须指向 Intermediate Catch Event 或 Receive Task
- ✅ 第一个到达的事件激活对应流程
- ✅ 其他分支被取消
- ✅ 不能有条件表达式

#### 4.5 Complex Gateway (复杂网关)

```xml
<complexGateway id="Gateway_Complex" name="复杂逻辑">
  <activationCondition>
    ${(route1Complete &amp;&amp; route2Complete) || route3Complete}
  </activationCondition>
</complexGateway>
```

### 5. 连接对象规则

#### 5.1 Sequence Flow (顺序流)

```xml
<!-- 基本顺序流 -->
<sequenceFlow id="Flow_1" sourceRef="Task_1" targetRef="Task_2"/>

<!-- 带名称 -->
<sequenceFlow id="Flow_2" name="批准" sourceRef="Gateway_1" targetRef="Task_Approve"/>

<!-- 带条件 -->
<sequenceFlow id="Flow_3" name="金额 > 1000" sourceRef="Gateway_1" targetRef="Task_Review">
  <conditionExpression xsi:type="tFormalExpression">
    ${amount > 1000}
  </conditionExpression>
</sequenceFlow>

<!-- 默认流 -->
<exclusiveGateway id="Gateway_1" default="Flow_Default"/>
<sequenceFlow id="Flow_Default" sourceRef="Gateway_1" targetRef="Task_Default"/>
```

**规则**:
- ✅ 只能在同一个 Pool 内部
- ✅ 不能跨越 Pool 边界
- ✅ 条件表达式支持: `${expression}` 或脚本

#### 5.2 Message Flow (消息流)

```xml
<!-- 定义消息 -->
<message id="Message_OrderRequest" name="订单请求"/>
<message id="Message_OrderConfirmation" name="订单确认"/>

<!-- Pool A 发送消息 -->
<sendTask id="Task_SendOrder" name="发送订单">
  <messageEventDefinition messageRef="Message_OrderRequest"/>
</sendTask>

<!-- Pool B 接收消息 -->
<receiveTask id="Task_ReceiveOrder" name="接收订单">
  <messageEventDefinition messageRef="Message_OrderRequest"/>
</receiveTask>

<!-- 消息流连接 -->
<messageFlow id="MessageFlow_1" sourceRef="Task_SendOrder" targetRef="Task_ReceiveOrder"/>
```

**规则**:
- ✅ 只能在不同 Pool 之间
- ✅ 不能在同一个 Pool 内部
- ✅ 必须引用 Message 定义
- ✅ 可以连接到: Message Event, Send/Receive Task, Pool 边界

#### 5.3 Association (关联)

```xml
<!-- 数据对象关联 -->
<dataObjectReference id="DataObject_Order" name="订单数据" dataObjectRef="DataObject_1"/>

<task id="Task_ProcessOrder" name="处理订单"/>

<dataInputAssociation id="Association_1">
  <sourceRef>DataObject_Order</sourceRef>
  <targetRef>Task_ProcessOrder</targetRef>
</dataInputAssociation>

<!-- 文本注释关联 -->
<textAnnotation id="TextAnnotation_1">
  <text>此任务需要 2-3 天完成</text>
</textAnnotation>

<association id="Association_2" sourceRef="Task_ProcessOrder" targetRef="TextAnnotation_1"/>
```

### 6. Swimlane 规则

#### 6.1 Pool (池)

```xml
<collaboration id="Collaboration_1">
  <!-- Pool 1 -->
  <participant id="Participant_Customer" name="客户" processRef="Process_Customer"/>

  <!-- Pool 2 -->
  <participant id="Participant_System" name="系统" processRef="Process_System"/>

  <!-- Black Box Pool (不显示内部流程) -->
  <participant id="Participant_ExternalAPI" name="外部 API"/>

  <!-- 消息流 -->
  <messageFlow id="MessageFlow_1" sourceRef="Task_SendRequest" targetRef="Participant_ExternalAPI"/>
</collaboration>

<process id="Process_Customer" isExecutable="false">
  <task id="Task_SendRequest" name="发送请求"/>
</process>

<process id="Process_System" isExecutable="false">
  <task id="Task_ProcessRequest" name="处理请求"/>
</process>
```

**规则**:
- ✅ 代表一个参与者 (组织、系统、角色)
- ✅ 必须通过 `processRef` 引用 Process
- ✅ Black Box Pool: 不指定 `processRef`
- ✅ Pool 之间用 Message Flow 连接

#### 6.2 Lane (泳道)

```xml
<process id="Process_OrderFulfillment">
  <laneSet id="LaneSet_1">
    <!-- 销售部门 -->
    <lane id="Lane_Sales" name="销售部">
      <flowNodeRef>Task_CreateOrder</flowNodeRef>
      <flowNodeRef>Task_SendInvoice</flowNodeRef>
    </lane>

    <!-- 仓库部门 -->
    <lane id="Lane_Warehouse" name="仓库">
      <flowNodeRef>Task_PickItems</flowNodeRef>
      <flowNodeRef>Task_PackOrder</flowNodeRef>
    </lane>

    <!-- 物流部门 -->
    <lane id="Lane_Shipping" name="物流">
      <flowNodeRef>Task_ShipOrder</flowNodeRef>
    </lane>
  </laneSet>

  <!-- Flow Objects -->
  <task id="Task_CreateOrder" name="创建订单"/>
  <task id="Task_PickItems" name="拣货"/>
  <task id="Task_PackOrder" name="打包"/>
  <task id="Task_ShipOrder" name="发货"/>
  <task id="Task_SendInvoice" name="发送发票"/>
</process>
```

**规则**:
- ✅ Lane 必须在 LaneSet 中定义
- ✅ 用 `flowNodeRef` 指定包含的 Flow Objects
- ✅ Lane 可以嵌套 (Sub-Lane)
- ✅ 一个 Flow Object 只能属于一个 Lane

### 7. 数据对象规则

```xml
<!-- 数据对象定义 -->
<dataObject id="DataObject_1"/>

<!-- 数据对象引用 -->
<dataObjectReference id="DataObject_Order" name="订单" dataObjectRef="DataObject_1"/>

<!-- 数据集合 -->
<dataObjectReference id="DataObject_Orders" name="订单列表" dataObjectRef="DataObject_1">
  <dataState name="已提交"/>
</dataObjectReference>

<!-- 数据存储 -->
<dataStoreReference id="DataStore_Database" name="订单数据库"/>

<!-- 数据输入关联 -->
<task id="Task_1" name="任务1"/>
<dataInputAssociation>
  <sourceRef>DataObject_Order</sourceRef>
  <targetRef>Task_1</targetRef>
</dataInputAssociation>

<!-- 数据输出关联 -->
<dataOutputAssociation>
  <sourceRef>Task_1</sourceRef>
  <targetRef>DataObject_Order</targetRef>
</dataOutputAssociation>
```

---

## 📏 图形规则 (BPMN DI)

### 1. 形状定义

```xml
<bpmndi:BPMNShape id="Shape_Task_1" bpmnElement="Task_1">
  <dc:Bounds x="200" y="100" width="100" height="80"/>
  <bpmndi:BPMNLabel>
    <dc:Bounds x="220" y="120" width="60" height="20"/>
  </bpmndi:BPMNLabel>
</bpmndi:BPMNShape>
```

**标准尺寸**:
- Task / Sub-Process: 100x80
- Event (Start/End): 36x36
- Intermediate Event: 36x36
- Gateway: 50x50
- Pool: 任意宽度, 最小高度 150
- Lane: 继承 Pool 宽度, 高度可变

### 2. 边定义

```xml
<bpmndi:BPMNEdge id="Edge_Flow_1" bpmnElement="Flow_1">
  <di:waypoint x="150" y="140"/>
  <di:waypoint x="200" y="140"/>
  <bpmndi:BPMNLabel>
    <dc:Bounds x="165" y="125" width="20" height="14"/>
  </bpmndi:BPMNLabel>
</bpmndi:BPMNEdge>
```

**规则**:
- `waypoint`: 至少 2 个点 (起点和终点)
- 可以有多个中间点定义折线
- `BPMNLabel`: 可选，定义标签位置

---

## 📋 验证规则检查清单

### 必须遵守

- [ ] 所有 ID 唯一
- [ ] Start Event 无 incoming flow
- [ ] End Event 无 outgoing flow
- [ ] Gateway 有多个 outgoing/incoming
- [ ] Exclusive/Inclusive Gateway 有 default flow
- [ ] Message Flow 仅在不同 Pool 间
- [ ] Sequence Flow 仅在同一 Pool 内
- [ ] Boundary Event 附加到 Activity
- [ ] flowNodeRef 引用的元素存在
- [ ] bpmnElement 引用的元素存在

### 推荐做法

- [ ] 为所有元素添加 name 属性
- [ ] 使用清晰的 ID 命名规则
- [ ] 添加 documentation 元素
- [ ] 使用 Text Annotation 添加说明
- [ ] 合理划分 Lane 和 Pool
- [ ] 复杂流程使用 Sub-Process

---

**文档更新**: 2025-10-13
**参考来源**: OMG BPMN 2.0 Specification, bpmn.io Documentation
