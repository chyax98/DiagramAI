
# SeqDiag Sequence 生成要求

## 图表类型：时序图（Sequence Diagram - BlockDiag风格）

SeqDiag时序图用于展示对象间消息传递序列，采用BlockDiag简化语法。

## 核心语法

### 基础时序图
```
seqdiag {
  // 调用使用 -> (实线)
  Client -> Server [label = "request"];
  Server -> Database [label = "query"];

  // 返回使用 <-- (虚线,方向相反)
  Server <-- Database [label = "data"];
  Client <-- Server [label = "response"];
}
```

**语法要点**：
- `->` 表示请求消息（实线箭头）
- `<--` 表示返回消息（虚线箭头，方向相反）
- `[label = "..."]` 定义消息标签

## 生成示例

### 示例 1: 用户登录流程（简单场景）
**用户需求**：展示用户登录的消息交互

**生成代码**：
```
seqdiag {
  // 定义对象
  User; WebApp; AuthService; Database;

  // 消息序列
  User -> WebApp [label = "输入用户名密码"];
  WebApp -> AuthService [label = "验证请求"];
  AuthService -> Database [label = "查询用户"];
  AuthService <-- Database [label = "用户数据"];
  WebApp <-- AuthService [label = "JWT Token"];
  User <-- WebApp [label = "登录成功"];
}
```

**关键点**：
- 四个参与对象
- 请求消息使用 `->`
- 返回消息使用 `<--`（方向相反）
- 消息标签清晰描述交互内容

### 示例 1.5: 使用 Auto-Return 简化代码
**用户需求**：简化请求-响应代码，避免手写返回箭头

**生成代码**：
```
seqdiag {
  // 对象定义
  Client; Server; Cache;

  // 使用 => 自动生成返回箭头
  Client => Server [label = "请求数据", return = "响应数据"];

  // 嵌套调用(一层)
  Client => Server [label = "复杂请求"] {
    Server => Cache [label = "查询缓存", return = "缓存数据"];
  }
}
```

**关键点**：
- `=>` 箭头会自动生成虚线返回箭头
- 使用 `return` 属性定义返回消息标签
- 支持一层嵌套，内部调用在外部调用期间执行
- **适用场景**：同步调用-返回模式，减少代码行数

### 示例 2: 电商下单流程（中等复杂度）
**用户需求**：展示电商下单的完整交互流程

**生成代码**：
```
seqdiag {
  // 对象定义
  Customer; WebUI; OrderService; InventoryService; PaymentService; Database;

  // 下单流程
  Customer -> WebUI [label = "提交订单"];
  WebUI -> OrderService [label = "创建订单"];

  // 检查库存
  OrderService -> InventoryService [label = "检查库存"];
  InventoryService -> Database [label = "查询库存"];
  InventoryService <-- Database [label = "库存数据"];
  OrderService <-- InventoryService [label = "库存充足"];

  // 支付流程
  OrderService -> PaymentService [label = "请求支付"];
  OrderService <-- PaymentService [label = "支付成功"];

  // 扣减库存
  OrderService -> InventoryService [label = "扣减库存"];
  InventoryService -> Database [label = "更新库存"];
  InventoryService <-- Database [label = "更新成功"];
  OrderService <-- InventoryService [label = "库存已扣减"];

  // 返回结果
  WebUI <-- OrderService [label = "订单确认"];
  Customer <-- WebUI [label = "下单成功"];
}
```

**关键点**：
- 六个参与对象
- 清晰展示检查库存→支付→扣减库存的顺序
- 使用 `->` 和 `<--` 区分请求和返回

### 示例 3: 微服务调用链（高级场景）
**用户需求**：展示微服务架构中的服务调用链

**生成代码**：
```
seqdiag {
  // 对象定义
  Client; APIGateway; AuthService; UserService; OrderService; NotificationService;

  // 认证流程
  Client -> APIGateway [label = "API请求 + Token"];
  APIGateway -> AuthService [label = "验证Token"];
  APIGateway <-- AuthService [label = "验证通过"];

  // 业务流程
  APIGateway -> UserService [label = "获取用户信息"];
  APIGateway <-- UserService [label = "用户数据"];

  APIGateway -> OrderService [label = "创建订单"];
  OrderService -> NotificationService [label = "发送通知"];
  OrderService <-- NotificationService [label = "通知已发送"];
  APIGateway <-- OrderService [label = "订单数据"];

  // 返回结果
  Client <-- APIGateway [label = "响应数据"];
}
```

**关键点**：
- API网关作为入口统一认证
- 展示跨服务调用关系
- 包含异步通知流程

### 示例 4: 激活框（对象激活状态）
**用户需求**：标记对象的激活生命周期

**生成代码**：
```
seqdiag {
  // 对象定义
  Client; Server; Database;

  // 设置激活框
  activation = normal;

  // 消息序列
  Client -> Server [label = "查询请求"] {
    Server -> Database [label = "SQL查询"] {
      Database -> Database [label = "执行查询"];
    }
    Server <-- Database [label = "结果集"];
  }
  Client <-- Server [label = "响应数据"];
}
```

**关键点**：
- `activation = normal` 启用激活框
- 嵌套消息块 `{}` 自动创建激活框
- 激活框可视化对象的活动状态
- **适用场景**：展示方法调用的执行期间

### 示例 5: 分隔符和注释
**用户需求**：将复杂交互划分为多个阶段，添加说明

**生成代码**：
```
seqdiag {
  // 对象定义
  User; App; Server; Database;

  === 阶段1: 用户认证 ===
  User -> App [label = "登录"];
  App -> Server [label = "验证"];
  App <-- Server [label = "Token"];

  === 阶段2: 数据操作 ===
  User -> App [label = "查询"];
  App -> Server [label = "查询请求"];
  Server -> Database [label = "SQL"];
  Server <-- Database [label = "数据"];
  App <-- Server [label = "结果"];

  === 阶段3: 退出登录 ===
  User -> App [label = "登出"];
  App -> Server [label = "注销Token"];
  App <-- Server [label = "确认"];
}
```

**关键点**：
- `=== 文本 ===` 添加水平分隔符
- 使用 `//` 添加代码注释
- 分隔符将图表分为逻辑阶段
- **适用场景**：展示多阶段流程（登录→操作→退出）

### 示例 6: 边属性（消息样式）
**用户需求**：区分不同类型的消息（失败、延迟、条件）

**生成代码**：
```
seqdiag {
  // 对象定义
  Client; PaymentGateway; Bank; Notification;

  // 正常支付流程
  Client -> PaymentGateway [label = "支付请求"];
  PaymentGateway -> Bank [label = "授权"] {
    // 模拟网络延迟
    Bank -> Bank [label = "处理", color = orange, style = dashed];
  }
  PaymentGateway <-- Bank [label = "授权成功"];

  // 发送通知（异步）
  PaymentGateway -> Notification [label = "发送邮件", color = blue, style = dotted, note = "异步"];

  // 返回客户端
  Client <-- PaymentGateway [label = "支付成功"];
}
```

**关键点**：
- `color = orange/red/blue` 改变箭头颜色
- `style = dashed/dotted` 改变箭头样式
- `note = "文本"` 添加消息注释
- **适用场景**：区分同步/异步、成功/失败、重要/次要消息

### 示例 7: 全局属性（图表外观）
**用户需求**：统一调整图表样式和布局

**生成代码**：
```
seqdiag {
  // 全局属性
  edge_length = 200;           // 对象间距
  span_height = 40;            // 消息垂直间距
  activation = normal;         // 启用激活框
  default_fontsize = 14;       // 字体大小

  // 对象定义（可以设置对象属性）
  Client [color = lightblue];
  Server [color = lightgreen];
  Database [color = lightyellow];

  // 消息序列
  Client -> Server [label = "请求"];
  Server -> Database [label = "查询"];
  Server <-- Database [label = "数据"];
  Client <-- Server [label = "响应"];
}
```

**关键点**：
- `edge_length` 控制对象水平间距
- `span_height` 控制消息垂直间距
- `default_fontsize` 设置全局字体大小
- 对象可以单独设置 `color` 属性
- **适用场景**：统一调整复杂图表的布局和美观度

### 示例 8: 异步消息和自调用
**用户需求**：展示异步消息和对象自调用

**生成代码**：
```
seqdiag {
  // 对象定义
  Client; WebServer; TaskQueue; Worker; Cache;

  // 同步请求
  Client -> WebServer [label = "提交任务"];

  // 异步消息（发送到队列）
  WebServer -> TaskQueue [label = "入队", style = dotted, color = blue];
  Client <-- WebServer [label = "任务已提交", note = "立即返回"];

  // 后台处理（Worker轮询）
  Worker -> TaskQueue [label = "拉取任务"] {
    // 自调用（对象内部处理）
    Worker -> Worker [label = "处理数据"];
    Worker -> Worker [label = "验证结果"];
  }
  Worker <-- TaskQueue [label = "任务数据"];

  // 缓存结果
  Worker -> Cache [label = "存储结果"];
  Worker <-- Cache [label = "确认"];
}
```

**关键点**：
- `A -> A` 表示自调用（对象内部操作）
- `style = dotted` + `color = blue` 区分异步消息
- `note = "..."` 添加额外说明
- **适用场景**：消息队列、后台任务、对象内部处理

## 常见错误

### 错误 1: 返回箭头方向错误
**❌ 错误写法**：
```
seqdiag {
  Client -> Server [label = "request"];
  Server --> Client [label = "response"];  // 错误：仍然从左到右
}
```

**✅ 正确写法（方式1 - 反向箭头）**：
```
seqdiag {
  Client -> Server [label = "request"];
  Client <-- Server [label = "response"];  // 正确：从右到左
}
```

**✅ 正确写法（方式2 - Auto-Return）**：
```
seqdiag {
  Client => Server [label = "request", return = "response"];
}
```

**原因**：`-->` 只是虚线样式，方向仍然从左到右，不符合返回语义。必须使用 `<--` 反向箭头，或使用 `=>` 自动生成返回消息。

### 错误 2: 消息标签缺失
**❌ 错误写法**：
```
seqdiag {
  A -> B;
  B <-- A;
}
```

**✅ 正确写法**：
```
seqdiag {
  A -> B [label = "请求"];
  A <-- B [label = "响应"];
}
```

**原因**：所有消息都应该定义清晰的标签，否则渲染时消息线为空。

### 错误 3: 返回消息使用实线
**❌ 错误写法**：
```
seqdiag {
  A -> B [label = "request"];
  A <- B [label = "return"];  // 实线反向箭头
}
```

**✅ 正确写法**：
```
seqdiag {
  A -> B [label = "request"];
  A <-- B [label = "return"];  // 虚线反向箭头
}
```

**原因**：返回消息应该使用 `<--` 虚线反向箭头，区分调用和返回。

### 错误 4: 嵌套消息未使用花括号
**❌ 错误写法**：
```
seqdiag {
  Client -> Server [label = "请求"];
  Server -> Database [label = "查询"];
  Server <-- Database [label = "数据"];
  Client <-- Server [label = "响应"];
}
```

**问题**：虽然语法正确，但无法体现 Server→Database 调用发生在 Client→Server 调用期间。

**✅ 正确写法**：
```
seqdiag {
  Client -> Server [label = "请求"] {
    Server -> Database [label = "查询"];
    Server <-- Database [label = "数据"];
  }
  Client <-- Server [label = "响应"];
}
```

**原因**：使用 `{}` 嵌套块可以清晰表示调用发生在某个调用的生命周期内，渲染时自动显示激活框。

### 错误 5: 混用 Auto-Return 和手动返回
**❌ 错误写法**：
```
seqdiag {
  A => B [label = "请求", return = "响应"];
  A <-- B [label = "额外返回"];  // 冗余
}
```

**问题**：`=>` 已经自动生成返回箭头，手动添加返回消息会导致两条返回线。

**✅ 正确写法（二选一）**：
```
// 方式1: 使用 Auto-Return
seqdiag {
  A => B [label = "请求", return = "响应"];
}

// 方式2: 手动返回
seqdiag {
  A -> B [label = "请求"];
  A <-- B [label = "响应"];
}
```

**原因**：选择一种风格并保持一致，不要混用。

## 生成检查清单

### 基础检查（必须）
- [ ] **图表声明**：使用 `seqdiag {}` 包裹
- [ ] **对象定义**：所有参与对象都显式定义（例如 `Client; Server;`）
- [ ] **消息标签**：所有消息都有清晰的 `label`
- [ ] **返回方向**：返回消息使用 `<--`（反向箭头），不是 `-->`
- [ ] **顺序合理**：消息的时间顺序符合业务逻辑
- [ ] **代码可渲染**：语法正确，可直接通过 Kroki 渲染

### 高级检查（推荐）
- [ ] **嵌套调用**：使用 `{}` 块表示嵌套调用关系
- [ ] **激活框**：复杂图表使用 `activation = normal` 显示对象生命周期
- [ ] **分隔符**：多阶段流程使用 `=== 阶段名 ===` 划分
- [ ] **消息样式**：使用 `color` 和 `style` 区分不同类型消息
- [ ] **异步标记**：异步消息使用 `style = dotted, color = blue`
- [ ] **全局属性**：根据需要调整 `edge_length`、`span_height`、`default_fontsize`

**任何基础检查项不通过，立即修正后重新生成**
