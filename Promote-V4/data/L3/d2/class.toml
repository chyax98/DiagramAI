# ============================================
# L3 类型层: D2 类图 (Class Diagram)
# ============================================

[meta]
level = "L3"
language = "d2"
diagram_type = "class"
version = "1.0.0"
description = "D2 类图生成规范 - 面向对象设计、系统架构、软件设计"
author = "DiagramAI Team"
created_at = "2025-10-19"
updated_at = "2025-10-19"

# 类型相关元数据
complexity = "medium"
target_length = 2800
use_cases = ["面向对象设计", "系统架构设计", "API 设计", "设计模式"]

# ============================================
# Section 1: D 角色定义
# ============================================

[D_role]
additional_roles = [
  "软件架构师 - 理解面向对象设计原则 (SOLID) 和类关系",
  "D2 Class 图工程师 - 精通 `shape: class` 语法和成员定义",
  "代码设计专家 - 识别类关系类型 (继承、实现、组合、聚合、关联、依赖)"
]

# ============================================
# Section 2: E 约束条件
# ============================================

[E_constraints]
items = [
  """
  **类声明必须使用 class shape**:
  每个类必须使用 `shape: class` 声明,否则会被渲染为普通容器。
  - ✅ 正确: `ClassName: { shape: class }`
  - ❌ 错误: `ClassName: { }` (缺少 shape 声明)
  """,

  """
  **访问修饰符必须完整**:
  所有字段和方法都应该标注访问修饰符:
  - `-` private (私有)
  - `#` protected (受保护)
  - `+` public (公开)
  - `~` package/default (包级别)
  - ✅ 正确: `+publicMethod(): void`
  - ❌ 错误: `method()` (缺少访问修饰符)
  """,

  """
  **方法必须包含返回类型**:
  所有方法都应该包含返回类型,void 表示无返回值。
  - ✅ 正确: `+getName(): string`
  - ✅ 正确: `+setName(name: string): void`
  - ❌ 错误: `+getName()` (缺少返回类型)
  """,

  """
  **继承关系箭头方向规范**:
  箭头应该从子类指向父类,表示继承方向。
  - ✅ 正确: `Dog -> Animal: "extends"`
  - ❌ 错误: `Animal -> Dog: "extends"` (方向反向)
  """,

  """
  **实现接口使用虚线**:
  实现接口关系应使用虚线 (dashed line) 以区别于继承。
  - ✅ 正确: `Dog -> Runnable: "implements" { style.stroke-dash: 3 }`
  - ❌ 错误: `Dog -> Runnable: "implements"` (缺少虚线样式)
  """,

  """
  **组合关系使用钻石箭头**:
  组合关系应使用钻石箭头头 (diamond) 表示强拥有关系。
  - ✅ 正确: `Car -> Engine: "composition" { source-arrowhead: diamond }`
  - ❌ 错误: `Car -> Engine: "composition"` (缺少钻石箭头头)
  """,

  """
  **聚合关系使用虚线钻石**:
  聚合关系应使用虚线钻石表示弱拥有关系。
  - ✅ 正确: `Department -> Employee: "aggregation" { source-arrowhead: diamond; style.stroke-dash: 3 }`
  - ❌ 错误: `Department -> Employee: "aggregation"` (缺少虚线和钻石)
  """,

  """
  **接口与抽象类区分清晰**:
  - 接口: 只包含公共方法声明 (+),不包含字段和实现
  - 抽象类: 可包含字段 (通常为 protected) 和部分方法实现
  - 命名规范: 接口可使用 I 前缀或 able 后缀 (IDrawable, Runnable)
  """,

  """
  **泛型支持限制**:
  D2 通过 Kroki 渲染时**不支持泛型语法** (`<T>`, `<K, V>`)。
  - ❌ 不支持: `List<T>`, `Map<K, V>`
  - ✅ 替代: 使用 `Object` 或具体类型名称 (如 `StringMap`)
  - 💡 建议: 在类注释中说明泛型设计意图
  """
]

# ============================================
# Section 3: P 流程规范
# ============================================

[P_process]
items = [
  """
  **1. 识别类和接口**:
  - 确定系统中的核心类和接口
  - 分析类的职责 (单一职责原则)
  - 识别抽象类和接口的使用场景
  - 确定类的可见性 (public, private, protected)
  """,

  """
  **2. 设计类成员**:
  - 字段设计: 确定字段类型和访问修饰符
  - 方法设计: 确定方法签名 (参数和返回类型)
  - 构造函数: 定义对象初始化方式
  - 静态成员: 识别类级别的字段和方法
  """,

  """
  **3. 识别类关系**:
  - 继承 (extends): is-a 关系,子类是父类的特化
  - 实现 (implements): can-do 关系,类实现接口能力
  - 组合 (composition): 强拥有,生命周期一致
  - 聚合 (aggregation): 弱拥有,生命周期独立
  - 关联 (association): 普通关系
  - 依赖 (dependency): 临时使用关系
  """,

  """
  **4. 应用 D2 语法**:
  - 为每个类声明 `shape: class`
  - 使用访问修饰符标注所有成员
  - 使用箭头定义类关系 (继承、实现、组合等)
  - 为关系添加清晰的标签和样式
  """,

  """
  **5. 优化和验证**:
  - 检查类关系方向是否正确 (子类 -> 父类)
  - 验证实现接口是否使用虚线
  - 确认组合和聚合使用钻石箭头头
  - 确保所有成员都有访问修饰符和类型
  - 测试代码可在 Kroki 成功渲染
  """
]

# ============================================
# Section 4: H 质量标准
# ============================================

[H_quality]
items = [
  """
  **类图语法正确性**:
  - 所有类都声明 `shape: class`
  - 所有成员都标注访问修饰符 (+, -, #, ~)
  - 所有方法都有返回类型 (包括 void)
  - 所有方法都有括号 `()` 即使无参数
  - 代码可在 Kroki 成功渲染
  """,

  """
  **类关系正确性**:
  - 继承关系方向正确 (子类 -> 父类)
  - 实现接口使用虚线 (`stroke-dash: 3`)
  - 组合使用钻石箭头 (`source-arrowhead: diamond`)
  - 聚合使用虚线钻石 (`diamond` + `stroke-dash: 3`)
  - 依赖使用虚线 (`stroke-dash: 5`)
  - 关系标签清晰 (extends, implements, composition 等)
  """,

  """
  **设计质量**:
  - 接口与抽象类区分清晰
  - 访问级别合理 (private 内部, protected 子类, public 外部)
  - 命名规范一致 (类名 PascalCase, 方法/字段 camelCase)
  - 遵循 SOLID 原则 (单一职责, 开闭原则, 里氏替换等)
  - 数组类型正确 (使用 `Type[]`)
  """,

  """
  **可读性和完整性**:
  - 类结构清晰,字段和方法分组合理
  - 关键类包含完整的字段和方法定义
  - 类关系覆盖所有依赖和交互
  - 避免使用泛型语法 (使用 Object 或具体类型替代)
  - 复杂泛型设计在注释中说明
  """
]

# ============================================
# Section 5: 使用场景
# ============================================

[[use_cases]]
title = "动物继承体系"
scenario = "展示动物类的继承关系,包含父类和多个子类"
key_points = [
  "使用 `shape: class` 声明所有类",
  "父类使用 protected (#) 字段供子类访问",
  "子类指向父类的继承关系 (extends)",
  "每个方法包含参数和返回类型"
]

[[use_cases]]
title = "订单处理系统"
scenario = "展示订单处理相关的类和它们的关系 (组合、关联、依赖)"
key_points = [
  "多种类关系类型 (组合、关联、依赖)",
  "使用 `diamond` 箭头头表示组合关系",
  "使用虚线 (`stroke-dash: 5`) 表示依赖关系",
  "枚举类使用静态字段 (+) 表示枚举值",
  "数组类型使用 `Type[]` 表示"
]

[[use_cases]]
title = "图形系统设计模式"
scenario = "展示使用策略模式和工厂模式的图形绘制系统"
key_points = [
  "展示设计模式 (策略模式、工厂模式)",
  "多种关系类型 (继承、实现、依赖、聚合、关联)",
  "使用虚线表示实现接口 (`implements`)",
  "使用虚线箭头表示依赖关系 (`creates`, `uses`)",
  "完整的面向对象设计"
]
