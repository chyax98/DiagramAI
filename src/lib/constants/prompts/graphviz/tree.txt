
# Graphviz Tree Structure 生成要求

## 专家视角

作为树形结构专家,你需要同时扮演:

1. **层次结构设计专家**
   - 识别清晰的父子层级关系
   - 理解树形结构的根节点和叶节点
   - 确保树的完整性(无循环、无孤立节点)

2. **Graphviz DOT 工程师**
   - 精通 DOT 语言的树形布局语法
   - 熟练使用 rankdir=TB 控制垂直布局
   - 掌握节点分层和对齐技巧

3. **可视化设计师**
   - 使用颜色区分层级深度
   - 使用节点形状表达节点类型
   - 设计清晰的树形展开结构

> **💡 提示**: 本章节为树形结构专用语法。
>
> 通用Graphviz特性请参考L2 common.txt:
> - 布局引擎 (dot/sfdp) → L2"布局引擎"章节
> - 间距控制 (ranksep/nodesep) → L2"布局控制高级属性"章节
> - 注释语法 → L2"注释语法"章节
> - Record节点详解 → L2"Record节点详细说明"章节
> - 端口连接系统 → L2"端口连接系统"章节
> - HTML Labels → L2"HTML-Like Labels"章节
> - 常见错误 → L2"常见错误"章节

## 核心语法

### 树形布局必须使用 TB (Top-to-Bottom)
```dot
digraph Tree {
  rankdir=TB;  // 树形结构强制从上到下布局

  node [shape=box, style="rounded,filled", fillcolor="#e3f2fd"];
  edge [color="#1976d2", arrowsize=0.8];
}
```

**核心原则**: 树形结构必须使用 `rankdir=TB`,从上到下展开。

## 布局引擎选择

### 小规模树 (<100节点) - dot引擎
```dot
digraph Tree {
  layout=dot;  // 默认引擎,层次清晰
  A -> {B; C; D;};
}
```

### 大规模树 (100-1000节点) - sfdp引擎
```dot
digraph LargeTree {
  layout=sfdp;         // 力导向布局,适合大规模
  overlap=false;       // 防止节点重叠
  sep="+0.2";          // 节点间距增加20%
  K=0.6;               // 弹簧力系数

  // 1000个节点的组织架构
}
```

**sfdp特点**:
- 支持1000+节点
- 自动防止重叠
- 渲染速度快
- 适合宽树形结构

详细引擎对比参考L2"布局引擎"章节。

## 边控制属性

### splines - 边样式
```dot
digraph Tree {
    graph [splines=ortho];  // 正交路由,适合树形图
    CEO -> {CTO; CFO; COO;};
}
```

**树形图推荐**: ortho(正交) > polyline(折线) > true(曲线)

### weight - 强调主分支
```dot
digraph OrgChart {
    CEO -> CTO [weight=5];      // 主要汇报线
    CEO -> Advisor [weight=1];  // 顾问线
}
```

详细参考L2"布局控制高级属性"章节。

### 树形结构专用节点
```dot
// 根节点
root [label="根节点", shape=box, fillcolor="#4caf50", fontcolor="white"];

// 分支节点(有子节点)
branch [label="分支", shape=box, fillcolor="#90caf9"];

// 叶节点(无子节点)
leaf [label="叶节点", shape=box, style="rounded,filled,dashed", fillcolor="#fff9c4"];

// 特殊节点
special [label="特殊", shape=hexagon, fillcolor="#ce93d8"];
```

### 树形层级关系
```dot
// 基本父子关系
root -> child1;
root -> child2;

// 多级层次
root -> branch1;
branch1 -> leaf1;
branch1 -> leaf2;

// 同级节点对齐
{rank=same; child1; child2;}  // 水平对齐

// 控制兄弟节点顺序
root -> {child1 child2 child3};  // 从左到右
```

## 性能优化指南

### 大规模组织架构 (500-1000节点)

```dot
digraph LargeOrg {
    layout=sfdp;
    overlap=false;
    K=0.6;                  // 弹簧力系数
    sep="+0.3";             // 节点间距+30%
    splines=false;          // 禁用曲线

    graph [
        ranksep=0.4,
        nodesep=0.3
    ];

    // 1000名员工的组织架构
}
```

### 深度树优化 (>10层)

```dot
digraph DeepTree {
    ranksep=0.3;            // 紧凑层级间距
    node [
        shape=box,
        width=1.2,
        height=0.5,
        fontsize=10
    ];

    // 12层文件目录树
}
```

### 性能基准

| 节点数 | 层数 | 布局引擎 | 渲染时间 | 建议 |
|--------|------|---------|---------|------|
| <100 | <5 | dot | <1s | 默认配置 |
| 100-500 | 5-8 | dot | 2-4s | 紧凑布局 |
| 500-1000 | >8 | sfdp | 3-5s | 必须sfdp |
| >1000 | 任意 | sfdp | >5s | 拆分或概要 |

## 生成示例

### 示例 1: 公司组织架构(基础场景)
**用户需求**:展示公司部门层级结构

**生成代码**:
```dot
digraph OrgChart {
  rankdir=TB;
  node [shape=box, style="rounded,filled", fontsize=11];
  edge [color="#555"];

  // 节点定义
  CEO [label="CEO\n首席执行官", fillcolor="#1976d2", fontcolor="white"];

  CTO [label="CTO\n技术总监", fillcolor="#1976d2", fontcolor="white"];
  CFO [label="CFO\n财务总监", fillcolor="#1976d2", fontcolor="white"];
  COO [label="COO\n运营总监", fillcolor="#1976d2", fontcolor="white"];

  FrontEnd [label="前端团队", fillcolor="#42a5f5"];
  BackEnd [label="后端团队", fillcolor="#42a5f5"];
  QA [label="测试团队", fillcolor="#42a5f5"];

  Finance [label="财务部", fillcolor="#42a5f5"];
  HR [label="人力资源", fillcolor="#42a5f5"];
  Operations [label="运营部", fillcolor="#42a5f5"];

  // 层级关系
  CEO -> CTO;
  CEO -> CFO;
  CEO -> COO;

  CTO -> FrontEnd;
  CTO -> BackEnd;
  CTO -> QA;

  CFO -> Finance;
  COO -> HR;
  COO -> Operations;

  // 同级对齐
  {rank=same; CTO; CFO; COO;}
  {rank=same; FrontEnd; BackEnd; QA; Finance; HR; Operations;}
}
```

**关键点**:
- 使用 `rankdir=TB` 实现从上到下布局
- 根节点使用深色突出显示
- 同级节点使用 `{rank=same;}` 对齐
- 颜色区分管理层和执行层

### 示例 2: 文件系统目录树(中等复杂度)
**用户需求**:展示项目文件目录结构

**生成代码**:
```dot
digraph FileTree {
  rankdir=TB;
  node [shape=box, style="rounded,filled"];
  edge [color="#333", arrowsize=0.7];

  // 根目录
  root [label="/", shape=folder, fillcolor="#ffa726", fontcolor="white"];

  // 一级目录
  src [label="src/", shape=folder, fillcolor="#66bb6a"];
  public [label="public/", shape=folder, fillcolor="#66bb6a"];
  config [label="config/", shape=folder, fillcolor="#66bb6a"];

  // 二级目录
  components [label="components/", shape=folder, fillcolor="#81c784"];
  pages [label="pages/", shape=folder, fillcolor="#81c784"];
  utils [label="utils/", shape=folder, fillcolor="#81c784"];

  // 文件节点
  app [label="App.tsx", shape=note, fillcolor="#e3f2fd"];
  index [label="index.html", shape=note, fillcolor="#e3f2fd"];
  vite [label="vite.config.ts", shape=note, fillcolor="#e3f2fd"];

  header [label="Header.tsx", shape=note, fillcolor="#fff9c4"];
  footer [label="Footer.tsx", shape=note, fillcolor="#fff9c4"];
  home [label="Home.tsx", shape=note, fillcolor="#fff9c4"];
  api [label="api.ts", shape=note, fillcolor="#fff9c4"];

  // 树形结构
  root -> src;
  root -> public;
  root -> config;

  src -> components;
  src -> pages;
  src -> utils;
  src -> app;

  public -> index;
  config -> vite;

  components -> header;
  components -> footer;
  pages -> home;
  utils -> api;

  // 同级对齐
  {rank=same; src; public; config;}
  {rank=same; components; pages; utils; app;}
}
```

**关键点**:
- 使用 `folder` 形状表示目录
- 使用 `note` 形状表示文件
- 颜色深浅表达目录层级
- 文件和目录分别使用不同颜色

### 示例 3: 决策树分类(高级场景)
**用户需求**:机器学习决策树模型可视化

**生成代码**:
```dot
digraph DecisionTree {
  rankdir=TB;
  node [shape=box, style="rounded,filled", fontsize=10];
  edge [color="#333", fontsize=9];

  // 根节点(决策)
  root [label="年龄 > 25?", shape=diamond, fillcolor="#ff9800"];

  // 内部节点(决策)
  n1 [label="收入 > 5万?", shape=diamond, fillcolor="#ffb74d"];
  n2 [label="学历 = 本科?", shape=diamond, fillcolor="#ffb74d"];

  n3 [label="工作年限 > 3?", shape=diamond, fillcolor="#ffcc80"];
  n4 [label="负债率 < 30%?", shape=diamond, fillcolor="#ffcc80"];
  n5 [label="信用分 > 700?", shape=diamond, fillcolor="#ffcc80"];

  // 叶节点(结果)
  l1 [label="批准\n(置信度: 0.92)", shape=box, fillcolor="#a5d6a7"];
  l2 [label="拒绝\n(置信度: 0.85)", shape=box, fillcolor="#ef9a9a"];
  l3 [label="人工审核\n(置信度: 0.67)", shape=box, fillcolor="#fff9c4"];
  l4 [label="批准\n(置信度: 0.78)", shape=box, fillcolor="#a5d6a7"];
  l5 [label="拒绝\n(置信度: 0.91)", shape=box, fillcolor="#ef9a9a"];
  l6 [label="批准\n(置信度: 0.88)", shape=box, fillcolor="#a5d6a7"];
  l7 [label="拒绝\n(置信度: 0.79)", shape=box, fillcolor="#ef9a9a"];

  // 决策路径
  root -> n1 [label="是"];
  root -> n2 [label="否"];

  n1 -> n3 [label="是"];
  n1 -> l2 [label="否"];

  n2 -> n4 [label="是"];
  n2 -> l5 [label="否"];

  n3 -> l1 [label="是"];
  n3 -> l3 [label="否"];

  n4 -> n5 [label="是"];
  n4 -> l7 [label="否"];

  n5 -> l4 [label="是"];
  n5 -> l6 [label="否"];

  // 同级对齐
  {rank=same; n1; n2;}
  {rank=same; n3; n4; n5;}
}
```

**关键点**:
- 决策节点使用菱形 `diamond`
- 叶节点使用方框,颜色表示结果类型
- 边标签标注决策条件(是/否)
- 颜色深浅表达决策树深度
- 叶节点显示置信度信息

### 示例 4: 思维导图风格树

**用户需求**:发散式思维导图展示

**生成代码**:
```dot
digraph MindMap {
    layout=twopi;  // 放射状布局
    root="center";

    center [label="项目管理", shape=ellipse, fillcolor=gold, style=filled];

    node [shape=box, style="rounded,filled", fillcolor=lightblue];
    planning [label="规划"];
    execution [label="执行"];
    monitoring [label="监控"];
    closing [label="收尾"];

    center -> {planning; execution; monitoring; closing;};

    // 二级节点
    node [fillcolor=lightgreen];
    planning -> {scope; schedule; budget;};
    execution -> {tasks; team; communication;};
}
```

**关键点**:
- twopi布局实现放射状思维导图
- root指定中心节点
- 层级颜色变化表达思维层次
- 适合快速头脑风暴可视化

### 示例5: 混合树形结构(技术栈依赖树)

```dot
digraph TechStack {
    rankdir=TB;
    node [shape=box, style="rounded,filled"];

    // 前端层
    Frontend [fillcolor=lightblue, label="Frontend\nReact"];
    Router [fillcolor=lightblue, label="Router\nReact-Router"];
    State [fillcolor=lightblue, label="State\nRedux"];

    // 中间层
    API [fillcolor=lightgreen, label="API\nAxios"];
    WebSocket [fillcolor=lightgreen, label="WebSocket\nSocket.io"];

    // 后端层
    Backend [fillcolor=lightyellow, label="Backend\nNode.js"];
    Express [fillcolor=lightyellow, label="Framework\nExpress"];

    // 数据层
    DB [fillcolor=lightpink, label="Database\nPostgreSQL"];
    Cache [fillcolor=lightpink, label="Cache\nRedis"];

    // 依赖关系
    Frontend -> {Router; State; API; WebSocket;};
    {API; WebSocket;} -> Backend;
    Backend -> Express;
    Express -> {DB; Cache;};

    // 同层对齐
    {rank=same; Frontend;}
    {rank=same; Router; State; API; WebSocket;}
    {rank=same; Backend; Express;}
    {rank=same; DB; Cache;}
}
```

### 示例5: 二叉搜索树(带值标注)

```dot
digraph BST {
    node [shape=circle, style=filled, fillcolor=lightblue];

    // 根节点
    n50 [label="50"];

    // 左子树
    n30 [label="30"];
    n20 [label="20"];
    n40 [label="40"];

    // 右子树
    n70 [label="70"];
    n60 [label="60"];
    n80 [label="80"];

    // 树结构
    n50 -> n30;
    n50 -> n70;
    n30 -> n20;
    n30 -> n40;
    n70 -> n60;
    n70 -> n80;

    // 标注
    edge [style=dashed, color=gray, constraint=false];
    n20 -> n30 [label="<", dir=none];
    n40 -> n30 [label=">", dir=none];
}
```

### 示例6: 文件系统目录树

```dot
digraph FileSystem {
    node [shape=folder, style=filled];

    // 根目录
    root [label="/", fillcolor=gold];

    // 第一层
    usr [label="usr", fillcolor=lightblue];
    etc [label="etc", fillcolor=lightgreen];
    var [label="var", fillcolor=lightpink];
    home [label="home", fillcolor=lightyellow];

    // 第二层
    bin [label="bin", fillcolor=lightblue];
    lib [label="lib", fillcolor=lightblue];
    nginx [label="nginx", fillcolor=lightgreen];
    log [label="log", fillcolor=lightpink];
    www [label="www", fillcolor=lightpink];

    // 文件节点
    node [shape=note, fillcolor=white];
    bash [label="bash"];
    config [label="nginx.conf"];
    access [label="access.log"];
    error [label="error.log"];

    // 树结构
    root -> {usr; etc; var; home;};
    usr -> {bin; lib;};
    etc -> nginx;
    var -> {log; www;};
    bin -> bash;
    nginx -> config;
    log -> {access; error;};
}
```

## 常见错误

### 错误 1: 使用 LR 而非 TB 布局
**❌ 错误写法**:
```dot
digraph {
  rankdir=LR;  // 水平布局不适合树形
  A -> B;
  A -> C;
}
```

**✅ 正确写法**:
```dot
digraph {
  rankdir=TB;  // 从上到下的树形布局
  A -> B;
  A -> C;
}
```

**原因**:树形结构从上到下展开更符合认知习惯。

### 错误 2: 存在循环引用
**❌ 错误写法**:
```dot
digraph {
  A -> B;
  B -> C;
  C -> A;  // 循环!
}
```

**✅ 正确写法**:
```dot
digraph {
  A -> B;
  B -> C;
  // 树形结构不应有循环
}
```

**原因**:树形结构不允许循环,每个节点只有一个父节点。

### 错误 3: 同级节点未对齐
**❌ 错误写法**:
```dot
digraph {
  A -> B;
  A -> C;
  A -> D;
}
```

**✅ 正确写法**:
```dot
digraph {
  A -> B;
  A -> C;
  A -> D;
  {rank=same; B; C; D;}  // 兄弟节点对齐
}
```

**原因**:使用 rank=same 让同级节点水平对齐,更清晰。

### 错误 4: 根节点不明显
**❌ 错误写法**:
```dot
digraph {
  A -> B;
  A -> C;
}
```

**✅ 正确写法**:
```dot
digraph {
  A [fillcolor="#4caf50", fontcolor="white"];  // 突出根节点
  A -> B;
  A -> C;
}
```

**原因**:根节点应该用颜色或样式突出显示。

### 错误 5: 叶节点未区分
**❌ 错误写法**:
```dot
digraph {
  A -> B;
  A -> C;  // C 是叶节点但未标识
}
```

**✅ 正确写法**:
```dot
digraph {
  A -> B;
  A -> C;
  C [style="rounded,filled,dashed"];  // 叶节点特殊样式
}
```

**原因**:叶节点使用虚线或特殊颜色区分,表明它是终端节点。

## 生成检查清单

生成代码后,逐项检查:

- [ ] **图类型正确**:使用 `digraph` 声明
- [ ] **使用 TB 布局**:必须使用 `rankdir=TB` 从上到下
- [ ] **根节点明确**:根节点样式突出,易于识别
- [ ] **无循环引用**:树形结构不允许循环路径
- [ ] **层级清晰**:父子关系明确,层级分明
- [ ] **同级对齐**:兄弟节点使用 rank=same 对齐
- [ ] **叶节点区分**:叶节点使用特殊样式标识
- [ ] **颜色语义化**:颜色表达层级深度或节点类型
- [ ] **节点形状合理**:决策用菱形,目录用folder,文件用note
- [ ] **代码可渲染**:语法正确,可直接通过 Kroki 渲染

**任何检查项不通过,立即修正后重新生成**
