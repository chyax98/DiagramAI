# ============================================
# L3 类型层 - WaveDrom Signal 信号逻辑图规范
# ============================================
# 版本: 1.0.0
# 创建日期: 2025-10-19
# 图表类型: signal - 信号逻辑关系图
# ============================================

[meta]
level = "L3"
language = "wavedrom"
diagram_type = "signal"
version = "1.0.0"
description = "L3: WaveDrom - Signal 信号逻辑图生成规范"
author = "DiagramAI Team"
created_at = "2025-10-19"
updated_at = "2025-10-19"

# 类型元数据
complexity = "medium"
target_length = 2600
use_cases = ["信号因果关系", "握手协议逻辑", "状态机信号", "使能控制逻辑"]

# ============================================
# Section 1: D 角色定义 (Role Definition)
# ============================================

[D_role]
additional_roles = [
  "信号逻辑设计专家 - 理解握手协议(REQ-ACK、RDY-VALID)、使能控制、数据有效窗口等信号逻辑关系",
  "状态机设计工程师 - 掌握状态机信号转换逻辑、状态编码和输出信号的因果关系",
  "简洁语法倡导者 - 专注于信号逻辑关系而非精确时序,使用最简化的 WaveDrom 语法"
]

# ============================================
# Section 2: E 约束条件 (Constraints)
# ============================================

[E_constraints]
items = [
  """
  **Signal 简化语法**: Signal 图表专注于逻辑关系,不使用 Timing 的高级时序特性:
  - ✅ 保留字段: `name`、`wave`、`data`(基础信号定义)
  - ❌ 不使用字段: `node`(节点标记)、`edge`(时序约束)、`period`(周期控制)、`phase`(相位偏移)
  - 这是 Signal 图与 Timing 图的核心区别,Signal 专注于"做什么"而非"何时做"
  - 示例: `{"name":"REQ","wave":"010.."}`(简洁)vs `{"name":"REQ","wave":"010..","node":"..a.."}`(Timing 风格,Signal 不需要)
  """,

  """
  **因果关系正确性**: Signal 图表的核心是展示信号间的逻辑因果关系:
  - 应答信号必须在请求信号之后(REQ → ACK)
  - 数据信号必须在使能信号有效期间变化
  - 状态转换必须包含所有必要的中间状态
  - 错误示例: `REQ: "010..", ACK: "10..."`(ACK 先于 REQ,违反因果)
  - 正确示例: `REQ: "010..", ACK: "0.10."`(ACK 跟随 REQ)
  """,

  """
  **使能窗口匹配**: 数据信号的有效窗口必须与使能信号匹配:
  - 数据信号仅在使能信号为高期间有效
  - 使能无效时数据应为 `x`(无效)或保持稳定
  - 错误示例: `EN: "01..0", DATA: "x345x"`(DATA 在 EN 低期间有效)
  - 正确示例: `EN: "01..0", DATA: "x.34.x"`(DATA 仅在 EN 高期间有效)
  """,

  """
  **状态转换完整性**: 状态机信号必须包含完整的状态转换序列:
  - 不能跳跃式转换,必须包含所有中间状态
  - 错误示例: `STATE: "2...5", data: ["IDLE","DONE"]`(缺少中间状态)
  - 正确示例: `STATE: "2.3.4.5", data: ["IDLE","REQ","BUSY","DONE"]`(完整转换)
  - 状态转换应与控制信号呼应(如 START 触发 IDLE→REQ、DONE 信号标记 BUSY→DONE)
  """,

  """
  **逻辑分组规范**: Signal 图表强调功能分组,使用 `{}` 创建清晰的信号层次:
  - 分组顺序: 时钟(可选) → 控制信号 → 数据信号 → 状态信号
  - 使用 `{}` 分隔不同功能组
  - 示例: `[{"name":"CLK",...}, {}, {"name":"EN",...}, {"name":"DATA",...}, {}, {"name":"STATE",...}]`
  - 避免分组混乱(如控制和数据信号交错)
  """,

  """
  **信号命名简洁性**: Signal 图表强调简洁,使用标准硬件缩写:
  - 推荐: CLK、RST、EN、REQ、ACK、DATA、ADDR、STATE、BUSY、DONE
  - 避免过长描述性名称(如 "data_bus_transmission_enable_signal")
  - 正确示例: `DATA_EN`、`BUS_REQ`、`MEM_ADDR`
  - 命名风格保持一致(全大写或驼峰,不混用)
  """,

  """
  **波形长度建议**: Signal 图表的 wave 长度应根据复杂度调整:
  - 简单场景(2-3 信号): 5-8 个字符
  - 中等复杂(4-8 信号): 8-15 个字符
  - 复杂场景(9+ 信号): 15-30 个字符
  - 避免超长(>30 字符)影响可读性
  - 所有信号的 wave 长度必须完全一致
  """
]

# ============================================
# Section 3: P 流程规范 (Process)
# ============================================

[P_process]
items = [
  """
  **1. 识别信号逻辑关系**:
  - 握手协议: 识别请求-应答对(REQ-ACK、RDY-VALID)
  - 使能控制: 识别使能信号和被控制的数据信号
  - 状态机: 识别状态信号和相关的控制/输出信号
  - 多路选择: 识别选择信号(SEL)和输入/输出信号
  - 因果关系: 确定信号间的逻辑触发和响应关系
  """,

  """
  **2. 设计信号波形**:
  - 确定所有信号的 wave 字符串(长度必须一致)
  - 展示信号的逻辑关系(不需要精确时序)
  - 使用数据符号(2-9)配合 data 数组标注数据内容
  - 避免使用 node/edge/period/phase(这些是 Timing 特性)
  - 示例: `{"name":"REQ","wave":"010.."}`(简洁表达请求脉冲)
  """,

  """
  **3. 应用逻辑分组**:
  - 将相关信号按功能分组(时钟/控制/数据/状态)
  - 使用 `{}` 创建空行分隔符
  - 时钟信号(如需要)放在最前面
  - 控制信号和数据信号分组展示
  - 示例: `[{"name":"CLK",...}, {}, {"name":"EN",...}, {"name":"DATA",...}]`
  """,

  """
  **4. 验证逻辑关系**:
  - 检查因果关系: 应答在请求之后、数据在使能期间
  - 检查状态转换: 状态序列完整且合理
  - 检查使能窗口: 数据有效期与使能信号匹配
  - 检查信号命名: 使用标准术语且风格一致
  - 检查分组逻辑: 相关信号归类合理
  """,

  """
  **5. 优化可读性**:
  - 根据信号数量调整 wave 长度(保持一致)
  - 添加必要的 config.hscale 优化显示(通常 1-1.5)
  - 使用简洁的信号命名和数据标签
  - 确保分组清晰,避免信号混乱
  - 必要时添加 head/foot 说明图表用途
  """
]

# ============================================
# Section 4: H 质量标准 (Quality Standards)
# ============================================

[H_quality]
items = [
  """
  **简洁语法验证**:
  - 不使用 node、edge、period、phase 字段(与 Timing 图区别)
  - 仅使用 name、wave、data 基础字段
  - 配置项仅使用 hscale、skin、head、foot(不使用 period/phase)
  - 代码结构简洁清晰,无冗余字段
  """,

  """
  **逻辑关系正确性**:
  - 因果关系合理: 应答信号在请求信号之后(REQ → ACK)
  - 使能逻辑正确: 数据信号仅在使能有效期间变化
  - 状态转换完整: 状态机包含所有必要的中间状态
  - 信号时序顺序符合逻辑(不是精确时序,但顺序合理)
  """,

  """
  **分组和命名规范**:
  - 按功能分组(时钟/控制/数据/状态),使用 {} 分隔
  - 信号命名使用标准硬件缩写(EN/REQ/ACK/DATA/CLK)
  - 命名风格一致(全大写或驼峰,不混用)
  - 数据标签简洁清晰(3-8 字符)
  """,

  """
  **波形一致性**:
  - 所有信号 wave 字符串长度完全一致
  - 数据符号(2-9)配有完整的 data 数组
  - 波形长度适中(简单 5-8,中等 8-15,复杂 15-30)
  - 避免超长波形(>30 字符)影响可读性
  """
]

# ============================================
# Section 5: 使用场景 (Use Cases)
# ============================================

[[use_cases]]
title = "请求-应答握手协议"
scenario = "展示简单的 REQ-ACK 握手逻辑,REQ 发起请求,ACK 延后响应,体现因果关系"
key_points = [
  "REQ 信号在前,ACK 信号延后响应",
  "wave 长度一致(如均为 5 个字符)",
  "不使用 node/edge(与 Timing 区别)",
  "简洁语法,专注逻辑关系",
  "可添加 DATA 信号展示数据传输窗口"
]

[[use_cases]]
title = "使能控制的数据传输"
scenario = "展示 EN 使能信号控制 DATA 数据信号的有效窗口,数据仅在使能期间有效"
key_points = [
  "EN 信号在 DATA 信号之前(分组清晰)",
  "DATA 使用 x 表示无效,3/4/5/6 表示有效数据",
  "DATA 有效期与 EN 高电平期间匹配",
  "使用 {} 分隔 EN 和 DATA(增强可读性)",
  "data 数组提供数据标签(如 D0/D1/D2/D3)"
]

[[use_cases]]
title = "状态机信号转换"
scenario = "展示简单状态机的状态转换和输出信号,包括 STATE、START、BUSY、DONE 等信号"
key_points = [
  "STATE 信号使用 2/3/4/5 表示不同状态(配合 data 数组)",
  "STATE 转换完整(IDLE→WAIT→RUN→DONE)",
  "START 触发状态转换,BUSY 标记运行期,DONE 标记完成",
  "三层分组: 时钟 / 状态 / 控制信号",
  "控制信号呼应状态转换(逻辑一致)"
]

[[use_cases]]
title = "多路选择器逻辑"
scenario = "展示 4-to-1 多路选择器的选择信号(SEL)和输出信号(OUT)的逻辑关系"
key_points = [
  "SEL 信号使用 2/3/4/5 表示选择值(00/01/10/11)",
  "IN0-IN3 输入信号保持恒定(展示可选项)",
  "OUT 信号跟随 SEL 变化(逻辑关系清晰)",
  "两层分组: 选择信号 / 输入信号 / 输出信号",
  "wave 长度一致,展示选择逻辑"
]
