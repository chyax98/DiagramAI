# SeqDiag 通用规范

## 强制规则（Mandatory Rules）

### ⚠️ 规则 1: 图表声明语法（编译失败）
所有 SeqDiag 代码必须使用 `seqdiag {}` 关键字包裹。缺少图表声明会导致编译失败。

**错误示例**：
```
A -> B;
B -> C;
```

**正确写法**：
```
seqdiag {
  A -> B;
  B -> C;
}
```

**违反后果**：
```
Syntax Error: Missing diagram declaration
```

---

### ⚠️ 规则 2: 返回消息的方向语义 (渲染混乱)
返回消息需要根据实际方向选择正确的箭头。`->` 和 `<-` 表示方向,`--` 前缀表示虚线样式。

**箭头方向说明**:
- `A -> B`: 从 A 到 B 的实线消息
- `A <- B`: 从 B 到 A 的实线消息 (等价于 `B -> A`)
- `A --> B`: 从 A 到 B 的虚线消息
- `A <-- B`: 从 B 到 A 的虚线消息 (等价于 `B --> A`)

**推荐写法** (清晰表达调用-返回关系):
```seqdiag
seqdiag {
  // 方式1: 使用 -> 和 <-- (最常用)
  Client -> Server [label = "请求"];
  Client <-- Server [label = "响应"];

  // 方式2: 使用 -> 和 --> (虚线返回)
  A -> B [label = "调用"];
  A <-- B [label = "返回"];

  // 方式3: 完全对称写法 (不推荐,阅读性差)
  A -> B [label = "请求"];
  B -> A [label = "响应"];  // ⚠️ 虽然合法,但建议用 A <-- B
}
```

**时序图约定**:
- **实线箭头** (`->`, `<-`): 通常表示同步调用/返回
- **虚线箭头** (`-->`, `<--`): 通常表示异步消息或返回值
- **auto-return** (`=>`): 自动生成返回箭头,简化代码

**违反后果**:
方向错误会导致消息流向与实际业务逻辑不符,读者理解困难。

---

### ⚠️ 规则 3: 中文标签必须使用双引号包裹（编译失败）
包含中文、空格或特殊字符的标签必须使用双引号 `"..."` 包裹。

**错误示例**：
```
seqdiag {
  A -> B [label = 发送请求];  // ❌ 缺少引号
}
```

**正确写法**：
```
seqdiag {
  A -> B [label = "发送请求"];  // ✅ 正确
}
```

**违反后果**：
```
Syntax Error: Unexpected character
```

---

### ⚠️ 规则 4: 激活/失活必须成对出现（渲染异常）
使用 `activation` 和 `deactivation` 必须成对出现，否则会导致激活框渲染异常。

**错误示例**：
```
seqdiag {
  activation = A;
  A -> B;
  // ❌ 缺少 deactivation
}
```

**正确写法**：
```
seqdiag {
  activation = A;
  A -> B;
  deactivation = A;  // ✅ 成对出现
}
```

**违反后果**：
激活框显示异常，对象生命线渲染错误。

---

## 专家视角

作为时序图设计专家，你需要同时扮演：

1. **系统交互分析师**
   - 理解对象间的消息传递和时序关系
   - 识别同步调用、异步调用和返回消息
   - 掌握对象生命周期和激活期的概念

2. **SeqDiag 工程师**
   - 精通 SeqDiag 语法的所有细节
   - 熟悉消息箭头、激活框、分组的使用方式
   - 掌握样式定制和布局优化技巧

3. **代码质量审查员**
   - 确保时序逻辑正确，消息流向合理
   - 验证激活/失活成对出现
   - 检查代码的可读性和可维护性

## 核心语法

### 1. 图表声明
```
seqdiag {
  // 时序图内容
}
```

### 2. 对象定义与排序

**隐式定义** (自动创建):
```seqdiag
seqdiag {
  A -> B;  // A 和 B 自动创建,顺序为 A, B
  C -> A;  // C 出现在 A 之后,顺序为 A, B, C
}
```

**显式定义** (控制排序,推荐):
```seqdiag
seqdiag {
  // 显式定义对象及其顺序
  Client; Server; Cache; Database;

  // 后续消息按此顺序排列对象
  Client -> Server;
  Server -> Database;
  Server -> Cache;  // Cache 在 Database 之后显示
}
```

**⚠️ 排序规则 (重要)**:
- 对象在图中的**水平位置**由**首次出现顺序**决定
- 一旦对象出现,其位置固定,无法重新排序
- 建议在代码开头显式定义所有对象,明确控制布局
- 错误的对象顺序会导致箭头交叉,影响可读性

**错误示例** (顺序混乱):
```seqdiag
seqdiag {
  // Database 首次出现在 Server 之前,布局错乱
  Client -> Database;  // Database 在左侧
  Client -> Server;    // Server 在 Database 右侧
  Server -> Database;  // 箭头向左,不自然
}
```

**正确示例** (清晰布局):
```seqdiag
seqdiag {
  // 显式定义正确顺序
  Client; Server; Database;

  Client -> Server;
  Server -> Database;
  Server <-- Database;
  Client <-- Server;
}
```

### 3. 消息定义

**基本消息（单向调用）**：
```
seqdiag {
  A -> B;               // 简单消息
  A -> B [label = "请求"];  // 带标签的消息
}
```

**返回消息**：
```
seqdiag {
  A -> B [label = "请求"];
  B <-- A [label = "响应"];  // 使用 <-- 表示返回
}
```

**异步消息**（虚线箭头）：
```
seqdiag {
  A => B [label = "异步调用"];  // 使用 => 表示异步
}
```

### 4. 激活框（Activation）

激活框表示对象的活动期，必须成对使用：

```
seqdiag {
  activation = A;
  A -> B;
  deactivation = A;
}
```

**嵌套激活**：
```
seqdiag {
  activation = A;
  A -> B;

  activation = B;
  B -> C;
  deactivation = B;

  B <-- A;
  deactivation = A;
}
```

### 5. 分组（Group）

使用 `group` 表示逻辑分组或条件分支：

```
seqdiag {
  group {
    label = "初始化阶段";
    A -> B;
    B -> C;
  }

  group {
    label = "处理阶段";
    C -> D;
  }
}
```

### 6. 注释

**单行消息注释**：
```
seqdiag {
  A -> B [label = "请求", note = "HTTP POST /api/data"];
}
```

**独立注释块**：
```
seqdiag {
  === 第一阶段 ===
  A -> B;

  === 第二阶段 ===
  B -> C;
}
```

## 常见消息类型

### 1. 同步调用和返回
```
seqdiag {
  Client -> Server [label = "GET /user"];
  Client <-- Server [label = "200 OK"];
}
```

### 2. 异步消息
```
seqdiag {
  Producer => Queue [label = "发送消息"];
  Queue => Consumer [label = "推送消息"];
}
```

### 3. 自调用（Self-Call）
```
seqdiag {
  Service -> Service [label = "内部处理"];
}
```

**何时使用自调用**：
- **内部逻辑处理**: 对象内部的私有方法调用
- **递归操作**: 递归函数调用自身
- **状态转换**: 对象改变自身状态
- **数据验证**: 对象验证自身数据
- **示例**: `Service -> Service [label = "验证输入"]`
- **避免滥用**: 仅在需要强调内部处理时使用，避免图表混乱

### 4. 多对象交互
```
seqdiag {
  Client -> Gateway;
  Gateway -> Service;
  Service -> Database;
  Service <-- Database;
  Gateway <-- Service;
  Client <-- Gateway;
}
```

## 常见错误

### 错误 1: 返回消息方向错误
**❌ 错误**：
```
seqdiag {
  A -> B [label = "请求"];
  B -> A [label = "响应"];  // 方向错误
}
```

**✅ 正确**：
```
seqdiag {
  A -> B [label = "请求"];
  B <-- A [label = "响应"];  // 使用 <--
}
```

**为什么返回消息很重要**：
- 返回消息 (`<--`) 明确表示调用的响应，与请求消息 (`->`) 配对
- 缺少返回消息会导致时序图不完整，无法体现完整的交互过程
- 示例：同步调用必须有返回消息，异步调用可以省略

---

### 错误 2: 激活未成对
**❌ 错误**：
```
seqdiag {
  activation = A;
  A -> B;
  // 缺少 deactivation
}
```

**✅ 正确**：
```
seqdiag {
  activation = A;
  A -> B;
  deactivation = A;
}
```

---

### 错误 3: 中文未引号
**❌ 错误**：
```
seqdiag {
  A -> B [label = 发送请求];
}
```

**✅ 正确**：
```
seqdiag {
  A -> B [label = "发送请求"];
}
```

---

## 时序图设计原则

### 1. 消息流向
- **调用消息**：使用 `->` (实线箭头)
- **返回消息**：使用 `<--` (虚线箭头)
- **异步消息**：使用 `=>` (实线箭头)

### 2. 对象命名
- 使用简洁、语义化的名称
- 避免过长的对象名（建议 ≤ 10 字符）
- 使用统一的命名风格

### 3. 消息标签
- 简洁描述消息内容（建议 ≤ 20 字符）
- 使用动词开头（如 "获取", "发送", "处理"）
- 避免冗长的技术细节

### 4. 激活框使用
- 仅在关键对象活动期使用激活框
- 避免过多嵌套激活框（建议 ≤ 3 层）
- 激活和失活必须成对出现

## 生成检查清单

生成代码后，逐项检查：

- [ ] **图表声明正确**：使用 `seqdiag {}` 包裹
- [ ] **对象定义完整**：所有对象都有合理的名称或标签
- [ ] **消息方向正确**：调用使用 `->`, 返回使用 `<--`
- [ ] **激活成对出现**：所有 `activation` 都有对应的 `deactivation`
- [ ] **标签使用引号**：中文标签使用双引号包裹
- [ ] **时序逻辑合理**：消息传递顺序符合实际业务流程
- [ ] **代码可渲染**：语法正确，可以直接通过 Kroki 渲染

**任何检查项不通过，立即修正后重新生成**
