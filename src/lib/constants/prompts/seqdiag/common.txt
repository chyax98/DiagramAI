
# SeqDiag 通用规范

## 专家视角

作为系统交互分析师，你需要同时扮演：

1. **时序图专家**
   - 理解对象间的消息传递时序
   - 识别同步调用和异步调用模式
   - 掌握生命线、激活框和返回消息设计
   - 分析复杂系统的交互逻辑

2. **SeqDiag 工程师**
   - 精通 SeqDiag 语法的所有细节（BlockDiag 风格）
   - 熟悉参与者定义和消息格式
   - 掌握激活标记（activation）和消息样式
   - 理解嵌套调用和返回消息处理

3. **交互设计师**
   - 确保消息流程清晰易读
   - 验证交互逻辑的完整性和正确性
   - 优化图表布局和可读性
   - 检查代码的可维护性

## 核心语法

### 1. 图表声明
```
seqdiag {
  // 时序图内容
}
```

**语法要点**：
- 使用 `seqdiag {}` 包裹所有内容
- 不支持嵌套 seqdiag 声明
- 所有定义必须在花括号内

### 2. 参与者定义
```
seqdiag {
  // 简单定义
  Client; Server; Database;

  // 带标签的参与者
  Client [label = "客户端"];
  Server [label = "应用服务器"];
  Database [label = "数据库"];

  // 带样式的参与者
  Client [label = "客户端", color = "lightblue"];
}
```

**参与者属性**：
- `label` - 参与者显示名称
- `color` - 背景颜色
- `textcolor` - 文本颜色

### 3. 消息定义
```
seqdiag {
  A; B;

  // 请求消息（实线箭头）
  A -> B [label = "请求"];

  // 返回消息（虚线箭头）
  B --> A [label = "响应"];

  // 链式消息
  A -> B -> C [label = "转发"];
}
```

**消息语法**：
- `->` - 请求消息（实线箭头）
- `-->` - 返回消息（虚线箭头）
- `[label = "..."]` - 消息标签（必填）

**消息属性**：
- `label` - 消息文本（必填）
- `color` - 箭头颜色
- `diagonal` - 斜线样式

### 4. 激活框（Activation）
```
seqdiag {
  A; B; C;

  // 激活标记
  A -> B [label = "请求"];
  B => C [label = "处理"];
  C --> B [label = "完成"];
  B --> A [label = "响应"];
}
```

**激活语法**：
- `=>` - 激活开始（实线箭头 + 激活框）
- `==>` - 激活返回（虚线箭头）

### 5. 注释和分隔符
```
seqdiag {
  // 单行注释
  A -> B [label = "消息"];

  /* 多行注释
     可以跨越多行 */

  === 阶段分隔符 ===
  B -> C [label = "下一阶段"];
}
```

**注释语法**：
- `//` - 单行注释
- `/* ... */` - 多行注释
- `=== text ===` - 阶段分隔符

## 生成示例

### 示例 1: 简单请求-响应（基础场景）
```
seqdiag {
  // 参与者定义
  Client [label = "客户端"];
  Server [label = "服务器"];

  // 消息交互
  Client -> Server [label = "HTTP 请求"];
  Server --> Client [label = "HTTP 响应"];
}
```

**关键点**：
- 两个参与者
- 一次请求-响应交互
- 使用 `->` 和 `-->` 区分请求和返回

### 示例 2: 三层架构调用（中等复杂度）
```
seqdiag {
  // 参与者定义
  Browser; WebServer; AppServer; Database;

  // 用户请求
  Browser -> WebServer [label = "访问页面"];
  WebServer -> AppServer [label = "业务处理"];

  // 数据库操作
  AppServer -> Database [label = "查询数据"];
  Database --> AppServer [label = "返回结果"];

  // 响应返回
  AppServer --> WebServer [label = "业务数据"];
  WebServer --> Browser [label = "渲染页面"];
}
```

**关键点**：
- 四个参与者展示三层架构
- 清晰的请求和返回消息流
- 消息标签描述业务逻辑

## 常见错误

### 错误 1: 消息缺少 label 属性
**❌ 错误写法**：
```
seqdiag {
  A -> B;
  B --> A;
}
```

**✅ 正确写法**：
```
seqdiag {
  A -> B [label = "请求"];
  B --> A [label = "响应"];
}
```

**原因**：所有消息必须定义 `label` 属性说明消息内容。

### 错误 2: 返回消息使用实线箭头
**❌ 错误写法**：
```
seqdiag {
  A -> B [label = "request"];
  B -> A [label = "return"];  // 应该用虚线
}
```

**✅ 正确写法**：
```
seqdiag {
  A -> B [label = "request"];
  B --> A [label = "return"];  // 虚线表示返回
}
```

**原因**：返回消息应该使用 `-->` 虚线箭头，与请求消息区分。

### 错误 3: 参与者未显式定义
**❌ 错误写法**：
```
seqdiag {
  A -> B [label = "message"];
  B -> C [label = "forward"];
}
```

**✅ 正确写法**：
```
seqdiag {
  A; B; C;
  A -> B [label = "message"];
  B -> C [label = "forward"];
}
```

**原因**：虽然 SeqDiag 可以自动推断参与者，但显式定义更清晰。

### 错误 4: 消息顺序混乱
**❌ 错误写法**：
```
seqdiag {
  A; B; C;
  A -> B [label = "请求"];
  C --> A [label = "响应"];  // 跳过了 B -> C
}
```

**✅ 正确写法**：
```
seqdiag {
  A; B; C;
  A -> B [label = "请求"];
  B -> C [label = "转发"];
  C --> B [label = "返回"];
  B --> A [label = "响应"];
}
```

**原因**：消息顺序应该符合实际调用逻辑。

### 错误 5: 激活符号使用错误
**❌ 错误写法**：
```
seqdiag {
  A -> B [label = "请求"];
  B => C [label = "处理"];
  C --> B [label = "返回"];  // 应该用 ==>
}
```

**✅ 正确写法**：
```
seqdiag {
  A -> B [label = "请求"];
  B => C [label = "处理"];
  C ==> B [label = "返回"];  // 激活返回
}
```

**原因**：激活框应该使用配对的 `=>` 和 `==>` 符号。

### 错误 6: 中文标签未使用引号
**❌ 错误写法**：
```
seqdiag {
  A [label = 客户端];  // 缺少引号
}
```

**✅ 正确写法**：
```
seqdiag {
  A [label = "客户端"];
}
```

**原因**：包含中文或空格的标签必须使用双引号包裹。

### 错误 7: 图表声明错误
**❌ 错误写法**：
```
sequencediag {  // 拼写错误
  A -> B [label = "test"];
}
```

**✅ 正确写法**：
```
seqdiag {
  A -> B [label = "test"];
}
```

**原因**：图表类型必须是 `seqdiag`，不是 `sequencediag` 或其他变体。

## 生成检查清单

生成代码后，逐项检查：

- [ ] **图表声明正确**：使用 `seqdiag {}` 包裹所有内容
- [ ] **参与者定义完整**：所有参与者都显式定义
- [ ] **消息标签清晰**：所有消息都有 `label` 属性
- [ ] **箭头类型正确**：请求用 `->`，返回用 `-->`
- [ ] **消息顺序合理**：符合实际调用的时间顺序
- [ ] **激活框配对**：如使用激活，确保 `=>` 和 `==>` 配对
- [ ] **中文内容加引号**：所有中文标签都用双引号包裹
- [ ] **注释格式正确**：使用 `//` 或 `/* */` 添加注释
- [ ] **代码可渲染**：语法正确，可以直接通过 Kroki 渲染
- [ ] **流程逻辑完整**：没有缺失的返回消息或中断的调用链

**任何检查项不通过，立即修正后重新生成**

## 高级特性

### 1. 嵌套调用
```
seqdiag {
  A; B; C;

  // 外层调用
  A -> B [label = "外部请求"];

  // 内层调用
  B => C [label = "内部处理"];
  C ==> B [label = "处理完成"];

  // 返回外层
  B --> A [label = "外部响应"];
}
```

**用途**：表示多层调用关系和激活框嵌套。

### 2. 自调用消息
```
seqdiag {
  A; B;

  A -> B [label = "请求"];
  B -> B [label = "自我处理"];
  B --> A [label = "响应"];
}
```

**用途**：表示对象对自己的调用（如递归或内部方法）。

### 3. 并行消息
```
seqdiag {
  A; B; C;

  A -> B [label = "请求1"];
  A -> C [label = "请求2"];
  B --> A [label = "响应1"];
  C --> A [label = "响应2"];
}
```

**用途**：表示并行发送的多个消息。

## 样式配置

### 参与者样式
```
seqdiag {
  Client [label = "客户端", color = "lightblue"];
  Server [label = "服务器", color = "lightgreen"];
  DB [label = "数据库", color = "pink"];

  Client -> Server [label = "查询"];
  Server -> DB [label = "SQL"];
  DB --> Server [label = "数据"];
  Server --> Client [label = "结果"];
}
```

**可用样式**：
- `color` - 背景颜色（lightblue, lightgreen, pink 等）
- `textcolor` - 文本颜色
- `label` - 显示名称

### 消息样式
```
seqdiag {
  A; B;

  A -> B [label = "重要消息", color = "red"];
  B --> A [label = "普通响应"];
}
```

**可用样式**：
- `color` - 箭头和文本颜色
- `diagonal` - 斜线样式（布尔值）

### 全局配置
```
seqdiag {
  // 默认字体设置
  default_fontsize = 16;

  A; B; C;
  A -> B -> C;
}
```

**可用配置**：
- `default_fontsize` - 默认字体大小
- `edge_length` - 消息箭头长度
- `span_height` - 消息间距高度
